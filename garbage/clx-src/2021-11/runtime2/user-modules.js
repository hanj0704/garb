/// start - 202004/aaa
/*
 * Module URI: 202004/aaa
 * SRC: 202004/aaa.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202004/aaa", function(exports, globals, module){
		/************************************************
		 * aaa.module.js
		 * Created at 2020. 4. 10. 오후 6:24:19.
		 *
		 * @author HANS
		 ************************************************/
		
		globals.glob = function(app){
			
		}
		
		function abc(app){
		
		}
		
		
		abc.prototype.abcd = function(){
			
		};
		
		
		var smallAbc = new abc();
		
	});
})();
/// end - 202004/aaa
/// start - 202005/sampleUtil
/*
 * Module URI: 202005/sampleUtil
 * SRC: 202005/sampleUtil.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202005/sampleUtil", function(exports, globals, module){
		exports.id = "sampleUtil.module.js";
		
		
		{
			var SampleUtil = function() {
				
			}
			
			/**
			 * lengthUnit 속성값이 utf8인 인풋박스의 byteLength 길이를 가져옵니다.
			 * @param {cpr.controls.InputBox} inputbox 인풋박스
			 */
			SampleUtil.prototype.getUtfByteLength = function(/* cpr.controls.InputBox */inputbox){
				var byte = 0;
				var i = 0;
				var code;
				var target = inputbox;
				var inputValue = target.value;
				
				if(!inputbox){
					return;
				}
				
				if(target.lengthUnit != "utf8"){
					alert("lengthUnit 속성값이 utf8이어야합니다.");
					return;
				}
				
				if(inputValue.length == 0){
					return 0;
				}
				
				var index = 0;
				var length = inputValue.length;
				var output = [];
			
				for (; index < length - 1; ++index) {
					var charCode = inputValue.charCodeAt(index);
					if (charCode >= 0xD800 && charCode <= 0xDBFF) {
						charCode = inputValue.charCodeAt(index + 1);
						if (charCode >= 0xDC00 && charCode <= 0xDFFF) {
							output.push(inputValue.slice(index, index + 2));
							++index;
			
							if (index == inputValue.length - 1) {
								return output;
							}
							continue;
						}
					}
					output.push(inputValue.charAt(index));
				}
				output.push(inputValue.charAt(index));
				
				var arr = output;
				
				for (byte = 0, i = 0; i < arr.length; i++) {
					code = arr[i].charCodeAt(0) > 127 ? '0x' + encodeURI(arr[i]).replace(/%/g, '') : arr[i].charCodeAt(0);
					code > 0xFFFFFF ? byte += 4 : byte += code >> 11 ? 3 : code >> 7 ? 2 : 1;
				};
				
				return byte;
			};
			
		}
		
		
		globals.SampleUtil = function() {
				return new SampleUtil();
		}
		
	});
})();
/// end - 202005/sampleUtil
/// start - 202007/customMod
/*
 * Module URI: 202007/customMod
 * SRC: 202007/customMod.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202007/customMod", function(exports, globals, module){
		/************************************************
		 * customMod.module.js
		 * Created at 2020. 7. 13. 오후 5:49:15.
		 * 해당 모듈은 이후에 추가될 모듈에 대해서, 선행적으로 추가하여 기능에 대한 가이드를 돕기 위해 작성되었습니다.
		 * 해당 모듈 내에 작성되어있는 함수는 이후에 다른 모듈로 이동하여 선언될 수 있습니다.
		 * @author han
		 ************************************************/
		/** @type cpr.data.DataSet */
		var dsMan;
		
		/**
		 * 
		 */
		//globals.createComboModule = function(){
		//	
		//	var submission = new cpr.protocols.Submission();
		//	submission.action = "data/scrnComCd.json";
		//	submission.async = true;
		//	
		//	submission.send();
		//	
		//	submission.addEventListener("submit-done", function(e){
		//		
		//		var sub = e.control;
		//	
		//		var response = sub.xhr.responseText;
		//		var jsonObj = JSON.parse(response);
		//		var vaScrnComCd = jsonObj["scrnComCd"];
		//		var vaNames = [];
		//		Object.keys(vaScrnComCd[0]).forEach(function(each){
		//			
		//			vaNames.push({"name" : each});
		//		});
		//		
		//		var newDs = new cpr.data.DataSet();
		//		
		//		newDs.parseData({
		//			"columns" : vaNames,
		//			"rows" : vaScrnComCd
		//		});
		//		
		//		 dsMan = newDs;
		//		console.log(newDs.getRowCount());
		//		console.log(newDs.getRowDataRanged());
		//		
		//	});
		//}
		
		//cpr.events.EventBus.INSTANCE.addFilter("load", function(e){
		//	var control = e.control;
		//	
		//	if(control instanceof cpr.core.AppInstance){
		//		
		//		control.getContainer().getAllRecursiveChildren().forEach(function(each){
		//			
		//			if(each.type =="combobox") {
		//				/** @type cpr.controls.ComboBox */
		//				var vcCombo = each;
		//				
		//				var vsFilter = vcCombo.userAttr("filt");
		//				if(vsFilter != ""){
		//					
		//					var dataView = new cpr.data.DataView(vcCombo.uuid, dsMan);
		//					dataView.setFilter(vsFilter);
		//					vcCombo.setItemSet(dataView, {
		//						"label" : "SCRN_PRN_CD_CTT",
		//						"value" : "SCRN_PRN_CD"
		//					});
		//				}				
		//			}
		//		});
		//	}
		//});
		
		//cpr.events.EventBus.INSTANCE.addFilter("load", function(e){
		//	var control = e.control;
		//	
		//	if(control instanceof cpr.core.AppInstance) {
		//		
		//		var vaCombos = control.getContainer().getAllRecursiveChildren().filter(function(each){
		//			
		//			if(each.type == "combobox") {
		//				return each;
		//			}
		//		});
		//		
		//		if(vaCombos.length > 0) {
		//			
		//	
		//		var vcInputDataSet = new cpr.data.DataSet();
		//			
		//			vcInputDataSet.parseData({
		//				"columns" : [{"name": "filter"}]
		//			});
		//			
		//		var vcOutputDataSet = new cpr.data.DataSet();
		//			
		//			vcOutputDataSet.parseData({
		//				"columns" : [
		//					{"name": "filter"},
		//					{"name": "value"},
		//					{"name": "name"}
		//				]
		//			});
		//			
		//		vaCombos.forEach(function(/*cpr.controls.ComboBox*/each){
		//			
		//			var vsFiltOpts = each.userAttr("filtOpts");
		//			
		//			if(vsFiltOpts) {
		//				vcInputDataSet.insertRow(vcInputDataSet.getRowCount(), vsFiltOpts);
		//				
		//			}
		//			});
		//			var submission = new cpr.protocols.Submission();
		//			
		//			submission.action = "/COMBOBOX.SVC";
		//			submission.async = true;
		//			submission.mediaType = "application/json"
		//			submission.addRequestData(vcInputDataSet,"cmbInpGrid");
		//			submission.addResponseData(vcOutputDataSet, false, "cmbOutgrid");
		//			submission.send();
		//			
		//			submission.addEventListener("submit-done", function(e){
		//				/** @type cpr.protocols.Submission */
		//				var vcSub = e.control;
		//				if(vcSub.isSuccess()) {
		////					/** @type JSON */
		////					var voJSON = JSON.parse(vcSub.xhr.responseText);
		////					
		////					var vaResponse = Object.keys(voJSON).map(function(each){
		////						return voJSON[each];
		////					});
		//					vaCombos.forEach(function(/*cpr.controls.ComboBox*/each){
		//						
		//						var dataView = new cpr.data.DataView(each.uuid,vcOutputDataSet);
		//						dataView.setFilter("filter =='"+each.userAttr("filtOpts")+"'");
		//						each.setItemSet(dataView, {
		//							"label" : "label",
		//							"value" : "value"
		//						});
		//					});
		//				}
		//			});
		//			}
		//	}
		//});
		
		/** @type cpr.data.DataMap */
		var dms;
		
		/**
		 * 미리 정의된 파일을 읽어서 
		 */
		globals.configDataMap = function(){
		/** @type {dataMapId:String,dataMapColumn:Array,dataMapDatas:{},optionalProperties:{}} */	
			var voDmConfig = dmConfig;
			
			var dataMap = new cpr.data.DataMap(voDmConfig.dataMapId);
				
			var vsAlterColumnLayout = "client";
			
			var voDataMapConfigObj = {
				alterColumnLayout : vsAlterColumnLayout,
				columns : voDmConfig.dataMapColumn,
				data : voDmConfig.dataMapDatas
				
			}
		
			var voOptionalProp = voDmConfig.optionalProperties;
		
			if(voOptionalProp) {
				var vaKeys = Object.keys(voOptionalProp);
				vaKeys.forEach(function(each){
					
					voDataMapConfigObj[each] = voOptionalProp[each];
				});
			}
			dataMap.parseData(voDataMapConfigObj);
			
			dms = dataMap;
		}
		
		
		globals.configDataMap2 = function(){
		//	/** @type {dataMapId:String,dataMapColumn:Array,dataMapDatas:{},optionalProperties:{}} */	
		//	var voDmConfig = dmConfig;
			
			var submission = new cpr.protocols.Submission();
			
			submission.action = "data/FXFIG2.json";
			submission.async = true;
			submission.send();
			
			submission.addEventListener("submit-done", function(e){
				/** @type cpr.protocols.Submission */
				var vcSub = e.control;
				
				var voJSON = JSON.parse(vcSub.xhr.responseText);
				
				var vaKeys = Object.keys(voJSON);
				
				var dataMap = new cpr.data.DataMap("FxFig");
				vaKeys.forEach(function(each){
					
					/** @type {Array} */
					var vaDatas = voJSON[each];
					
					vaDatas.forEach(function(/**{key:String,value:any}*/colms){
						dataMap.addColumn(new cpr.data.header.Header(colms.key, typeof colms.value), colms.value);
					});
				});
				
				dms = dataMap;
				console.log(dms.getDatas());
			});
			
		}
		globals.getFxfig = function(){
			return dms;
		}
	});
})();
/// end - 202007/customMod
/// start - 202008/htmlCapture
/*
 * Module URI: 202008/htmlCapture
 * SRC: 202008/htmlCapture.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202008/htmlCapture", function(exports, globals, module){
		/************************************************
		 * htmlCapture.module.js
		 * Created at 2020. 7. 24. 오후 4:30:45.
		 *
		 * @author daye
		 ************************************************/
		
		/*
		 * 본 모듈은 MDI에 띄워진 임베디드앱을 캡쳐하는 모듈입니다.
		 * MDI에 선택된 탭이 없을 경우에는 모듈에서 제공하는 기능을 확인 할 수 없습니다.
		 * 
		 * ※ 사용방법 ※
		 * 아래의 작성된 단축키(ALT + A)를 누르면 새로운 창을 통해서 캡쳐된 화면을 확인 할 수 있으며, 본 모듈에서 단축키를 변경 하여 사용이 가능합니다.
		 * 캡쳐 시 띄워지는 화면은 연결되어있는 web프로젝트의 WebContent 하위에 배치되어 있는 jsp 파일을 호출합니다.
		 * jsp파일의 경로를 변경하고자 할 경우엔 작성된 actionUrl을 수정하십시오.
		 * 
		 * ※ 주의사항 ※
		 * - 현재 선택된 임베디드앱을 캡쳐할 경우, 다이얼로그가 메인(root)에 띄워져있을 경우 캡쳐가 되지 않습니다.
		 * - 캡쳐 영역은 전역변수 mbEmbCt가 true면 선택 된 임베디드 앱, false이면 메인(root)를 캡처합니다.
		 */
		
		var mbEmbCt = true;
		window.addEventListener("keydown", function(e) {
			
			// TODO 단축키변경을 하기위해서 아래의 코드를 수정하십시오. (기본 : ALT+A)
			if(e.altKey && e.keyCode == cpr.events.KeyCode.A) {
				
				/* head innerHTML */
				var vsHead = "";
				var head = document.head.cloneNode(true);
				
				// base tag
				var baseTags = head.getElementsByTagName("base");
				var voBase = Object.keys(baseTags).map(function(idx) {
					return baseTags[idx];
				});
				voBase.forEach(function(each) {
					vsHead += each.outerHTML;
				})
				
				// meta tag
				var metaTags = head.getElementsByTagName("meta");
				var voMeta = Object.keys(metaTags).map(function(idx) {
					return metaTags[idx];
				});
				voMeta.forEach(function(each) {
					vsHead += each.outerHTML;
				})
				
				// link tag
				var linkTags = head.getElementsByTagName("link");
				var voLink = Object.keys(linkTags).map(function(idx) {
					return linkTags[idx];
				});
				voLink.forEach(function(each) {
					vsHead += each.outerHTML;
				})
				
		//		var scriptTags = head.getElementsByTagName("script");
		//		var voScr = Object.keys(scriptTags).map(function(idx){
		//			return scriptTags[idx];
		//		});
		//		voScr.forEach(function(each){
		//			vsHead += each.outerHTML;
		//		})
		//		console.log(scriptTags);
				
				/* body innerHTML */
				var vsBody; 
				if(mbEmbCt) {
					
					// 현재 MDI폴더에 열린 화면만 캡쳐 할 경우
					var vnSelectedIndex = document.querySelectorAll(".cl-selected.cl-tabfolder-item.cl-unselectable")[0].getAttribute("data-itemidx");
					var EmbClasses = document.querySelectorAll(".cl-control.cl-embeddedapp");
					var voEmb = Object.keys(EmbClasses).map(function(idx) {
						return EmbClasses[idx];
					});
					voEmb.forEach(function(each) {
						if(each.parentNode.id.indexOf("tb"+vnSelectedIndex) != -1) {
							vsBody = each.cloneNode(true);
						}
					});
				} else {
					
					// 메인의 전체 화면을 캡쳐 할 경우
					vsBody = document.body.cloneNode(true);
					vsBody.firstChild.style.position = "absolute";
				}
				
				/* input tag value setting */
				var inputTags = vsBody.getElementsByTagName("input");
				var voInput = Object.keys(inputTags).map(function(idx) {
					return inputTags[idx];
				});
				voInput.forEach(function (each) {
					each.setAttribute("value", each.value);
				});
				
				/* textarea tag value setting */
				var textAreaTags =vsBody.getElementsByTagName("textarea");
				var voTextarea = Object.keys(textAreaTags).map(function(idx) {
					return textAreaTags[idx];
				});
				voTextarea.forEach(function (each) {
					each.innerText = each.value;
				});
				
				/* create cover */
		//		var cover = document.createElement("div");
		//		cover.style.position = "absolute";
		//		cover.style.top = "0";
		//		cover.style.left = "0";
		//		cover.style.width = "100%";
		//		cover.style.height = "100%";
		//		cover.style.zIndex = "100";
		//		vsBody.firstChild.appendChild(cover);
				
				// 미리 생성한 JSP를 호출하여 head, body에 내용을 전달합니다.
				// TODO 호출 jsp파일의 경로가 변경되었을 경우 아래의 url을 수정하십시오.
				var post = new cpr.protocols.HttpPostMethod("202008/capture.jsp", "_blank");
				post.addParameter("head", vsHead);
				post.addParameter("body", vsBody.innerHTML);
				post.submit();
				post.dispose();
			}
		});
		
	});
})();
/// end - 202008/htmlCapture
/// start - 202008/I4331
/*
 * Module URI: 202008/I4331
 * SRC: 202008/I4331.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202008/I4331", function(exports, globals, module){
		/************************************************
		 * I4331.module.js
		 * Created at 2020. 3. 13. 오전 11:24:03.
		 *
		 * @author jeeeyul
		 ************************************************/
		
		//cpr.core.App.addHook({
		//	// App.load 트리거.
		//	onLoad: function(appId, loader) {
		//		console.log(appId);
		//		// I4311-emb 앱이 로드 될 때 I4331-dep.js가 함께 로드 되도록 함.
		//		if (appId == "202008/tester") {
		//			loader.addScript("data/FXFIG2.json");
		//		}
		//	},
		//	
		//	// 앱 델리게이트 onPrepare 트리거.
		//	onPrepare: function(app, loader) {
		//		if (app.app.id == "_MILESTONE_ISSUES_/2020/R-13/I4331-content/I4331-emb") {
		//		}
		//	},
		//	
		//	// 앱 델리게이트 onCreate 트리거.
		//	onCreate: function(app, exports) {
		//		// 4311이 앱 아이디에 포함된 경우, 앱 컨테이너의 보더 색상을 변경 함.
		//		if (app.app.id.indexOf("4331") !== -1) {
		//			app.getContainer().style.css("border", "solid 5px orange");
		//		}
		//	}
		//});
	});
})();
/// end - 202008/I4331
/// start - 202010/abcd
/*
 * Module URI: 202010/abcd
 * SRC: 202010/abcd.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202010/abcd", function(exports, globals, module){
		/************************************************
		 * abcd.module.js
		 * Created at 2020. 10. 20. 오후 6:43:58.
		 *
		 * @author HANS
		 ************************************************/
		
		
		/**
		 * 
		 * @param {cpr.core.AppInstance} _app
		 */
		globals.abc = function(_app){
			
			_app.openDialog("202010/GridWidthConfigurer", {width : 400, height : 300}, function(dialog){
				dialog.ready(function(dialogApp){
					// 필요한 경우, 다이얼로그의 앱이 초기화 된 후, 앱 속성을 전달하십시오.
				});
			}).then(function(returnValue){
				
				return returnValue;
			});
		}
	});
})();
/// end - 202010/abcd
/// start - 202010/moveTab
/*
 * Module URI: 202010/moveTab
 * SRC: 202010/moveTab.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202010/moveTab", function(exports, globals, module){
		/************************************************
		 * moveTab.module.js
		 * Created at 2020. 9. 14. 오후 3:29:13.
		 *
		 * @author daye
		 * 
		 * [ 수정사항 ]
		 * - Drop 시 영역을 벗어났을 때, 타겟스타일이 삭제되도록 수정되었습니다. (2020.09.16)
		 * - 타겟영역을 border 가 아닌 backgroud-color 색상으로 변경되었습니다. 타겟 아이템의 뒤로 탭아이템이 이동하도록 수정되었습니다. (2020.09.16)
		 * 
		 ************************************************/
		
		/*
		 * 본 모듈은 탭 아이템을 이동 할 수 있는 모듈입니다.
		 * 탭폴더(또는 MDI 폴더)의 사용자속성(tabMovable=true)을 설정하면 모듈에서 제공하는 기능을 사용 할 수 있습니다.
		 */
		
		/************************************************
		 * 전역변수
		 ************************************************/
		/**
		 * 이전 타겟이였던 탭아이템
		 */
		var moPrevTargetItem = null;
		
		
		
		/************************************************
		 * 이벤트 필터
		 ************************************************/
		cpr.events.EventBus.INSTANCE.addFilter("load", fn_load);
		
		function fn_load(e) {
			var control = e.control;
			
			if(control instanceof cpr.core.AppInstance) {
				var container = control.getContainer();
				var vaTabFolder = container.getAllRecursiveChildren().filter(function(each){
					return each.userAttr("tab-movable")=="true";
				});
				
				vaTabFolder.forEach(function(ctrl){
					_setDragSource(control, ctrl);
					_setDropTarget(control, ctrl);
				});
			}
		}
		
		/**
		 * 드래그 중인 걸 표시하기 위한 컨트롤 생성
		 * @param {cpr.controls.UIControl} pcDragCtrl
		 * @param {cpr.controls.TabItem item
		 */
		function _createDragSourceFeedback(pcDragCtrl, item) {
		
			var feedback = new cpr.controls.Output();
			var voItemEl = document.getElementById("uuid-"+pcDragCtrl.uuid).querySelectorAll(".cl-tabfolder-item").item(item.itemIndex); 
			var voStyle = getComputedStyle(voItemEl); 
			
			/* 현재의 탭 스타일과 동일하게 적용 */
			// TODO 탭스타일 또는 클래스를 적용하십시오.
		//	feedback.style.css({
		////		"opacity" : "0.7",
		//		"width" : voStyle.width,
		//		"background": voStyle.background,
		//		"border-top" : voStyle.borderTop,
		//		"border-left" : voStyle.borderLeft,
		//		"border-right" : voStyle.borderRight,
		//		"border-bottom" : voStyle.borderBottom,
		//		"color": voStyle.color,
		//		"font" : voStyle.font,
		//		"overflow" : voStyle.overflow,
		//		"padding" : voStyle.padding,
		//		"text-align": voStyle.textAlign,
		//	});
			
			feedback.style.css({
				"opacity": "0.8",
				"text-align": "center",
				"color": "black",
				"border-radius": "10px",
				"background": "white",
				"box-shadow": "0px 2px 10px #ddd",
				"cursor": "move"
			});
		
		//	feedback.style.addClass("className");
		
			feedback.userAttr("drag", "true");
		
			return feedback;
		}
		
		/**
		 * 드래그 소스 설정
		 * @param {cpr.core.AppInstance} app
		 * @param {cpr.controls.UIControl} pcDragCtrl
		 */
		function _setDragSource(app, pcDragCtrl) {
		
			var feedback = null;
			
			var dragSource = new cpr.controls.DragSource(pcDragCtrl, {
				options: {
					dataType: "text",
					threadhold: 10 // 10px만큼 이동해야 드래그시작으로 인식
				},
				onDragStart: function(context) {
					if(context.sourceTargetObject != null && context.sourceTargetObject.item instanceof cpr.controls.TabItem) {
						var voTabItem = context.sourceTargetObject.item;
						
						context.cursor = "grabbing";
						context.data = voTabItem;
						
						feedback = _createDragSourceFeedback(pcDragCtrl, voTabItem);
						feedback.value = voTabItem.text;
						
						var voItemRect = voTabItem.getActualRect();	
						
						var vnDrgStartLocation = context.dragStartLocation;
						if(voItemRect.top > vnDrgStartLocation.y || (voItemRect.top + voItemRect.height) < vnDrgStartLocation.y) {
							context.cancel();
						} else {
							var newRect =cpr.controls.layouts.XYLayout.createConstraintWithRect(voItemRect);
							app.getRootAppInstance().floatControl(feedback, newRect);
						}
					} else {
						context.cancel();
					}
				},
				onDragMove: function(context) {
					context.cursor = "grabbing";
					
					/* 탭아이템 영역 안에서만 드래그가 가능하도록 rect 설정 */
					var voActuralRect = context.data.getActualRect();
					var voTraslateRect = voActuralRect.getTranslatedByDimension(context.dragDelta);
					var newRect = new cpr.geometry.Rectangle(voTraslateRect.left, voActuralRect.top, voTraslateRect.width, voTraslateRect.height);
					
					app.getRootAppInstance().floatControl(feedback, newRect);
				},
				onDragEnd: function(context) {
					context.cursor = "";
					feedback.dispose();
					feedback = null;
					
					/* 포커스 스타일 제거 */
					if(moPrevTargetItem) {
		//				moPrevTargetItem.style.border = "0px";
						moPrevTargetItem.style.backgroundColor = "white";
						moPrevTargetItem = null;
					}
				}
			});
		}
		
		
		
		/**
		 * 
		 * @param {cpr.core.AppInstance} app
		 * @param {cpr.controls.UIControl} pcDropCtrl
		 */
		function _setDropTarget(app, pcDropCtrl) {
			
		//	var vaTargetItems = document.getElementById("uuid-"+pcDropCtrl.uuid).querySelectorAll(".cl-tabfolder-item");	
		//	var voTargetEl = null;
		//	var feedback = null;
			
			var dropTarget = new cpr.controls.DropTarget(pcDropCtrl, {
				isImportant: function(source) {
					return source.dataType == "text";
				},
				onDragEnter: function(context) {
		//			feedback = app.getFloatingControls().filter(function(each){
		//				return each.userAttr("drag") == "true";
		//			})[0];
				},
				onDragLeave: function(context) {
					
				},
				onDragMove: function(context) {
					
		//			if(context.targetItem instanceof cpr.controls.TabItem) {
		//				var voTargetItem = context.targetItem;
		//				vnTargetIndex = voTargetItem.itemIndex;
		//				voTargetEl = vaTargetItems.item(vnTargetIndex);
		//			}
		//			
		//			if(feedback) {
		//
		//				var vnTabSpacing = context.target.control.itemSpacing;
		//				var voFeedbackRect = feedback.getActualRect();
		//				
		////				voNewTab.visible = true;
		//				pcDropCtrl.insertTabItem(vnTargetIndex, voNewTab);
		//			}
					
					context.cursor = context.targetItem ? "grabbing" : "no-drop";
					if(context.targetItem instanceof cpr.controls.TabItem && context.source.control.id == context.target.control.id) {
						var voTargetItem = context.targetItem;
		
						if (moPrevTargetItem) {
							moPrevTargetItem.classList.remove("mv-left");
							moPrevTargetItem.classList.remove("mv-right");
		//					moPrevTargetItem.style.border = "0px";
							moPrevTargetItem.style.backgroundColor = "white";
						}
		
						var voTargetEl = document.getElementById("uuid-"+pcDropCtrl.uuid).querySelectorAll(".cl-tabfolder-item").item(voTargetItem.itemIndex);
						if(voTargetEl) {
							
							var voItemRect = voTargetItem.getActualRect();
							var vnTabSpacing = context.target.control.itemSpacing;
							var vnDragDeltaX = context.dragStartLocation.x + context.dragDelta.width;
							
							if(vnDragDeltaX  <= (voItemRect.left + parseInt(voItemRect.width)/2 )) { // background-color : rgba(255, 0, 0,0.3);
								voTargetEl.setAttribute("style", voTargetEl.style.cssText + "background-color: rgba(255, 0, 0,0.3);");
								voTargetEl.classList.add("mv-left");
							} else {
								voTargetEl = document.getElementById("uuid-"+pcDropCtrl.uuid).querySelectorAll(".cl-tabfolder-item").item(voTargetItem.itemIndex+1);
								if(voTargetEl) {
									voTargetEl.setAttribute("style", voTargetEl.style.cssText + "background-color: rgba(255, 0, 0,0.3);");
									voTargetEl.classList.add("mv-right");
								}
							}
		
							moPrevTargetItem = voTargetEl;
						}
						
					}
		
					
				},
				onDrop: function(context) {
					
					/** @type cpr.controls.TabFolder */
					var vcTabfolder = context.source.control;
		
		//			if(context.targetItem instanceof cpr.controls.TabItem) {
					if(moPrevTargetItem) {
						
						/* 탭아이템 이동 */
						var vbDirection = moPrevTargetItem.classList.contains("mv-right") ? true : false;
						var vnMvIndex = _.values(document.getElementById("uuid-"+pcDropCtrl.uuid).querySelectorAll(".cl-tabfolder-item")).indexOf(moPrevTargetItem);
						vcTabfolder.removeTabItem(context.data);
						vcTabfolder.insertTabItem(vnMvIndex, context.data);
					}
				}
			});
		}
		
	});
})();
/// end - 202010/moveTab
/// start - 202011/ExportUtil
/*
 * Module URI: 202011/ExportUtil
 * SRC: 202011/ExportUtil.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202011/ExportUtil", function(exports, globals, module){
		/************************************************
		 * ExportUtil.module.js
		 * Created at 2020. 11. 27. 오후 4:11:24.
		 *
		 * @author HANS
		 ************************************************/
		
		StyleUtil = {
			/**
			 * 
			 * @param {Object} poStyleObj
			 */
			_styleTransfer: function(poStyleObj) {
				
				var results = {
					"border": {},
					"fill": {},
					"font":{},
					"alignment":{}
				};
				
				var vaKeys = Object.keys(poStyleObj);
				
				var border = ["border-top-width",
					"border-top-color",
					"border-right-width",
					"border-right-color",
					"border-bottom-width",
					"border-bottom-color",
					"border-left-width",
					"border-left-color"
				];
				var fill = ["color",
					"background-color"
				]
				
				for (var i = 0; i <= border.length - 2; i += 2) {
					
					if (poStyleObj[border[i]] != undefined) {
						var direction = border[i].split("-")[1];
						var colors = poStyleObj[border[i + 1]].toString().substring(1);
						results.border[direction] = {
							"style": 'thin',
							color: {
								argb: "FF" + colors
							}
						}
					}
				}
				
				var bgColor = 	poStyleObj["background-color"] != undefined ? "FF"+poStyleObj["background-color"].toString().substring(1) : "FFFFFFFF";
					results.fill = {
						"type": "pattern",
						"pattern": "solid",
						"fgColor": {
							"argb": bgColor
						}
					}
					results.font = {
						name : "sans-serif",
						color: {
							argb: "FF"+poStyleObj["color"].toString().substring(1)
						}
					};
				
				
				return results;
			}
		}
		ExporterUtil = {
			/**
			 * 지정된 기본 스타일을 가진채로 엑셀을 내보내는 함수입니다.
			 * @param {cpr.controls.Grid} pcGrid 엑셀로 Export할 그리드
			 * @param {{exceptStyle : boolean, applyFormat : boolean, rowDataHandler:Function}} poOptions? 그리드의 getExportData()할때에 옵션을 지정할 수 있습니다.
			 *  입력하지 않을 경우, 모듈에 선언된 기본 옵션으로 구성합니다.
			 */
			exportExcelJS: function(pcGrid, poOptions) {
				/** @type cpr.controls.Grid */
				var vcGrid = pcGrid;
				console.log("시작");
				var voStartTime = moment().valueOf();
				var voHandleObj = {
					exceptStyle: false,
					applyFormat: true,
					rowDataHandler: function( /* {value:String,style:#css-color}[] */ datas, /* Number */ rowIndex) {
						datas.forEach(function(each) {
							
							each.style["border-top-width"] = "1px";
							each.style["border-right-width"] = "1px";
							each.style["border-bottom-width"] = "1px";
							each.style["border-left-width"] = "1px";
							each.style["border-top-style"] = "solid";
							each.style["border-right-style"] = "solid";
							each.style["border-bottom-style"] = "solid";
							each.style["border-left-style"] = "solid";
							each.style["border-top-color"] = "#000000";
							each.style["border-right-color"] = "#000000";
							each.style["border-bottom-color"] = "#000000";
							each.style["border-left-color"] = "#000000";
							each.style["color"] = "#343434";
							
							if (rowIndex == 0) { // Header
								each.style["background-color"] = "#A9A9A9";
								each.style["color"] = "#343434";
								each.style["text-align"] = "center";
							}
						});
					}
				}
				if (poOptions != undefined && Object.keys(poOptions).length != 0) {
					voHandleObj = poOptions;
				}
				
				var voExportOption = vcGrid.getExportData(voHandleObj);
				//멀티헤더의 경우에 대한 스크립트로 진화시켜야함
				/** @type Array */
				var vaHeader = voExportOption.rowgroups[0].data[0];
				
				var vaHeaderData = vaHeader.map(function(each) {
					return each.value;
				});
				var vaHeaderStyle = vaHeader.map(function(each) {
					return each.style;
				});
				
				/** @type Array */
				var vaDetailData = voExportOption.rowgroups[1].data;
				var vaDetailStyle = voExportOption.rowgroups[1].style;
				
				var wb = new ExcelJS.Workbook();
				var ws = wb.addWorksheet("sample");
				
				var headerRow = ws.addRow(vaHeaderData);
				headerRow.eachCell(function(cell, number) {
					var fils = StyleUtil._styleTransfer(vaHeaderStyle[number - 1]);
					cell.fill = fils.fill;
					cell.border = fils.border;
					cell.font = fils.font;
					if (vaHeaderStyle[number - 1]["text-align"] != undefined) {
						cell.alignment = {
							"horizontal": vaHeaderStyle[number - 1]["text-align"]
						};
					}
				})
				vaDetailData.forEach(function( /*Array*/ each, idx) {
					
					var vaDetailDataValue = each.map(function(each) {
						return each.value;
					});
					var vaDetailDataStyle = each.map(function(each) {
						return each.style;
					});
					var row = ws.addRow(vaDetailDataValue);
					row.eachCell(function(cell, number) {
						var fils = StyleUtil._styleTransfer(vaDetailDataStyle[number - 1]);
						cell.fill = fils.fill;
						cell.border = fils.border;
						cell.font = fils.font;
						
						var voCellInfo = vaDetailStyle[number - 1];
						if (voCellInfo.style["text-align"] != undefined) {
							cell.alignment = {
								"horizontal": voCellInfo.style["text-align"]
							};
						}
						
						if (voCellInfo.type == "number") {
							
							if (voCellInfo.format != undefined) {
								var vsNumFormat = voCellInfo.format;
								if (vsNumFormat.indexOf("s") != -1) {
									vsNumFormat = vsNumFormat.replace("s", "");
								}
								cell.numFmt = vsNumFormat;
							}
						}
					})
				});
				
				var vaCols = voExportOption.cols;
				var vaNumCols = vaCols.map(function(each){
					/** @type String */
					var width = each.width;
					width = Number(width.replace("px",""));
					return width;
				});
				
				var wholeWidth = vaNumCols.reduce(function add(sum, current){
					return sum + current;
				}, 0);
				
				var vnWidthAvg = wholeWidth/vaCols.length;
				
				/** @type Array */
				var vaWsCols = ws.columns;
				vaWsCols.forEach(function(each,idx){
					each.width = 14 * vaNumCols[idx]/vnWidthAvg;
				});
					
				wb.xlsx.writeBuffer().then(function(data) {
					var blob = new Blob([data], {
						type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
					});
					saveAs(blob, 'EXCEL_EXPORT_SAMPLE.xlsx');
					console.log("끝");
					var end = moment().valueOf() - voStartTime;
					console.log(moment.duration(end) / 1000);
				});
				
			},
			/**
			 * 그리드에 인라인으로 스타일을 지정해놓았을 경우 엑셀 내보내기를 할 때 사용하는 함수입니다.
			 * @param {cpr.controls.Grid} pcGrid 엑셀로 Export할 그리드
			 * @param {{exceptStyle : boolean, applyFormat : boolean, rowDataHandler:Function}} poOptions? 그리드의 getExportData()할때에 옵션을 지정할 수 있습니다.
			 *  입력하지 않을 경우, 모듈에 선언된 기본 옵션으로 구성합니다.
			 */
			exportExcelJSWithInlineStyle: function(pcGrid, poOptions) {
				/** @type cpr.controls.Grid */
				var vcGrid = pcGrid;
				console.log("시작");
				var voStartTime = moment().valueOf();
				var voHandleObj = {
					exceptStyle: false,
					applyFormat: true
				}
				if (poOptions != undefined && Object.keys(poOptions).length != 0) {
					voHandleObj = poOptions;
				}
				
				var voExportOption = vcGrid.getExportData(voHandleObj);
		
				//멀티헤더의 경우에 대한 스크립트로 진화시켜야함
				/** @type Array */
				var vaHeader = voExportOption.rowgroups[0].data[0];
				
				var vaHeaderData = vaHeader.map(function(each) {
					return each.value;
				});
				var vaHeaderStyle = voExportOption.rowgroups[0].style;
				/** @type Array */
				var vaDetailData = voExportOption.rowgroups[1].data;
				var vaDetailStyle = voExportOption.rowgroups[1].style;
				
				var wb = new ExcelJS.Workbook();
				var ws = wb.addWorksheet("sample");
				var headerRow = ws.addRow(vaHeaderData);
				headerRow.eachCell(function(cell, number) {
					var fils = StyleUtil._styleTransfer(vaHeaderStyle[number - 1].style);
					cell.fill = fils.fill;
					cell.border = fils.border;
					cell.font = fils.font;
					
					if (vaHeaderStyle[number - 1]["text-align"] != undefined) {
						cell.alignment = {
							"horizontal": vaHeaderStyle[number - 1]["text-align"]
						};
					} else {
						cell.alignment = {
							"horizontal" : "center"
						};
					}
				})
				
				vaDetailData.forEach(function( /*Array*/ each, idx) {
					
					var vaDetailDataValue = each.map(function(each) {
						return each.value;
					});
					var vaDetailDataStyle = each.map(function(each) {
						return each.style;
					});
					var row = ws.addRow(vaDetailDataValue);
					row.eachCell(function(cell, number) {
						var fils = StyleUtil._styleTransfer(vaDetailStyle[number - 1].style);
						var bgColor = 	vaDetailDataStyle[number-1]["background-color"] != undefined ? "FF"+vaDetailDataStyle[number-1]["background-color"].toString().substring(1) : "FFFFFFFF";
					cell.fill = {
						"type": "pattern",
						"pattern": "solid",
						"fgColor": {
							"argb": bgColor
						}
					}
						cell.border = fils.border;
						cell.font = fils.font;
						
						var voCellInfo = vaDetailStyle[number - 1];
						if (voCellInfo.style["text-align"] != undefined) {
							cell.alignment = {
								"horizontal": voCellInfo.style["text-align"]
							};
						}
						
						if (voCellInfo.type == "number") {
							
							if (voCellInfo.format != undefined) {
								var vsNumFormat = voCellInfo.format;
								if (vsNumFormat.indexOf("s") != -1) {
									vsNumFormat = vsNumFormat.replace("s", "");
								}
								cell.numFmt = vsNumFormat;
							}
						}
					})
				});
				
				var vaCols = voExportOption.cols;
				var vaNumCols = vaCols.map(function(each){
					/** @type String */
					var width = each.width;
					width = Number(width.replace("px",""));
					return width;
				});
				
				var wholeWidth = vaNumCols.reduce(function add(sum, current){
					return sum + current;
				}, 0);
				
				var vnWidthAvg = wholeWidth/vaCols.length;
				
				/** @type Array */
				var vaWsCols = ws.columns;
				vaWsCols.forEach(function(each,idx){
					each.width = 14 * vaNumCols[idx]/vnWidthAvg;
				});
				
				wb.xlsx.writeBuffer().then(function(data) {
					var blob = new Blob([data], {
						type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
					});
					saveAs(blob, 'EXCEL_EXPORT_SAMPLE.xlsx');
					console.log("끝");
					var end = moment().valueOf() - voStartTime;
					console.log(moment.duration(end) / 1000);
					vcGrid.getAppInstance().callAppMethod("hideMask");
				});
				
			}
		}
	});
})();
/// end - 202011/ExportUtil
/// start - 202011/util
/*
 * Module URI: 202011/util
 * SRC: 202011/util.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202011/util", function(exports, globals, module){
		
		//exports.id = "util.module.js";
		
		/**
		 * @class AppUtil AppInstance에 대한 유틸
		 */
		AppUtil = {
		    /**
		     * 해당 앱의 속성(Property)값을 할당한다.
		     * @param {cpr.core.AppInstance} app - 앱인스턴스 객체
			 * @param {String | Object} propertyName App 속성
			 * @param {String | Object} value App 속성값
			 * @param {boolean} pbEvent value-change 이벤트 발생여부  (default : true)
			 * @return void
		     */
		    setAppProperty : function (app, propertyName, value, pbEvent) {
		    	pbEvent = pbEvent == null ? true : pbEvent;
		    	
		        /** @type cpr.core.AppInstance */
		        var _app = app;
		        var hostApp = _app.getHostAppInstance();
		        var property = _app.getAppProperty(propertyName);
		        if(hostApp && hostApp.lookup(property) && hostApp.lookup(property) instanceof cpr.controls.UIControl){
		        	if(pbEvent){
		        		hostApp.lookup(property).value = value;
		        	}else{
		        		hostApp.lookup(property).putValue(value);
		        	}
		        }else{
		        	_app.setAppProperty(propertyName, value);
		        }
		    },
		    
		    /**
		     * UDC 컨트롤에 대해 value 앱 속성에 바인딩된 컨트롤 객체를 반환한다.
		     * @param {cpr.controls.UIControl} poCtrl
		     */
		    getUDCBindValueControl : function(poCtrl){
		    	var vcBindCtrl = poCtrl;
		    	var embApp = poCtrl.getEmbeddedAppInstance();
				embApp.getContainer().getChildren().some(function(embCtrl){
					if(embCtrl.type == "container"){
						embCtrl.getChildren().some(function(subembCtrl){
							if(subembCtrl.getBindInfo("value") && subembCtrl.getBindInfo("value").property == "value"){
								vcBindCtrl = subembCtrl;
								return true;
							}
						});
					}else{
						if(embCtrl.getBindInfo("value") && embCtrl.getBindInfo("value").property == "value"){
							vcBindCtrl = embCtrl;
							return true;
						}
					}
				});
				
				return vcBindCtrl;
		    }
		 };
		
		/**
		 * @class ValueUtil Value 체크 및 형 변환
		 */
		ValueUtil = {
		    /**
		     * 해당 값이 Null인지 여부를 체크하여 반환한다.
			 * @param {String | Object} puValue		값
			 * @return {Boolean} Null 여부
		     */
		    isNull : function (puValue) {
		        return (this.fixNull(puValue) == "");
		    },
		
		    /**
		     * 해당 값이 숫자(Number) 타입인지 여부를 반환한다.
			 * @param {Number | String} puValue		값
			 * @example ValueUtil.isNumber("1234.56") == true
			 * @return {Boolean} Number인지 여부
		     */
		    isNumber : function (puValue) {
		        var vnNum = Number(puValue);
		        return isNaN(vnNum) == false;
		    },
		
		    /**
		     * 해당 값에 대한 문자열을 반환한다. 
		     *       만약 해당값이 null이거나 정의되지 않은 경우, 공백("") 문자열을 반환한다.
			 * @param {String | Object} puValue		값
			 * @return {String} 문자열 String
		     */
		    fixNull : function (puValue) {
		        var vsType = typeof(puValue);
		        if (vsType == "string" || (vsType == "object" && puValue instanceof String)) {
					puValue = this.trim(puValue);
		        }
				
		        return (puValue == null || puValue == "null" || puValue == "undefined") ? "" : String(puValue);
		    },
		
		     /**
		     * 해당 값을 불리언(Boolean) 타입으로 변환한다.
			 * @param {Boolean | Object} puValue		값
			 * @return {Boolean} 불리언 유형으로 반환
		     */
		    fixBoolean : function (puValue) {
		        if (typeof(puValue) == "boolean" || puValue instanceof Boolean) {
		            return puValue;
		        }
		        if (typeof(puValue) == "number" || puValue instanceof Number) {
		            return puValue != 0;
		        }
		        return (this.fixNull(puValue).toUpperCase() == "TRUE");
		    },
		
		    /**
		     * 해당 값을 숫자(Number) 타입으로 변환한다.
			 * @param {Object} puValue		값
			 * @return {Number} 숫자 타입으로 반환
		     */
		    fixNumber : function (puValue) {
		        if (typeof(puValue) == "number" || puValue instanceof Number) {
		            return puValue;
		        }
		        var vnNum = Number(this.fixNull(puValue));
		        return isNaN(vnNum) ? 0 : vnNum;
		    },
		    
		    /**
		     * 해당 값을 숫자(Float) 타입으로 변환한다.
			 * @param {Object} puValue		값
			 * @return {Float} 소수점이 있는 숫자 타입으로 반환
		     */
		    fixFloat : function (puValue) {
		        if (typeof(puValue) == "number" || puValue instanceof Number) {
		            return puValue;
		        }
		        var vnFloat = parseFloat(this.fixNull(puValue));
		        return isNaN(vnFloat) ? 0 : vnFloat;
		    },
		    
		    /**
		     * 해당 값의 앞/뒤 공백을 제거한 문자열을 반환한다.
			 * @param {String} psValue		값
			 * @return {String} 공백 제거된 문자열
		     */
		    trim : function (psValue) {
		        return psValue == null ? psValue : psValue.replace(/(^\s*)|(\s*$)/g, "");
		    },
		    
		    /**
		     * 문자열을 split한 배열을 반환한다.
			 * @param {String} psValue		split 대상 문자열
			 * @param {String} psDelemeter  구분문자 (ex: 콤마(,))
			 * @return {Array} 문자열 배열
		     */
		    split : function (psValue, psDelemeter) {
		    	psValue = this.fixNull(psValue);
		        var vaValues = new Array();
		        var vaTemp = psValue.split(psDelemeter);
		        var _this = this;
		        vaTemp.forEach(function(/* eachType */ item){
		        	vaValues.push(_this.trim(item));
		        });
		        
		        return vaValues;
		    },
		    
		    /**
		     * 문자열 데이터의 길이(length)를 반환한다.
			 * @param {String} value		값
			 * @param {String} unit (Optional) 단위<br/>
		     * [char] : 문자의 길이.<br/>
		 	 * [utf8] : utf8 기준의 문자 byte size.<br/>
		 	 * [ascii] : ascii 기준의 문자 byte size.
			 * @return {Number} 문자열 길이
		     */
		    getLength : function(value, unit) {
		    	if(!unit) unit = "char";
		    	
				var length = 0;
				switch(unit) {
					case "utf8":{
		//				for(var i = 0, c; c = value.charAt(i++); length += (c >> 11 ? 3 : c >> 7 ? 2 : 1));
						for(var i=0, len=value.length; i<len; i++) {
						    if(escape(value.charAt(i)).length >= 4)
						        length += 3;
						    else if(escape(value.charAt(i)) == "%A7")
						        length += 3;
						    else if(escape(value.charAt(i)) != "%0D")
						        length++;
						    else length++;
						}
						break;
					}
					case "ascii":{
						for(var i = 0, c; c = value.charAt(i++); length += c >> 7 ? 2 : 1);
						break;
					}
					default : {
						length = value.length;
					}
				}
				
				return length;
		    },
		    getByteLength: function(/*String*/_str){
		    	var stringByteLength = 0;
		    	stringByteLength = (function(s,b,i,c){
				    for(b=i=0;c=s.charCodeAt(i++);b+=c>>11?2:c>>7?2:1);
				    return b
				})(_str);
		
				return stringByteLength;
		    }
		 };
		
		/**
		 * @class 날짜 유틸 클래스
		 */
		DateUtil = {
		
		    /**
		     * 날짜를 지정한 패턴의 문자열로 반환한다.
			 * @param {Date} poDate			날짜
			 * @param {String} psPattern	포맷 문자열(ex: YYYYMMDD)
			 * @return {String} 날짜 문자열
		     */
		    format : function (poDate, psPattern) { // dateValue As Date, strPattern As String
		        var CAL_INITIAL = {
				    MONTH_IN_YEAR :         ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
				    SHORT_MONTH_IN_YEAR :   ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
				    DAY_IN_WEEK :           ["Sunday", "Monday", "Tuesday", "Wednesday","Thursday", "Friday", "Saturday"],
				    SHORT_DAY_IN_WEEK :     ["Sun", "Mon", "Tue", "Wed","Thu", "Fri", "Sat"]
				};
		        
		        var year      = poDate.getFullYear();
			    var month     = poDate.getMonth() + 1;
			    var day       = poDate.getDate();
			    var dayInWeek = poDate.getDay();
			    var hour24    = poDate.getHours();
			    var ampm      = (hour24 < 12) ? "AM" : "PM";
			    var hour12    = (hour24 > 12) ? (hour24 - 12) : hour24;
			    var min       = poDate.getMinutes();
			    var sec       = poDate.getSeconds();
			
			    var YYYY = "" + year;
			    var YY   = YYYY.substr(2);
			    var MM   = (("" + month).length == 1) ? "0" + month : "" + month;
			    var MON  = CAL_INITIAL.MONTH_IN_YEAR[month-1];
			    var mon  = CAL_INITIAL.SHORT_MONTH_IN_YEAR[month-1];
			    var DD   = (("" + day).length == 1) ? "0" + day : "" + day;
			    var DAY  = CAL_INITIAL.DAY_IN_WEEK[dayInWeek];
			    var day  = CAL_INITIAL.SHORT_DAY_IN_WEEK[dayInWeek];
			    var HH   = (("" + hour24).length == 1) ? "0" + hour24 : "" + hour24;
			    var hh   = (("" + hour12).length == 1) ? "0" + hour12 : "" + hour12;
			    var mm   = (("" + min).length == 1) ? "0" + min : "" + min;
			    var ss   = (("" + sec).length == 1) ? "0" + sec : "" + sec;
			    var SS   = "" + poDate.getMilliseconds();
				
			    var dateStr;
			    var index = -1;
			    if (typeof(psPattern) == "undefined") {
			        dateStr = "YYYYMMDD";
			    } else {
			        dateStr = psPattern;
			    }
			
			    dateStr = dateStr.replace(/YYYY/g, YYYY);
			    dateStr = dateStr.replace(/yyyy/g, YYYY);
			    dateStr = dateStr.replace(/YY/g,   YY);
			    dateStr = dateStr.replace(/MM/g,   MM);
			    dateStr = dateStr.replace(/MON/g,  MON);
			    dateStr = dateStr.replace(/mon/g,  mon);
			    dateStr = dateStr.replace(/DD/g,   DD);
			    dateStr = dateStr.replace(/dd/g,   DD);
			    dateStr = dateStr.replace(/day/g,  day);
			    dateStr = dateStr.replace(/DAY/g,  DAY);
			    dateStr = dateStr.replace(/hh/g,   hh);
			    dateStr = dateStr.replace(/HH/g,   HH);
			    dateStr = dateStr.replace(/mm/g,   mm);
			    dateStr = dateStr.replace(/ss/g,   ss);
			    dateStr = dateStr.replace(/(\s+)a/g, "$1" + ampm);
			
			    return dateStr;
		    },
		
		    /**
		     * 올바른 날짜인지를 체크한다.
			 * @param {Number | String} puYear			년도
			 * @param {Number | String} puMonth			월
			 * @param {Number | String} puDay			일
			 * @return {Boolean} 유효한 날짜인지 여부
		    */
		    isValid : function (puYear, puMonth, puDay) {
		    	var pnYear = Number(puYear);
		    	var pnMonth = Number(puMonth);
		    	var pnDay = Number(puDay);
		        var vdDate = new Date(pnYear, pnMonth-1, pnDay);
		        return vdDate.getFullYear() == pnYear      &&
		               vdDate.getMonth   () == pnMonth - 1 &&
		               vdDate.getDate    () == pnDay;
		    },
		
		    /**
		     * 현재 날짜에 해당 날짜만큼 더한 날짜를 반환한다.
			 * @param {String} psDate			날짜 문자열(ex: 20180101)
			 * @param {Number} pnDayTerm		추가 일수
			 * @return {String} 날짜 문자열
		    */
		    addDate : function (psDate, pnDayTerm) { 
		    	var pnYear 	= Number(psDate.substring(0,4));
		    	var pnMonth = Number(psDate.substring(4,6));
		    	var pnDay 	= Number(psDate.substring(6,8));
		
		    	if (this.isValid(pnYear, pnMonth, pnDay)) {
			    	var vdDate = new Date(pnYear, pnMonth-1, pnDay);
			    	var vnOneDay = 1*24*60*60*1000 ; /* 1day,24hour,60minute,60seconds,1000ms */
			    	
			    	var psTime = vdDate.getTime() + (Number(pnDayTerm)*Number(vnOneDay));
			    	vdDate.setTime(psTime);
			    	
			        return this.format(vdDate,"YYYYMMDD");
		    	}else{
		    		return psDate;
		    	}
		    },
		    
		    /**
		     * 날짜 문자열을 Date형으로 변환하여 반환한다.
		     * <pre><code>
		     * DateUtil.toDate("2007-02-09","YYYY-MM-DD");
		 	 * </code></pre>
			 * @param {Date} psDateTime			날짜
			 * @param {String} psPattern	포맷 문자열(ex: YYYY-MM-DD)
			 * @example DateUtil.toDate("2007-02-09","YYYY-MM-DD")
			 * @return {Date} 날짜(Date) 객체
		     */ 
		    toDate : function (psDateTime, psPattern) {
		        var vdDate = new Date();
		        var vnIdx, vnCnt;
		
		        var vsaFmt = ["Y", "M", "D", "H", "m", "s", "S"];
		        var vnFmtLen = vsaFmt.length;
		        var vnPtnLen = psPattern.length;
		        var vnaNums = [vdDate.getFullYear(), vdDate.getMonth()+1, vdDate.getDate(), vdDate.getHours(), vdDate.getMinutes(), vdDate.getSeconds(), vdDate.getMilliseconds()];
		
		        for (var i = 0; i < vnFmtLen; i++) {
		            vnIdx = psPattern.indexOf(vsaFmt[i]);
		            if (vnIdx != -1) {
		                vnCnt = 1;
		                for (var j=vnIdx+1; j < vnPtnLen; j++) {
		                    if (psPattern.charAt(j) != vsaFmt[i]) { break; }
		                    vnCnt++;
		                }
		                vnaNums[i] = Number(psDateTime.substring(vnIdx, vnIdx+vnCnt));
		            } else {
		                if(i==0) vnaNums[0] = 1900;
		                else if(i==2) vnaNums[2] = 01;
		            }
		        }
		
		        if (vnaNums[0] < 1900) { // 년도는 검증
		            if (vnaNums[0] <= vdDate.getFullYear() % 100) {
		                vnaNums[0] += vdDate.getFullYear() - (vdDate.getFullYear() % 100);
		            } else if (vnaNums[0] < 100) {
		                vnaNums[0] += 1900;
		            } else {
		                vnaNums[0] = 1900;
		            }
		        }
		
		        return new Date(vnaNums[0], vnaNums[1]-1, vnaNums[2], vnaNums[3], vnaNums[4], vnaNums[5], vnaNums[6]);
		    },
		
		    /**
		     * 해당월의 마지막 일자를 반환한다.
		     * <pre><code>
		     * DateUti.getMonthLastDay("20180201");
		     * 또는
		     * DateUti.getMonthLastDay("20180301", -1);
		 	 * </code></pre>
			 * @param {String} psDate	년월 문자열(ex: 201802, 20180201)
			 * @param {Number} pnAdd (Optional)   +/- 월 수
			 * @return {Number} 일(Day)
		     */ 
		    getMonthLastDay : function (psDate, pnAdd) {
		    	var pnYear 	= Number(psDate.substring(0,4));
		    	var pnMonth = Number(psDate.substring(4,6));
		        var vdDate = new Date(pnYear, pnMonth, 0, 1, 0, 0);
		        if(pnAdd == null){
		        	return vdDate.getDate();
		        }else{
		        	var vdDate2 = new Date(vdDate.getFullYear(), vdDate.getMonth()+1+pnAdd, 0, 1, 0, 0);
		        	return vdDate2.getDate();
		        }
		    },
		
		    /**
		     * 두 날짜간의 일(Day)수를 반환한다.
			 * @param {String} psDate1st	년월 문자열(ex: 20180201)
			 * @param {String} psDate2nd    년월 문자열(ex: 20170201)
			 * @return {Number} 일수(Day)
		     */
		    getDiffDay : function (psDate1st, psDate2nd) {
		    	var date1 = this.toDate(psDate1st, "YYYYMMDD");
		    	var date2 = this.toDate(psDate2nd, "YYYYMMDD");
		        
		        return parseInt((date2 - date1)/(1000*60*60*24));
		    },
		    
		    /**
		     * @param {String} psHHmm 특정분을 더할 시분 값
			 * @param {String} pnAddMinutes 더할 분
			 * @return {String} 시분(HHmm)
			 * 
			 * ex) DateUtil.addMinutes("0900", 50)
		     */
		    addMinutes : function (psHHmm, pnAddMinutes) {
		    	var vdDate = DateUtil.toDate(psHHmm, "HHmm");
				vdDate.setMinutes(vdDate.getMinutes() + pnAddMinutes);
				
				var vnHours = vdDate.getHours();
				var vnMinutes = vdDate.getMinutes();
				
				var vsHours = "";
				var vsMinutes = "";
				
				if(vnHours < 10){
					vsHours = "0" + vnHours;
				}else{
					vsHours = vnHours + "";
				}
				
				if(vnMinutes < 10){
					vsMinutes = "0" + vnMinutes;
				}else{
					vsMinutes = vnMinutes + "";
				}
				
				return vsHours + vsMinutes;
		    },
		    
		    getCurrentTime : function() {
		    	return new Date().getTime();
		    },
		    
		    /**
		     * 입력한 일자에 해당되는 한글 요일을 반환한다.
		     * <pre><code>
		     * DateUti.getDayOfWeek("20191120");
		 	 * </code></pre>
			 * @param {String} psDate 일자 문자열(ex:20191120)
			 * @return {String} 한글 요일
		     */ 
		    getDayOfWeek : function (psDate) {
		    	
		    	var vsYear 	= psDate.substring(0,4);
		    	var vsMonth = psDate.substring(4,6);
		    	var vsDay 	= psDate.substring(6,8);
		    	var vaWeek  = ['일', '월', '화', '수', '목', '금', '토'];
		    	
				return vaWeek[new Date(vsYear + "-" + vsMonth + "-" + vsDay).getDay()];
		    }
		};
		
		/**
		 * @class 파일 유틸 클래스
		 */
		FileUtil = {
			//업로드 가능한 파일 확장자 목록반환
			getPemitedFileExts : function(){
				var vaFileExt = [
								'JPG' , 'PNG' , 'GIF', 'BMP'
								, 'TIF', 'TIFF', 'JFIF'
								, 'TXT', 'CSV', 'HWP', 'DOCX', 'GNG'
								, 'DOC', 'DOCM', 'PPT', 'PPTX'
								, 'PPTM', 'PPS', 'PPSX', 'XLS'
								, 'XLSX', 'XLSM', 'XLAM', 'XLA'
								, 'PSD', 'PDF', 'ODS', 'OGG', 'ZIP', 'EGG'
								, 'MP4', 'AVI', 'WMV'
								, 'RAR', 'TAR', '7Z', 'TBZ', 'TGZ'
								, 'LZH', 'GZ', 'AI'
							]; 
				return vaFileExt;
			},
			
			//업로드 불가한 파일 확장자 목록반환
			getLimitedFileExts : function(){
				// 파일 선택 제한 확장자.
				var vaFileExt = new Array(
					 'A6P'     //Authorware 6 Program
					,'AC'      //Autoconfig Script
					,'AS'      //Adobe Flash ActionScript File
					,'ACR'     //ACRobot Script
					,'ACTION'  //Automator Action
					,'AIR'     //Adobe AIR Installation Package
					,'APP'     //FoxPro Generated Application
					,'APP'     //Symbian OS Application
					,'ASP'	   //Active Server Page
					,'ASPX'	   //Extended Active Server Page
					,'AWK'     //AWK Script
					,'BAT'     //Batch File
					,'CGI'     //Common Gateway Interface Script
					,'CMD'     //Windows Command
					,'COM'     //DOS Command File
					,'CSH'     //C Shell Script
					,'DEK'     //Eavesdropper Batch File
					,'DLD'     //EdLog Compiled Program
					,'DS'      //TWAIN Data Source
					,'EBM'     //EXTRA! Basic Macro
					,'ESH'     //Extended Shell Batch File
					,'EXE'     //Windows Executable File
					,'EZS'     //EZ-R Stats Batch Script
					,'FKY'     //FoxPro Macro
					,'FRS'     //Flash Renamer Script
					,'FXP'     //FoxPro Compiled Source
					,'GADGET'  //Windows Gadget
					,'HMS'     //HostMonitor Script File
					,'HTA'     //HTML Application
					,'ICD'     //SafeDisc Encrypted Program
					,'INX'     //Compiled Script
					,'IPF'     //SMS Installer Script
					,'ISU'     //InstallShield Uninstaller Script
					,'JAR'     //Java Archive File
					,'JS'      //JScript Executable Script
					,'JSE'     //JScript Encoded File
					,'JSP'	   //JavaServer Pages
					,'JSX'     //ExtendScript Script File
					,'KIX'     //KiXtart Script File
					,'LUA'     //Lua Scripting File
					,'MCR'     //3ds Max Macroscript File
					,'MEM'     //Macro Editor Macro
					,'MPX'     //FoxPro Compiled Menu Program
					,'MS'      //3ds Max Script File
					,'MST'     //Windows SDK Setup Transform Script
					,'OBS'     //ObjectScript Script File
					,'PAF'     //Portable Application Installer File
					,'PEX'     //ProBoard Executable File
					,'PHP'	   //Hypertext Preprocessor
					,'PIF'     //Program Information File
					,'PL'	   //Perl Script
					,'PRC'     //Palm Resource Code File
					,'PRG'     //Generica Program File
					,'PVD'     //Instalit Script
					,'PWC'     //PictureTaker File
					,'PY'      //Python Script
					,'PYC'     //Python Compiled File
					,'PYO'     //Python Optimized Code
					,'QPX'     //FoxPro Compiled Query Program
					,'RBX'     //Rembo-C Compiled Script
					,'RGS'     //Registry Script
					,'ROX'     //Actuate Report Object Executable File
					,'RPJ'     //Real Pac Batch Job File
					,'SCAR'    //SCAR Script
					,'SCR'     //Script File
					,'SCRIPT'  //Generic Script File
					,'SCT'     //Windows Script Component
					,'SH'	   //Shell Script
					,'SHB'     //Windows Shortcut into a Document
					,'SHS'     //Shell Scrap Object File
					,'SPR'     //FoxPro Generated Screen File
					,'TLB'     //OLE Type Library
					,'TMS'     //Telemate Script
					,'U3P'     //U3 Smart Application
					,'UDF'     //Excel User Defined Function
					,'VB'      //VBScript File
					,'VBE'     //VBScript Encoded Script File
					,'VBS'     //VBScript File
					,'VBSCRIPT'//Visual Basic Script
					,'WCM'     //WordPerfect Macro
					,'WPK'     //WordPerfect Macro
					,'WS'      //Windows Script
					,'WSF'     //Windows Script File
					,'XQT'     //SuperCalc Macro File
				);
				
				return vaFileExt;
			},
			
			/**
			 * 해당 파일이 업로드 가능한 파일 유형인지 체크한다.
			 * @param {Object} poUtil - 유틸 클래스 객체 
			 * @param {String} psFileNm - 파일명
			 * @param {String} psLimitFileExt - 업로드 가능제한 파일 확장자
			 */
			checkFileType : function(poUtil, psFileNm, psLimitFileExt){
				var vaCheckFileExt = null;
				if (!ValueUtil.isNull(psLimitFileExt)) {
					psLimitFileExt = psLimitFileExt.replace(/\./ig, "");
					vaCheckFileExt = ValueUtil.split(psLimitFileExt, ",");
				}
				
				if(vaCheckFileExt == null || vaCheckFileExt.length < 1){
					vaCheckFileExt = FileUtil.getPemitedFileExts();
				}
				
				var isValid = false;
				var arrStr = psFileNm.split(".");
				var extStr = arrStr [arrStr.length - 1].toUpperCase();
				for(var j=0, jlen=vaCheckFileExt.length; j<jlen; j++){
					if (extStr == vaCheckFileExt[j].toUpperCase()) {
						isValid = true;
						break;
					}
				}
				if(!isValid){
					//{0} 유형의 파일은 업로드 불가합니다.
					poUtil.Msg.alert("WRN-M024", [extStr]);
					return isValid;
				}
				
				var vaLimitedFileExt = FileUtil.getLimitedFileExts();
				for(var i=0, len=vaLimitedFileExt.length; i<len; i++) {
					if (extStr == vaLimitedFileExt[i]) {
						//{0} 유형의 파일은 업로드 불가합니다.
						poUtil.Msg.alert("WRN-M024", [extStr]);
						isValid = false;
						break;
					}
				}
				
				return isValid;
			}
		};
		
		//StyleUtil = {
		//	/**
		//	 * 
		//	 * @param {Object} poStyleObj
		//	 */
		//	_styleTransfer: function(poStyleObj) {
		//		
		//		var results = {
		//			"border": {},
		//			"fill": {},
		//			"font":{},
		//			"alignment":{}
		//		};
		//		
		//		var vaKeys = Object.keys(poStyleObj);
		//		
		//		var border = ["border-top-width",
		//			"border-top-color",
		//			"border-right-width",
		//			"border-right-color",
		//			"border-bottom-width",
		//			"border-bottom-color",
		//			"border-left-width",
		//			"border-left-color"
		//		];
		//		var fill = ["color",
		//			"background-color"
		//		]
		//		
		//		for (var i = 0; i <= border.length - 2; i += 2) {
		//			
		//			if (poStyleObj[border[i]] != undefined) {
		//				var direction = border[i].split("-")[1];
		//				var colors = poStyleObj[border[i + 1]].toString().substring(1);
		//				results.border[direction] = {
		//					"style": 'thin',
		//					color: {
		//						argb: "FF" + colors
		//					}
		//				}
		//			}
		//		}
		//		
		//		var bgColor = 	poStyleObj["background-color"] != undefined ? "FF"+poStyleObj["background-color"].toString().substring(1) : "FFFFFFFF";
		//			results.fill = {
		//				"type": "pattern",
		//				"pattern": "solid",
		//				"fgColor": {
		//					"argb": bgColor
		//				}
		//			}
		//			results.font = {
		//				name : "sans-serif",
		//				color: {
		//					argb: "FF"+poStyleObj["color"].toString().substring(1)
		//				}
		//			};
		//		
		//		
		//		return results;
		//	}
		//}
		//ExporterUtil = {
		//	/**
		//	 * 간다간다우간다!
		//	 * @param {cpr.controls.Grid} pcGrid
		//	 * @param {Object} poOptions?
		//	 */
		//	exportExcelJS: function(pcGrid, poOptions) {
		//		/** @type cpr.controls.Grid */
		//		var vcGrid = pcGrid;
		//		console.log("시작");
		//		var voStartTime = moment().valueOf();
		//		var voHandleObj = {
		//			exceptStyle: false,
		//			applyFormat: true,
		//			rowDataHandler: function( /* {value:String,style:#css-color}[] */ datas, /* Number */ rowIndex) {
		//				datas.forEach(function(each) {
		//					
		//					each.style["border-top-width"] = "1px";
		//					each.style["border-right-width"] = "1px";
		//					each.style["border-bottom-width"] = "1px";
		//					each.style["border-left-width"] = "1px";
		//					each.style["border-top-style"] = "solid";
		//					each.style["border-right-style"] = "solid";
		//					each.style["border-bottom-style"] = "solid";
		//					each.style["border-left-style"] = "solid";
		//					each.style["border-top-color"] = "#000000";
		//					each.style["border-right-color"] = "#000000";
		//					each.style["border-bottom-color"] = "#000000";
		//					each.style["border-left-color"] = "#000000";
		//					each.style["color"] = "#343434";
		//					
		//					if (rowIndex == 0) { // Header
		//						each.style["background-color"] = "#A9A9A9";
		//						each.style["color"] = "#343434";
		//						each.style["text-align"] = "center";
		//					}
		//				});
		//			}
		//		}
		//		if (poOptions != undefined && Object.keys(poOptions).length != 0) {
		//			voHandleObj = poOptions;
		//		}
		//		
		//		var voExportOption = vcGrid.getExportData(voHandleObj);
		//		//멀티헤더의 경우에 대한 스크립트로 진화시켜야함
		//		/** @type Array */
		//		var vaHeader = voExportOption.rowgroups[0].data[0];
		//		
		//		var vaHeaderData = vaHeader.map(function(each) {
		//			return each.value;
		//		});
		//		var vaHeaderStyle = vaHeader.map(function(each) {
		//			return each.style;
		//		});
		//		
		//		/** @type Array */
		//		var vaDetailData = voExportOption.rowgroups[1].data;
		//		var vaDetailStyle = voExportOption.rowgroups[1].style;
		//		
		//		var wb = new ExcelJS.Workbook();
		//		var ws = wb.addWorksheet("sample");
		//		
		//		var headerRow = ws.addRow(vaHeaderData);
		//		headerRow.eachCell(function(cell, number) {
		//			var fils = StyleUtil._styleTransfer(vaHeaderStyle[number - 1]);
		//			cell.fill = fils.fill;
		//			cell.border = fils.border;
		//			cell.font = fils.font;
		//			if (vaHeaderStyle[number - 1]["text-align"] != undefined) {
		//				cell.alignment = {
		//					"horizontal": vaHeaderStyle[number - 1]["text-align"]
		//				};
		//			}
		//		})
		//		vaDetailData.forEach(function( /*Array*/ each, idx) {
		//			
		//			var vaDetailDataValue = each.map(function(each) {
		//				return each.value;
		//			});
		//			var vaDetailDataStyle = each.map(function(each) {
		//				return each.style;
		//			});
		//			var row = ws.addRow(vaDetailDataValue);
		//			row.eachCell(function(cell, number) {
		//				var fils = StyleUtil._styleTransfer(vaDetailDataStyle[number - 1]);
		//				cell.fill = fils.fill;
		//				cell.border = fils.border;
		//				cell.font = fils.font;
		//				
		//				var voCellInfo = vaDetailStyle[number - 1];
		//				if (voCellInfo.style["text-align"] != undefined) {
		//					cell.alignment = {
		//						"horizontal": voCellInfo.style["text-align"]
		//					};
		//				}
		//				
		//				if (voCellInfo.type == "number") {
		//					
		//					if (voCellInfo.format != undefined) {
		//						var vsNumFormat = voCellInfo.format;
		//						if (vsNumFormat.indexOf("s") != -1) {
		//							vsNumFormat = vsNumFormat.replace("s", "");
		//						}
		//						cell.numFmt = vsNumFormat;
		//					}
		//				}
		//			})
		//		});
		//		
		//		var vaCols = voExportOption.cols;
		//		var vaNumCols = vaCols.map(function(each){
		//			/** @type String */
		//			var width = each.width;
		//			width = Number(width.replace("px",""));
		//			return width;
		//		});
		//		
		//		var wholeWidth = vaNumCols.reduce(function add(sum, current){
		//			return sum + current;
		//		}, 0);
		//		
		//		var vnWidthAvg = wholeWidth/vaCols.length;
		//		
		//		/** @type Array */
		//		var vaWsCols = ws.columns;
		//		vaWsCols.forEach(function(each,idx){
		//			each.width = 14 * vaNumCols[idx]/vnWidthAvg;
		//		});
		//			
		//		wb.xlsx.writeBuffer().then(function(data) {
		//			var blob = new Blob([data], {
		//				type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
		//			});
		//			saveAs(blob, 'EXCEL_EXPORT_SAMPLE.xlsx');
		//			console.log("끝");
		//			var end = moment().valueOf() - voStartTime;
		//			console.log(moment.duration(end) / 1000);
		//		});
		//		
		//	},
		//	/**
		//	 * 간다간다우간다!
		//	 * @param {cpr.controls.Grid} pcGrid
		//	 * @param {Object} poOptions?
		//	 */
		//	exportExcelJS2: function(pcGrid, poOptions) {
		//		/** @type cpr.controls.Grid */
		//		var vcGrid = pcGrid;
		//		console.log("시작");
		//		var voStartTime = moment().valueOf();
		//		var voHandleObj = {
		//			exceptStyle: false,
		//			applyFormat: true
		//		}
		//		if (poOptions != undefined && Object.keys(poOptions).length != 0) {
		//			voHandleObj = poOptions;
		//		}
		//		
		//		var voExportOption = vcGrid.getExportData(voHandleObj);
		//
		//		//멀티헤더의 경우에 대한 스크립트로 진화시켜야함
		//		/** @type Array */
		//		var vaHeader = voExportOption.rowgroups[0].data[0];
		//		
		//		var vaHeaderData = vaHeader.map(function(each) {
		//			return each.value;
		//		});
		//		var vaHeaderStyle = voExportOption.rowgroups[0].style;
		//		/** @type Array */
		//		var vaDetailData = voExportOption.rowgroups[1].data;
		//		var vaDetailStyle = voExportOption.rowgroups[1].style;
		//		
		//		var wb = new ExcelJS.Workbook();
		//		var ws = wb.addWorksheet("sample");
		//		var headerRow = ws.addRow(vaHeaderData);
		//		headerRow.eachCell(function(cell, number) {
		//			var fils = StyleUtil._styleTransfer(vaHeaderStyle[number - 1].style);
		//			cell.fill = fils.fill;
		//			cell.border = fils.border;
		//			cell.font = fils.font;
		//			
		//			if (vaHeaderStyle[number - 1]["text-align"] != undefined) {
		//				cell.alignment = {
		//					"horizontal": vaHeaderStyle[number - 1]["text-align"]
		//				};
		//			} else {
		//				cell.alignment = {
		//					"horizontal" : "center"
		//				};
		//			}
		//		})
		//		
		//		vaDetailData.forEach(function( /*Array*/ each, idx) {
		//			
		//			var vaDetailDataValue = each.map(function(each) {
		//				return each.value;
		//			});
		//			var vaDetailDataStyle = each.map(function(each) {
		//				return each.style;
		//			});
		//			var row = ws.addRow(vaDetailDataValue);
		//			row.eachCell(function(cell, number) {
		//				var fils = StyleUtil._styleTransfer(vaDetailStyle[number - 1].style);
		//				var bgColor = 	vaDetailDataStyle[number-1]["background-color"] != undefined ? "FF"+vaDetailDataStyle[number-1]["background-color"].toString().substring(1) : "FFFFFFFF";
		//			cell.fill = {
		//				"type": "pattern",
		//				"pattern": "solid",
		//				"fgColor": {
		//					"argb": bgColor
		//				}
		//			}
		//				cell.border = fils.border;
		//				cell.font = fils.font;
		//				
		//				var voCellInfo = vaDetailStyle[number - 1];
		//				if (voCellInfo.style["text-align"] != undefined) {
		//					cell.alignment = {
		//						"horizontal": voCellInfo.style["text-align"]
		//					};
		//				}
		//				
		//				if (voCellInfo.type == "number") {
		//					
		//					if (voCellInfo.format != undefined) {
		//						var vsNumFormat = voCellInfo.format;
		//						if (vsNumFormat.indexOf("s") != -1) {
		//							vsNumFormat = vsNumFormat.replace("s", "");
		//						}
		//						cell.numFmt = vsNumFormat;
		//					}
		//				}
		//			})
		//		});
		//		
		//		var vaCols = voExportOption.cols;
		//		var vaNumCols = vaCols.map(function(each){
		//			/** @type String */
		//			var width = each.width;
		//			width = Number(width.replace("px",""));
		//			return width;
		//		});
		//		
		//		var wholeWidth = vaNumCols.reduce(function add(sum, current){
		//			return sum + current;
		//		}, 0);
		//		
		//		var vnWidthAvg = wholeWidth/vaCols.length;
		//		
		//		/** @type Array */
		//		var vaWsCols = ws.columns;
		//		vaWsCols.forEach(function(each,idx){
		//			each.width = 14 * vaNumCols[idx]/vnWidthAvg;
		//		});
		//		
		//		wb.xlsx.writeBuffer().then(function(data) {
		//			var blob = new Blob([data], {
		//				type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
		//			});
		//			saveAs(blob, 'EXCEL_EXPORT_SAMPLE.xlsx');
		//			console.log("끝");
		//			var end = moment().valueOf() - voStartTime;
		//			console.log(moment.duration(end) / 1000);
		//			vcGrid.getAppInstance().callAppMethod("hideMask");
		//		});
		//		
		//	}
		//}
		
		ExcelUtil = {
				_s2ab: function(s) {
					
					var buf = new ArrayBuffer(s.length); //convert s to arrayBuffer
					var view = new Uint8Array(buf); //create uint8array as viewer
					for (var i = 0; i < s.length; i++) view[i] = s.charCodeAt(i) & 0xFF; //convert to octet
					return buf;
				},
				_exportExcel: function(fileName, sheetName, excelData,type) {
					
					var wb = XLSX.utils.book_new();
					
					var newWorksheet ;
					if(type == "table") {
						
						// step 2. 시트 만들기 
						newWorksheet = XLSX.utils.table_to_sheet(excelData);
					} else if(type == "json") {
						
						newWorksheet = XLSX.utils.json_to_sheet(excelData,{range:2});
					}
					
					// step 3. workbook에 새로만든 워크시트에 이름을 주고 붙인다.  
					XLSX.utils.book_append_sheet(wb, newWorksheet, sheetName);
					
					// step 4. 엑셀 파일 만들기 
					var wbout = XLSX.write(wb, {
						bookType: 'xlsx',
						type: 'binary'
					});
					
					// step 5. 엑셀 파일 내보내기 
					saveAs(new Blob([this._s2ab(wbout)], {
						type: "application/octet-stream"
					}), fileName);
				},
				
				exportExcelToTable: function(fileName, sheetName, gridCtrl) {
					var table = document.createElement("table");
					table.id = "tableData";
					
					var vcGrid = gridCtrl;
					var exportData = vcGrid.getExportData({
						exceptStyle: true,
						applyFormat: true
					})
					
					var header = exportData.rowgroups[0];
					var detail = exportData.rowgroups[1];
					/** @type Array */
					var headerData = header.data[0];
					/** @type Array */
					var detailData = detail.data;
					
					var result = [];
					
					var tr = document.createElement("tr");
					headerData.forEach(function(each) {
						var td = document.createElement("td");
						td.innerHTML = each;
						tr.appendChild(td);
						table.appendChild(tr);
					});
					
					detailData.forEach(function(each) {
						var trs = document.createElement("tr");
						each.forEach(function(eachs) {
							var tds = document.createElement("td");
							tds.innerHTML = eachs;
							trs.appendChild(tds);
							table.appendChild(trs);
						});
					});
					return table;
				},
				
				exportExcelToJSON : function(fileName, sheetName, gridCtrl) {
					/** @type cpr.controls.Grid */
					var vcGrid = gridCtrl;
					var exportData = vcGrid.getExportData({
						exceptStyle : true,
						applyFormat : true
					});
					
					var vnHeaderCnt = vcGrid.columnCount;
					var headerData = [];
					for(var i = 0 ; i < vnHeaderCnt ; i++) {
						
						headerData.push(vcGrid.header.getColumn(i).targetColumnName);
					}
					
					
					
					var headerText = exportData.rowgroups[0];
					var detail = exportData.rowgroups[1];
					/** @type Array */
					var headerTextData = headerText.data[0];
					/** @type Array */
					var detailData = detail.data;
					
					var result = [];
					
					
					
		//			headerTextData.forEach(function(each){
						var b =  {};
						headerData.forEach(function(headerEach,idx){
							b[headerEach] = headerTextData[idx];
							
						});
						result.push(b);
		//			});
					
					detailData.forEach(function(each) {
						var a = {};
						headerData.forEach(function(headerEach, idx) {
							a[headerEach] = each[idx];
						});
						result.push(a);
						
					});
					console.log(result);
					
					this._exportExcel(fileName, sheetName, result, "json");
				}
		}
	});
})();
/// end - 202011/util
/// start - 202012/GridSplitHelper
/*
 * Module URI: 202012/GridSplitHelper
 * SRC: 202012/GridSplitHelper.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202012/GridSplitHelper", function(exports, globals, module){
		///************************************************
		// * GridSplitHelper.module.js
		// * Created at 2020. 10. 7. 오전 11:14:26.
		// *
		// * @author HANS
		// ************************************************/
		//
		//
		//cpr.events.EventBus.INSTANCE.addFilter("init", function(e){
		//	var control = e.control;
		//	
		//	if(control instanceof cpr.core.AppInstance) {
		//		
		//		var _app = control;
		//		
		//		var vaAllChild = _app.getContainer().getAllRecursiveChildren();
		//		
		//		vaAllChild.forEach(function(each){
		//			
		//			if(each instanceof cpr.controls.Grid) {
		//				if(each.leftSplit != 0) {
		//					each.userAttr("leftSplit", each.leftSplit.toString());
		//				}
		//				if(each.leftSplitWidth != undefined) {
		//					each.userAttr("leftSplitWidth",each.leftSplitWidth.toString());
		//				}
		//				if(each.rightSplit != 0) {
		//					each.userAttr("rightSplit",each.rightSplit.toString());
		//				}
		//				if(each.rightSplitWidth != undefined) {
		//					each.userAttr("rightSplitWidth", each.rightSplitWidth.toString());
		//				}
		//			}
		//		});
		//	}
		//});
		//
		//cpr.events.EventBus.INSTANCE.addFilter("screen-change", function(/* cpr.events.CScreenChangeEvent */ e){
		//	
		//	var control = e.control;
		//	
		//	if(control instanceof cpr.core.AppInstance) {
		//			
		//		if(e.screen.name != "default") {
		//			control.getContainer().getAllRecursiveChildren().forEach(function(each){
		//				
		//				if(each instanceof cpr.controls.Grid) {
		//					
		//					each.getUserAttrNames().forEach(function(eachProp){
		//						if(each[eachProp] != undefined) {
		//							each[eachProp] = parseInt(each.userAttr(eachProp));
		//						}
		//					});
		//					
		//					each.redraw();
		//				}
		//			});
		//		} else {
		//			control.getContainer().getAllRecursiveChildren().forEach(function(each){
		//				if(each instanceof cpr.controls.Grid) {
		//					each.leftSplit = 0;
		//					each.leftSplitWidth = 0;
		//					each.rightSplit = 0;
		//					each.rightSplitWidth = 0;
		//					
		//					each.redraw();
		//				}
		//				
		//			});
		//			
		//			
		//		}
		//	}
		//});	
	});
})();
/// end - 202012/GridSplitHelper
/// start - 202012/propChanger
/*
 * Module URI: 202012/propChanger
 * SRC: 202012/propChanger.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202012/propChanger", function(exports, globals, module){
		/************************************************
		 * propChanger.module.js
		 * Created at 2020. 9. 7. 오후 3:52:32.
		 *
		 * @author han
		 ************************************************/
		//	cpr.core.AppConfig.INSTANCE.setControlValue("combobox",{preventInput:true});
		//cpr.core.AppConfig.INSTANCE.setControlValue("dateinput", {mask : "YYYY/MM-DD",format : "YYYY-MM-DD"});
		
		//cpr.core.AppConfig.INSTANCE.setControlValue("numbereditor", {format : "s#,##0.00"});
		
		//cpr.core.AppConfig.INSTANCE.setValue("controls", {
		//	"dateinput": {
		//		mask: "YYYY/MM-DD",
		//		format : "yyyy-mm-dd"
		//	},
		//	"numbereditor" :{
		//		format : "s#,##0"
		//	}
		//});
	});
})();
/// end - 202012/propChanger
/// start - 202101/DynamicGrid
/*
 * Module URI: 202101/DynamicGrid
 * SRC: 202101/DynamicGrid.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202101/DynamicGrid", function(exports, globals, module){
		///************************************************
		// * DynamicGrid.module.js
		// * Created at 2021. 1. 12. 오후 2:15:23.
		// *
		// * @author ryu54
		// ************************************************/
		//
		//
		//var gridConfig = {
		//	"column" : {
		//		"width" : "100px"
		//	},
		//	"header" : {
		//		"height" : "35px"
		//	},
		//	"detail" : {
		//		"height" : "32px"
		//	}
		//}
		//
		//
		///**
		// * 
		// * @param {cpr.controls.Grid} grid
		// * @param {
		// *   header : cpr.data.DataSet <!-- 그리드 헤더를 구성하는 데이터 셋 ID -->,
		// *   detail : cpr.data.DataSet <!-- 그리드에 연결될 데이터 셋 ID -->
		// * } config
		// */
		//function DynamicGrid(grid, config) {
		//	if (grid instanceof cpr.controls.Grid == false){
		//		throw new cpr.exceptions.IllegalStateException("타겟이 그리드 컨트롤이 아닙니다. 다시 확인하여 주십시오.");
		//	}
		//	
		//	this._grid = grid;
		//	this._appInstance = grid.getAppInstance();
		//	this._headerDataset = config.header;
		//	this._detailDataset = config.detail;
		//	
		//	/*
		//	 * this._columnSettings = [];
		//	 * this._headerSettings = {};
		//	 * this._detailSettings = {};
		//	 */
		//	
		//	this.init();
		//}
		//
		///**
		// * 
		// * @type {{width:String}[]}
		// */
		//DynamicGrid.prototype._columnSettings = [];
		//
		///**
		//* 
		//* @type 
		//* {
		//*   rows: {height:String}[],
		//*   cells: {
		//*     constraint: {rowIndex:Number,rowSpan:Number,colIndex:Number,colSpan:Number},
		//*     configurator: Function
		//*   }[]
		//* }
		//*/
		//DynamicGrid.prototype._headerSettings = {};
		//
		///**
		//* 
		//* @type 
		//* {
		//*   rows: {height:String}[],
		//*   cells: {
		//*     constraint: {rowIndex:Number,rowSpan:Number,colIndex:Number,colSpan:Number},
		//*     configurator: Function
		//*   }[]
		//* }
		//*/
		//DynamicGrid.prototype._detailSettings = {};
		//
		//DynamicGrid.prototype._handleColumn = function() {
		//	var dataset = this._headerDataset;
		//	
		//	var originalLayout = gridConfig.column.width;
		//	
		//	var colCount = dataset.getRowCount();
		//	for(var idx = 0; idx < colCount; idx++){
		//		this._columnSettings.push({"width" : originalLayout});
		//	}
		//}
		//
		//DynamicGrid.prototype._handleHeader = function() {
		//	var dataset = this._headerDataset;
		//	
		//	var originalLayout = gridConfig.header.height;
		//	
		//	/* Rows */
		//	this._headerSettings.rows = [];
		//	var headerCount = dataset.getColumnCount();
		//	for(var idx = 0; idx < headerCount; idx++){
		//		this._headerSettings.rows.push({"height" : originalLayout});
		//	}
		//	
		//	/* Cells */
		//	this._headerSettings.cells = [];
		//	var colCount = dataset.getRowCount();
		//	var vaHeaderRow  = [];
		//	for(var rowIdx = 0; rowIdx < headerCount; rowIdx++){
		//		var colNm = dataset.getColumnNames()[rowIdx];
		//		for(var colIdx = 0; colIdx < colCount; colIdx++){
		//			var headerText = dataset.getValue(colIdx, colNm);
		//			vaHeaderRow.push(headerText);
		//		}
		//	}
		//	for(var rowIdx = 0; rowIdx < headerCount; rowIdx++){
		//		var colNm = dataset.getColumnNames()[rowIdx];
		//		for(var colIdx = 0; colIdx < colCount; colIdx++){
		//			var headerText = dataset.getValue(colIdx, colNm);
		//			var config = {
		//				constraint : {
		//					"rowIndex" : rowIdx,
		//					"rowSpan" : 1,
		//					"colIndex" : colIdx,
		//					"colSpan" : 1
		//				},
		//				configurator: function(cell) {
		//					//TODO 마지막 변수에 대한 텍스트가 들어가는 문제 있음
		//					cell.text = vaHeaderRow.shift();
		//				}
		//			}
		//			this._headerSettings.cells.push(config);
		//		}
		//	}
		//}
		//
		//DynamicGrid.prototype._handleDetail = function() {
		//	var dataset = this._detailDataset;
		//	
		//	var originalLayout = gridConfig.detail.height;
		//	
		//	this._detailSettings.rows = [];
		//	this._detailSettings.rows.push({"height" : originalLayout});
		//	
		//	this._detailSettings.cells = [];
		//	var headerCount = this._headerDataset.getRowCount();
		//	for(var idx = 0; idx < headerCount; idx++){
		//		var colNm = dataset.getColumnNames()[idx];
		//		
		//		var config = {
		//				constraint : {
		//					"rowIndex" : 0,
		//					"rowSpan" : 1,
		//					"colIndex" : idx,
		//					"colSpan" : 1
		//				},
		//				configurator: function(cell) {
		//					cell.columnName = "empId";
		//					//TODO 마지막 변수에 대한 텍스트가 들어가는 문제 있음
		//					/*
		//					 * cell.columnName = (function() {
		//					 * 	return colNm;
		//					 * })();
		//					 */
		//				}
		//			}
		//		
		//		this._detailSettings.cells.push(config);
		//	}
		//}
		//
		//DynamicGrid.prototype.init = function() {
		//	var grid = this._grid;
		//	
		//	this._handleColumn();
		//	this._handleHeader();
		//	this._handleDetail();
		//	
		//	console.log(this._columnSettings);
		//	console.log(this._headerSettings);
		//	console.log(this._detailSettings);
		//	
		//	grid.init({
		//		dataset : this._detailDataset,
		//		resizableColumn: "all",
		//		columns : this._columnSettings,
		//		header : this._headerSettings,
		//		detail : this._detailSettings
		//	});
		//}
		//
		///**
		// * 
		// * @param {cpr.controls.Grid} grid
		// * @param {
		// *   header : cpr.data.DataSet <!-- 그리드 헤더를 구성하는 데이터 셋 ID -->,
		// *   detail : cpr.data.DataSet <!-- 그리드에 연결될 데이터 셋 ID -->
		// * } config
		// */
		//globals.createGrid = function(grid, config) {
		//	return new DynamicGrid(grid, config);
		//}
	});
})();
/// end - 202101/DynamicGrid
/// start - 202102/sj/I4331
/*
 * Module URI: 202102/sj/I4331
 * SRC: 202102/sj/I4331.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202102/sj/I4331", function(exports, globals, module){
		/************************************************
		 * I4331.module.js
		 * Created at 2020. 3. 13. 오전 11:24:03.
		 *
		 * @author jeeeyul
		 ************************************************/
		
		//cpr.core.App.addHook({
		//	// App.load 트리거.
		//	onLoad: function(appId, loader) {
		//		console.log(appId);
		//		// I4311-emb 앱이 로드 될 때 I4331-dep.js가 함께 로드 되도록 함.
		//		if (appId == "202008/tester") {
		//			loader.addScript("data/FXFIG2.json");
		//		}
		//	},
		//	
		//	// 앱 델리게이트 onPrepare 트리거.
		//	onPrepare: function(app, loader) {
		//		if (app.app.id == "_MILESTONE_ISSUES_/2020/R-13/I4331-content/I4331-emb") {
		//			
		//		}
		//	},
		//	
		//	// 앱 델리게이트 onCreate 트리거.
		//	onCreate: function(app, exports) {
		//		// 4311이 앱 아이디에 포함된 경우, 앱 컨테이너의 보더 색상을 변경 함.
		//		if (app.app.id.indexOf("pop") !== -1) {
		//			console.log("ㅋㅋ 걸렸죠?");
		//			
		//			app.
		//		}
		//	}
		//});
	});
})();
/// end - 202102/sj/I4331
/// start - 202104/cardObjectSwipeinEmbeded
/*
 * Module URI: 202104/cardObjectSwipeinEmbeded
 * SRC: 202104/cardObjectSwipeinEmbeded.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202104/cardObjectSwipeinEmbeded", function(exports, globals, module){
		/************************************************
		 * cardObjectSwipe.module.js
		 * Created at 2021. 4. 21. 오전 9:15:00.
		 *
		 * @author HANS
		 ************************************************/
		
		// 의존 모듈 선언.
		module.depends("module/swiper_mobile");
		var mob = cpr.core.Module.require("module/swiper_mobile");
		
		var arrs = [];
		var target ;
		var ghostCont;
		/**
		 * 문제점 :
		 * 모듈밖에서 슬라이더를 핸들링 하는 방법이 조잡함.
		 * grpFamily를 지워버려서 추가 버튼을 누를때 조잡하게 찾아서 사용해야함.
		 * 이 기능을 객체화 할 수 있는지 아니면 그룹 컨트롤을 삭제하지 않고 레이아웃만 변경할 수 있을지
		 */
		
		/**
		 * @param {cpr.core.AppInstance} poAppInstance
		 * @param {cardSwiper[]} paSwiper
		 */
		function cardGrp(poAppInstance,paSwiper){
			this.grps=  paSwiper;
			this.appIns = poAppInstance;
			this.swiper = null;
		}
		
		cardGrp.prototype._onScreenChange = function(/*cpr.events.CScreenChangeEvent*/e) {
			
			var vaGrps = this.grps;
			var vsScreenNm = e.screen.name;
			
			
			if(vsScreenNm == "default") {
				
				if(ghostCont.visible){
					
					target.visible = true;
					var vaGrps = this.grps;
					
					vaGrps.forEach(function(each){
						
						each.parent.insertChild(each.index, each.container,each.constraint);
					});
					if(this.swiper)
					this.swiper.clear();
					ghostCont.removeAllChildren();
					ghostCont.visible = false;
				}
			} else {
				console.log("나에요~~");
				ghostCont.visible = true;
		//		vaGrps.forEach(function(each){
		//			
		//		});
				var vaSwipeDepth=  vaGrps.map(function(each){
					return each.swipeIdx
				});
				vaSwipeDepth = _.uniq(vaSwipeDepth, true);
				console.log(vaSwipeDepth);
				
				vaSwipeDepth.forEach(function(each){
					
					var bro = vaGrps.filter(function(eachGrp){
						if(eachGrp.swipeIdx == each){
							return eachGrp;
						}
					});
					
					if(bro.length > 1) {
						var verticalCont = new cpr.controls.Container();
						var verticalLay = new cpr.controls.layouts.VerticalLayout();
						verticalLay.spacing = 20;
						verticalLay.scrollable = false;
						verticalCont.setLayout(verticalLay);
						
						bro.forEach(function(eachB){
							verticalCont.addChild(eachB.container, eachB.constraint);
						});
						ghostCont.addChild(verticalCont, {
							width:"100%",
							height:"100%",
							autoSize:"height"
						});
					} else {
						var child = bro[0];
						ghostCont.addChild(child.container, {
							width : "100%",
							height: "300%",
							autoSize:"height"
						});
					}
				});
				
				var slidi = mob.slidify(ghostCont)
				slidi.showCount = 1;
				slidi.itemSize = 0;
				slidi.navigationButtonClassName = "slide-btn-none";
				slidi.start(); //slidify추가
				this.swiper = slidi;
				target.visible = false;
				
			}
		}
		cardGrp.prototype.start = function(){
			this.appIns.addEventListener("screen-change",this._onScreenChange.bind(this));
		}
		/**
		 * 
		 * @param {cpr.controls.Container} pcContainer
		 */
		function cardSwiper(pcContainer){
			this.swiper = null;
			this.container = pcContainer;
			this.parent = pcContainer.getParent();
			this.constraint = pcContainer.getParent().getConstraint(pcContainer);
			this.index = pcContainer.getParent().getChildren().indexOf(pcContainer);
			this.appIns = pcContainer.getAppInstance();
			this.swipeIdx = pcContainer.userAttr("swipe-depth")
		
			
			this._onchange = this._onScreenChange.bind(this);
		//	this.container.swipe = this.swiper;
		}
		
		cardSwiper.prototype.change = function(/*cpr.events.CScreenChangeEvent*/e){
			
			var vcContainer = this.container;
			
			var vsScreenName = e.screen.name;
			
			if(vsScreenName == "default") {
				
			}
			else {
				
		//		vaContainer.forEach(function(each){
		//			
		//			each.getAllRecursiveChildren().filter(function(each){
		//				
		//				if(each.userAttr("swipe-depth") != "");
		//				return each;
		//			});
		//		});
			}
		}
		
		cardSwiper.prototype._onScreenChange = function(e) {
			
			console.log("타시면 안되는데요");
		}
		cardSwiper.prototype.start = function(){
			this.appIns.addEventListener("screen-change", this._onchange);
		}
		
		//cpr.events.EventBus.INSTANCE.addFilter("init", function(e){
		//	var control = e.control;
		//	
		//	if(control instanceof cpr.core.AppInstance && control.id.indexOf("udc") != 0) {
		//		console.log(control);
		//		var vaAllChild = control.getContainer().getAllRecursiveChildren();
		//			
		//			var vaEa = vaAllChild.filter(function(each){
		//				if(each instanceof cpr.controls.EmbeddedApp)
		//				return each;
		//			});
		//			vaEa.forEach(function(each){
		//				each.addEventListenerOnce("app", function(e){
		//					
		//					console.log(e.control);
		//				});
		//			});
		//		var targetCtrl = vaAllChild.filter(function(each){
		//			
		//			if(each.userAttr("swipe-depth") != "") {
		////				return each;
		//			var cs = new cardSwiper(each);
		////			cs.start();
		//			arrs.push(cs);
		//			}
		//			
		//		});
		////		console.log(targetCtrl);
		////		var cs = new cardSwiper(targetCtrl);
		////		arrs.push(cs);
		//		console.log(arrs);
		////		var carSw = new cardGrp(arrs);
		////		carSw.start();
		//	
		////		 target = vaAllChild.find(function(ele){
		////			if(ele.userAttr("ghost-target") == "true"){
		////				return ele;
		////			}
		////		});
		////		
		////		 ghostCont = new cpr.controls.Container();
		////		 var voGhostFlow = new cpr.controls.layouts.FlowLayout();
		////		 voGhostFlow.scrollable = false;
		////		 voGhostFlow.lineWrap = false;
		////		 voGhostFlow.spacing = 0;
		////		 voGhostFlow.bottomMargin = 50;
		////		 
		////		 ghostCont.setLayout(voGhostFlow);
		////		 
		////		 target.getParent().insertChild(0, ghostCont,{
		////		 	width : "100px",
		////		 	height: "300px",
		////		 	autoSize:"height"
		////		 });
		////		 ghostCont.visible = false;
		//		 
		//	}
		//});
		
		/**
		 * 
		 * @param {cpr.core.AppInstance} poAppInstance
		 */
		globals.initer = function(poAppInstance){
			var aps = poAppInstance;
			
			var vaAllChild = aps.getContainer().getAllRecursiveChildren();
			var allReady = [];
			/** @type cpr.controls.EmbeddedApp[] */
			var vaEa = vaAllChild.filter(function(each){
						if(each instanceof cpr.controls.EmbeddedApp && each.app == undefined){
							return each;
						}
					});
					
					vaEa.forEach(function(each){
						var readyPromise = each.ready(function(eApp){
							var a = eApp.getEmbeddedAppInstance().getContainer().getAllRecursiveChildren();
							a.forEach(function(eachA){
								if(eachA.userAttr("swipe-depth")!=""){
									var cs = new cardSwiper(eachA);
									arrs.push(cs);
								}
							});
						});
						 allReady.push(readyPromise);
					});
					
		//			var carSwq = new cardGrp();
		//				carSwq.start();
					Promise.all(allReady).then(function(input) {
						console.log(arrs);
						var carSw = new cardGrp(aps,arrs);
						carSw.start();
						target = vaAllChild.find(function(ele) {
							if (ele.userAttr("ghost-target") == "true") {
								return ele;
							}
						});
						
						ghostCont = new cpr.controls.Container();
						var voGhostFlow = new cpr.controls.layouts.FlowLayout();
						voGhostFlow.scrollable = false;
						voGhostFlow.lineWrap = false;
						voGhostFlow.spacing = 0;
						voGhostFlow.bottomMargin = 50;
						
						ghostCont.setLayout(voGhostFlow);
						
						target.getParent().insertChild(0, ghostCont, {
							width: "100px",
							height: "300px",
							autoSize: "height"
						});
						ghostCont.visible = false;
					});
					
		}
		
		globals.createCardSwiper = function(pcContainer){
			
			return new cardSwiper(pcContainer);
		}
	});
})();
/// end - 202104/cardObjectSwipeinEmbeded
/// start - 202104/changer
/*
 * Module URI: 202104/changer
 * SRC: 202104/changer.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202104/changer", function(exports, globals, module){
		///************************************************
		// * changer.module.js
		// * Created at 2021. 4. 12. 오후 1:17:51.
		// *
		// * @author HANS
		// ************************************************/
		//// 의존 모듈 선언.
		//module.depends("module/swiper_mobile");
		//var mob = cpr.core.Module.require("module/swiper_mobile");
		//var originConstraint;
		//var originParent;
		//
		//cpr.events.EventBus.INSTANCE.addFilter("screen-change", function(e) {
		//	var control = e.control;
		//	if (control instanceof cpr.core.AppInstance) {
		//		
		//		if (control.id.indexOf("udc") != 0) {
		//			
		//			/** @type cpr.controls.Container[]*/
		//			var vaSwipedContainer = control.getContainer().getAllRecursiveChildren().filter(function(ele) {
		//				if (ele.userAttr("mobile-swiped") == "true") {
		//					
		//					return ele;
		//				}
		//			});
		//			
		//			if(vaSwipedContainer.length < 1) {
		//				return;
		//			}
		//			var btns = vaSwipedContainer[0].getParent().getAllRecursiveChildren().find(function(ele){
		//				if(ele.id =="btnFamilyInsert"){
		//					return ele;
		//				}
		//			});
		//			
		//			if(btns) {
		//				originConstraint = btns.getParent().getConstraint(btns);
		//				originParent = btns.getParent();
		//			}
		//			if (e.screen.name != "default") {
		//				cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function() {
		//					
		//					if (vaSwipedContainer[0].getLayout() instanceof cpr.controls.layouts.VerticalLayout) {
		//						vaSwipedContainer.forEach(function(each) {
		//							
		//							var vcSwipedContainer = each;
		//							var voConst = vcSwipedContainer.getParent().getConstraint(vcSwipedContainer);
		//							var vcSwipeCtrl = new cpr.controls.Container();
		//							vcSwipeCtrl.style.setClasses("card-group vertical");
		//							vcSwipeCtrl.userAttr("mobile-swiped", "true");
		//							var voFlowLayout = new cpr.controls.layouts.FlowLayout();
		//							voFlowLayout.scrollable = false;
		//							voFlowLayout.lineWrap = false;
		//							voFlowLayout.spacing = 0;
		//							vcSwipeCtrl.setLayout(voFlowLayout);
		//							vcSwipedContainer.getParent().addChild(vcSwipeCtrl, voConst);
		//							var vnOriginChildLength = vcSwipedContainer.getChildren().length;
		//							var visier;
		//							vcSwipedContainer.getChildren().forEach(function(each, idx) {
		//								var han = each.getParent().getConstraint(each);
		//								if (vnOriginChildLength - 1 <= idx) {
		//									each.addChild(btns,{
		//										"width": "100px",
		//										"height": "35px",
		//										"autoSize": "none"
		//									})
		////									vcSwipeCtrl.addChild(each, han);
		//								} else {
		////									each.visible = false;
		////									visier = each;
		//								}
		//									vcSwipeCtrl.addChild(each, han);
		//								
		//							});
		//							
		////							var btnq = new cpr.controls.Button();
		////							btnq.value = "가족 구성원 추가";
		////							btnq.style.setClasses("btn-secondary btn-innr");
		////							vcSwipeCtrl.getChildren()[vnOriginChildLength - 2].addChild(btnq, {
		////								"width": "100px",
		////								"height": "35px",
		////								"autoSize": "none"
		////							});
		//							btns.addEventListener("click", function(e){
		//								console.log("ㅋㅋ~~");
		//							});
		//
		//							vcSwipedContainer.dispose();
		//							cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function() {
		//								
		//								var slid = mob.slidify(vcSwipeCtrl);
		//								slid.showCount = 1;
		//								slid.itemSize = 0;
		//								slid.navigationButtonClassName = "slide-btn-none"
		//								slid.start();
		//								
		////								btnq.addEventListener("click", function(e) {
		////									/** @type cpr.controls.UIControl */
		////									var ctrl = vcSwipeCtrl.getChildren()[0].getChildren()[0];
		////									var hh = visier.getParent().getConstraint(visier)
		////									vcSwipeCtrl.getChildren()[0].addChild(visier, hh);
		////									visier.visible = true;
		////									slid.clear();
		////									
		////									slid.initialPage = 3;
		////									slid.start();
		////								});
		//							});
		//						});
		//					}
		//				});
		//				
		//			} else {
		//				if (vaSwipedContainer[0].getLayout() instanceof cpr.controls.layouts.FlowLayout) {
		//					vaSwipedContainer.forEach(function(each) {
		//						var vcSwipedContainer = each;
		//						
		//						var voConstraint = vcSwipedContainer.getParent().getConstraint(vcSwipedContainer);
		//						/** @type cpr.controls.Container */
		//						var childParent = vcSwipedContainer.getChildren()[0];
		//						
		//						var vcVerticalContainer = new cpr.controls.Container();
		//						var voVerticalLayout = new cpr.controls.layouts.VerticalLayout();
		//						voVerticalLayout.spacing = 0;
		//						voVerticalLayout.scrollable = false;
		//						vcVerticalContainer.setLayout(voVerticalLayout);
		//						vcVerticalContainer.style.setClasses("card-group vertical");
		//						vcVerticalContainer.userAttr("mobile-swiped", "true");
		//						
		//						childParent.getChildren().forEach(function(each) {
		//							
		//							each.visible = true;
		//							vcVerticalContainer.addChild(each, {
		//								width: "1214px",
		//								height: "300px",
		//								autoSize: "height"
		//							});
		//						});
		//						
		//						vcSwipedContainer.getParent().addChild(vcVerticalContainer, voConstraint);
		//						vcSwipedContainer.dispose();
		//					});
		//				}
		//			}
		//		}
		//	}
		//});
	});
})();
/// end - 202104/changer
/// start - 202104/hooker
/*
 * Module URI: 202104/hooker
 * SRC: 202104/hooker.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202104/hooker", function(exports, globals, module){
		/************************************************
		 * hooker.module.js
		 * Created at 2021. 4. 16. 오후 2:21:50.
		 *
		 * @author HANS
		 ************************************************/
		
	});
})();
/// end - 202104/hooker
/// start - 202104/modelHan
/*
 * Module URI: 202104/modelHan
 * SRC: 202104/modelHan.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202104/modelHan", function(exports, globals, module){
		
		
	});
})();
/// end - 202104/modelHan
/// start - 202105/swiper_mobile_temp
/*
 * Module URI: 202105/swiper_mobile_temp
 * SRC: 202105/swiper_mobile_temp.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202105/swiper_mobile_temp", function(exports, globals, module){
		///************************************************
		// * swiper.module.js
		// * Created at 2021. 3. 8. 오전 11:13:06.
		// *
		// * @author HANS
		// ************************************************/
		//
		///**
		// * 
		// * @param {Event} e
		// */
		//function eventStopper(e) {
		//	e.stopPropagation();
		//	e.preventDefault();
		//}
		//
		///**
		// * 
		// * @param {cpr.controls.Container} container
		// */
		//function SlideView(container) {
		//	this._container = container;
		//	var layout = container.getLayout();
		//	
		//	if (layout instanceof cpr.controls.layouts.FlowLayout == false){
		//		throw new cpr.exceptions.IllegalArgumentException("플로우 레이아웃에서만 사용가능 합니다.");
		//	}
		//	
		//	/** @type cpr.controls.layouts.FlowLayout */
		//	this._layout = container.getLayout();
		//};
		///**
		// * 2021.03.30추가, showCount를 바꿀 경우가 있을 떄, 원본 레이아웃의 spacing을 저장하기 위해 사용.
		// */
		//SlideView.prototype.originSpacing =0;
		///**
		// * 한 페이지에서 표시할 콘텐츠 수
		// */
		//SlideView.prototype.showCount = 2;
		//
		///**
		// * 페이지 내 한 컨텐츠의 너비. 0인 경우 비율로 균등 분배합니다.
		// */
		//SlideView.prototype.itemSize = 0;
		//
		///**
		// * 자동 재생시 애니메이션의 길이. 단위 초.
		// */
		//SlideView.prototype.autoPlayDuration = 0.3;
		//
		///**
		// * 자동 재생시, 각 재생간의 간격. 단위 초. 0 이상의 값을 주면 start()시 자동 재생이 시작됩니다. 0을 주는 경우, 자동으로 재생을 시작하지 않습니다.
		// */
		//SlideView.prototype.autoPlayDelay = 0;
		//
		///**
		// * 터치 또는 마우스로 드래그중 놓았을 때, 스내핑 애니메이션의 길이. 단위 초.
		// */
		//SlideView.prototype.snapDuration = 0.3;
		//
		///**
		// * 페이지니션을 표시할 것인지 여부.
		// */
		//SlideView.prototype.showPagination = true;
		//
		///**
		// * 페이지니션을 사용자가 원하는 위치에 표시할 것인지 여부.
		// */
		//SlideView.prototype.adjustPagination = false;
		//
		///**
		// * 좌우 버튼의 너비
		// */
		//SlideView.prototype.navigationButtonWidth = 48;
		//
		//
		///**
		// * 좌우 버튼의 높이
		// */
		//SlideView.prototype.navigationButtonHeight = 48;
		//
		///** 
		// * 좌우버튼에 추가적으로 줄 클래스 명.
		// * @type String 
		// */
		//SlideView.prototype.navigationButtonClassName = null;
		//
		///**
		// * 무한 스크롤 사용 여부.
		// */
		//SlideView.prototype.useInfiniteScroll = false;
		//
		//SlideView.prototype.infiniteTarget = null;
		//
		///**
		// * 네비게이션 버튼 표시 스타일
		// * <li>hover: 컨테이너 가장자리에 호버 시킴</li>
		// * <li>outside: 컨테이나 가장자리 바깥쪽에 표시</li>
		// * <li>content-hover: 가운데 정렬된 콘텐츠의 가장자리에 호버 시킴</li>
		// * <li>content-outside: 가운데 정렬된 콘텐츠의 가장자리에 바깥쪽에 표시</li></li>
		// * <li>cover: 콘텐츠의 가장자리에 걸쳐 표시</li></li>
		// * <li>none: 버튼 표시 안함</li>
		// */
		//SlideView.prototype.navigationButtonStyle = "cover";
		//
		///**
		// * 시작 페이지 번호 0부터 시작.
		// */
		//SlideView.prototype.initialPage = 0;
		//
		///**
		// * <li>left: 시작 컨트롤이 왼쪽 끝에서 시작</li>
		// * <li>center: 시작 컨트롤이 가운데에서 시작</li>
		// * <li>right: 시작 컨트롤이 오른쪽 끝에서 시작</li>
		// */
		//SlideView.prototype.startAlign = "left";
		//
		///**
		// * @type SlidePagination
		// */
		//SlideView.prototype._pagination = null;
		///**
		// * @type cpr.controls.UIControl[]
		// */
		//SlideView.prototype._originalChildren = [];
		//SlideView.prototype._knownScreenX = -1;
		//SlideView.prototype._initialScrollLeft = -1;
		///** @type cpr.controls.Container */
		//SlideView.prototype._innerContainer = null;
		///** @type cpr.controls.layouts.FlowLayout */
		//SlideView.prototype._innerLayout = null;
		//
		///** @type cpr.geometry.Rectangle */
		//SlideView.prototype._knownBounds = null;
		//
		///** @type cpr.controls.Button */
		//SlideView.prototype._prevButton = null;
		//
		///** @type cpr.controls.Button */
		//SlideView.prototype._nextButton = null;
		//
		///** @type cpr.animation.Animator */
		//SlideView.prototype._activeAnimator = null;
		//SlideView.prototype._autoPlayTimerID = -1;
		//
		//SlideView.prototype.hasScroll = false;
		//
		//SlideView.prototype.scrollMode = null;
		//SlideView.prototype.touchVector = null;
		//SlideView.prototype._transform = function() {
		//		if (this._container.getActualRect().width === 0) {
		//		cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(this._transform.bind(this));
		//		return;
		//	}
		//	var height = this._container.getViewPortRect().height;
		//	this._container.style.addClass("cl-unselectable");
		//	this._layout.horizontalAlign = "center";
		//	this._layout.scrollable = false;
		//	this._originalChildren = this._container.getChildren();
		//
		//	this._innerContainer = new cpr.controls.Container();
		//	this._innerContainer.style.addClass("slide-inner");
		//	var layout = new cpr.controls.layouts.FlowLayout();
		//	layout.lineWrap = false;
		//	layout.scrollable = false;
		//	if(this._layout.spacing != 0)
		//	this.originSpacing = this._layout.spacing;
		//	layout.spacing = this.originSpacing;
		//	this._innerContainer.setLayout(layout);
		//	this._innerLayout = layout;
		//	this._layout.spacing = 0;
		//	this._layout.scrollable = false;
		//
		//	var itemConstraint = {
		//		height: "100%"
		//	};
		//
		//	var itemSizeExpression = this.itemSize + "px";
		//
		//	if (this.itemSize <= 0) {
		//		itemSizeExpression = "(100% - " + (this.showCount) * layout.spacing + "px) / " + this.showCount;
		//		itemConstraint.width = "calc(" + itemSizeExpression + ")";
		//	} else {
		//		itemConstraint.width = this.itemSize + "px";
		//	}
		//	
		//	if (this.useInfiniteScroll === false) {
		//		switch (this.startAlign) {
		//			case "center":
		//				{
		//					var padder = new cpr.controls.Output();
		//					padder.style.addClass("placeholder");
		//					this._innerContainer.addChild(padder, {
		//						width: cpr.utils.Util.template("calc((100% - ${spacing} - ${eachWidth}) / 2 - ${spacing})", {
		//							eachWidth: "(" + itemSizeExpression + ")",
		//							spacing: layout.spacing + "px"
		//						}),
		//						height: "100%"
		//					});
		//					break;
		//				}
		//
		//			case "right":
		//				{
		//					var padder = new cpr.controls.Output();
		//					padder.style.addClass("placeholder");
		//					this._innerContainer.addChild(padder, {
		//						width: cpr.utils.Util.template("calc(100% - 2 * ${spacing} - ${eachWidth})", {
		//							eachWidth: "(" + itemSizeExpression + ")",
		//							spacing: layout.spacing + "px"
		//						}),
		//						height: "100%"
		//					});
		//					break;
		//				}
		//		}
		//	}
		//
		//	this._container.getChildren().forEach((function( /* cpr.controls.UIControl */ each, idx) {
		//		each.userAttr("-snap-point", "true");
		//		itemConstraint.height = "300px",
		//		itemConstraint.autoSize="height";
		//		this._innerContainer.addChild(each, itemConstraint);
		//	}).bind(this));
		//	this._container.addChild(this._innerContainer, {
		//		width: this.itemSize > 0 ? this.showCount * this.itemSize + (this.showCount - 1) * layout.spacing + 2 + "px" : "100%", //XXX 보정치 추가
		//		height: "100%"
		//	});
		//
		//	this._pagination = new SlidePagination(this);
		//	this._pagination.control.userAttr("swiped", "true");
		//	this._container.getParent().floatControl(this._pagination.control);
		////	this._updateActivePageButton = _.debounce(this._updateActivePageButton.bind(this),50);
		//	this._innerContainer.addEventListener("scroll", this._updateActivePageButton.bind(this));
		//	this.updateContentHeight();
		//		this._innerContainer.scrollTo(1, 0,0.3,cpr.animation.TimingFunction.EASE_IN);
		//}
		//
		///**
		// * 슬라이드뷰를 시작합니다.
		// * 시작하기전 모든 설정이 마쳐져야 합니다.
		// */
		//SlideView.prototype.start = function() {
		//	if (this._container.getActualRect().width === 0) {
		//		cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(this.start.bind(this));
		//		return;
		//	}
		//	
		//	this._transform();
		//
		//	this._onMouseDown = this._onMouseDown.bind(this);
		//	this._onMouseUp = this._onMouseUp.bind(this);
		//	this._onMouseMove = this._onMouseMove.bind(this);
		//
		//	this._onTouchEnd = this._onTouchEnd.bind(this);
		//	this._onTouchStart = this._onTouchStart.bind(this);
		//	this._onTouchMove = this._onTouchMove.bind(this);
		//	
		//	this._doUpdateButtons = _.debounce(this._doUpdateButtons.bind(this), 500);
		////	this._updateActivePageButton = _.debounce(this._updateActivePageButton.bind(this), 50);
		//
		//	this._onResize = this._onResize.bind(this);
		//
		////	this._innerContainer.addEventListener("scroll", this._updateActivePageButton);
		//	this._container.addEventListener("mousedown", this._onMouseDown);
		//	this._container.addEventListener("touchstart", this._onTouchStart);
		//	this._container.addEventListenerOnce("dispose", this._handleDispose.bind(this));
		//	cpr.core.NotificationCenter.INSTANCE.subscribe("main-size-changed", this, this._updateButtons);
		//	cpr.core.NotificationCenter.INSTANCE.subscribe("swipe-transition-occured", this, this._onResize);
		//	cpr.core.NotificationCenter.INSTANCE.subscribe(cpr.core.SystemTopics.RESIZE, this, this._onResize);
		//	cpr.core.NotificationCenter.INSTANCE.subscribe("swipe-size-changed",this, this.updateContentHeight);
		////	this._updateActivePageButton();
		//
		//	if (this.autoPlayDelay > 0) {
		//		this.autoPlay();
		//	}
		//
		//	if (this.initialPage > 0) {
		//		cpr.core.DeferredUpdateManager.INSTANCE.asyncExec((function() {
		//			if (this._container.disposed) {
		//				return;
		//			}
		//			this.setActivePage(this.initialPage);
		//		}).bind(this));
		//	}
		//
		//	cpr.core.DeferredUpdateManager.INSTANCE.asyncExec((function() {
		//		if (this._container.disposed) {
		//			return;
		//		}
		//		this._doUpdateButtonsImmediatly();
		//	}).bind(this));
		//	
		//};
		//
		///**
		// * 자동 재생을 시작합니다. autoPlayDelay가 지정된 경우, 슬라이드 시작시 자동으로 재생이 시작됩니다.
		// */
		//SlideView.prototype.autoPlay = function() {
		//	if (this._autoPlayTimerID >= 0) {
		//		return;
		//	}
		//	this._autoPlayTimerID = setInterval(this.showNext.bind(this), (this.autoPlayDelay + this.autoPlayDuration) * 1000);
		//};
		//
		///**
		// * 자동 재생중인 경우, 자동 재생을 중단합니다.
		// */
		//SlideView.prototype.stopAutoPlay = function() {
		//	if (this._autoPlayTimerID >= 0) {
		//		clearInterval(this._autoPlayTimerID);
		//		this._autoPlayTimerID = -1;
		//	}
		//};
		//
		//SlideView.prototype._handleDispose = function() {
		//	this.stopAutoPlay();
		//	this._container.removeEventListener("mousedown", this._onMouseDown);
		//	this._container.removeEventListener("touchstart", this._onTouchStart);
		//	cpr.core.NotificationCenter.INSTANCE.unsubcribeAllTopic(this);
		//};
		//SlideView.prototype.startButton = function(){
		//	var container = this._innerContainer;
		//	var layout = this._innerLayout;
		//	
		//	
		//	var buttons = new cpr.controls.Button();
		//	buttons.value = "->";
		//	buttons.style.addClass("hanCont");
		//	container.floatControl(buttons,{
		//		"left" :"-100px",
		//		"top" : "calc(50%)",
		//		"width":"100px",
		//		"height":"100px"
		//	});
		//}
		//
		//SlideView.prototype.hanButton = function(cliX){
		//	var container = this._innerContainer;
		//	var layout = this._innerLayout;
		//
		//	// 스크롤 불능일 경우 중단.
		//	if (container.getViewPortRect().width >= container.getContentPaneRect().width) {
		//		return;
		//	}
		//
		//	if (this._knownScreenX < 0) {
		//		return;
		//	}
		//
		//	// 터치/마우스의 이동량을 구함.
		//	var delta = this._knownScreenX - cliX;
		//
		//	// 새로운 뷰포트의 위치
		//	var newScrollLeft = this._initialScrollLeft + delta;
		//	
		//	
		//	var btns = container.getChildren().find(function(each){
		//		if(each.isFloated()){
		//			
		//			return each;
		//		}
		//	});
		//	
		//	if(this._knownScreenX - cliX > 0){
		//		
		//		if(delta > 50) {
		//			delta = 50
		//		}
		//		container.floatControl(btns,{
		//			left : this._initialScrollLeft+container.getActualRect().width - delta+"px"
		//			
		//		});
		//	} else {
		//		
		//		if(Math.abs(delta) > 50) {
		//			delta =  -50
		//		}
		//		container.floatControl(btns,{
		//			left : this._initialScrollLeft-100 - delta +"px"
		//		})
		//	}
		//}
		///**
		// * 터치 시작 처리 핸들러
		// * @param {cpr.events.CTouchEvent} e
		// */
		//SlideView.prototype._onTouchStart = function(e) {
		//	if (this._activeAnimator) {
		//		return;
		//	}
		//	
		//	var touch = e.targetTouches.item(0);
		//	this._knownScreenX = touch.clientX;
		//	this._knownScreenY = touch.clientY;
		//	this._initialScrollLeft = this._innerContainer.getViewPortRect().x;
		//	window.addEventListener("touchmove", this._onTouchMove);
		//	window.addEventListener("touchend", this._onTouchEnd);
		//	this.startButton();
		//	e.stopPropagation();
		//	this.stopAutoPlay();
		//};
		//
		///**
		// * 터치 이동 핸들러
		// * @param {cpr.events.CTouchEvent} e
		// */
		//SlideView.prototype._onTouchMove = function(e) {
		//	
		//	var touch = e.targetTouches.item(0);
		//	
		//	var stx = Math.abs(this._knownScreenX - touch.clientX);
		//	var sty = Math.abs(this._knownScreenY - touch.clientY);
		//	if(this.scrollMode == null) {
		//		if(stx>sty) {
		//			this.scrollMode = "vertical";
		//		}
		//		if(stx<sty) {
		//			this.scrollMode = "horizon";
		//		}
		//	}
		//	 else {
		//	 	if(this.scrollMode == "vertical") {
		//			document.body.style.overflowY= "hidden";
		////			this._handleMove(touch.clientX);
		//			this.hanButton(touch.clientX);
		//	 		
		//	 	}
		//	 	else if(this.scrollMode == "horizon") {
		//	 		
		//	 	}
		//	 }
		//			
		//	e.stopPropagation();
		//};
		//
		///**
		// * 터치 종료 핸들러
		// * @param {cpr.events.CTouchEvent} e
		// */
		//SlideView.prototype._onTouchEnd = function(e) {
		//	document.body.style.overflowY= null;
		//	this.scrollMode = null;
		//	window.removeEventListener("touchmove", this._onTouchMove);
		//	window.removeEventListener("touchend", this._onTouchEnd);
		//	this._knownScreenX = -1;
		//	this._snapToClosestContent();
		//	var rects = this._innerContainer.getActualRect();
		//	var hanjin = null;
		//	this._innerContainer.getChildren().forEach(function(/*cpr.controls.UIControl*/each){
		//		if(each.isFloated()) {
		//			var buttonRect = each.getActualRect().left;
		//			if(buttonRect > 0) {
		//				if(rects.width - buttonRect > 45) {
		//					hanjin = "next";
		//				}
		//			} else {
		//				if(Math.abs(buttonRect) < 55) {
		//					hanjin="prev";
		//				}
		//			}
		//			each.dispose();
		//			
		//		}
		//	});
		//	if(hanjin == "next"){
		//		this.showNext();
		//	}
		//	 else if(hanjin == "prev") {
		//	 	this.showPrev();
		//	 }
		//};
		//
		///**
		// * 마우스 다운 핸들러
		// * @param {cpr.events.CMouseEvent} e
		// */
		//SlideView.prototype._onMouseDown = function(e) {
		//	if (e.button !== 0) {
		//		return;
		//	}
		//	if (this._activeAnimator) {
		//		return;
		//	}
		//
		//	// 마우스가 다운 된 위치를 기억 해 둠.
		//	//this._knownScreenX = e.screenX;
		//	this._knownScreenX = e.clientX;
		//
		//	// 현재 뷰포트의 위치를 기억해 둠.
		//	this._initialScrollLeft = this._innerContainer.getViewPortRect().x;
		//
		//	window.addEventListener("mouseup", this._onMouseUp);
		//	window.addEventListener("mousemove", this._onMouseMove);
		//
		//	// 혹시라도 마우스 업이 내비게이션 버튼에서 일어나, 드래깅 상태가 지속되는 문제를 미연에 방지.
		//	if (this._prevButton && this._nextButton) {
		//		this._prevButton.removeEventListener("mouseup", eventStopper);
		//		this._nextButton.removeEventListener("mouseup", eventStopper);
		//	}
		//
		//	this.stopAutoPlay();
		//	e.stopPropagation();
		//};
		//
		///**
		// * 마우스/터치의 이동 처리. 
		// * @param {Number} screenX
		// */
		//SlideView.prototype._handleMove = function(screenX) {
		//	var container = this._innerContainer;
		//	var layout = this._innerLayout;
		//
		//	// 스크롤 불능일 경우 중단.
		//	if (container.getViewPortRect().width >= container.getContentPaneRect().width) {
		//		return;
		//	}
		//
		//	if (this._knownScreenX < 0) {
		//		return;
		//	}
		//
		//	// 터치/마우스의 이동량을 구함.
		//	var delta = this._knownScreenX - screenX;
		//
		//	// 새로운 뷰포트의 위치
		//	var newScrollLeft = this._initialScrollLeft + delta;
		//
		//	// 왼쪽 경계선 너머로 스크롤.
		//	if (newScrollLeft < 0) {
		//		if (this.useInfiniteScroll === false) {
		//			container.scrollTo(0, 0);
		//			return;
		//		}
		//		var children = container.getChildren();
		//
		//		// 오른쪽 끝 자식을 떼어 내어 왼쪽으로 이동시키고, 스크롤 상황을 업데이트 함.
		//		var lastChild = children[children.length - 1];
		//		container.reorderChild(lastChild, 0);
		//		var fix = this._innerLayout.spacing + lastChild.getOffsetRect().width;
		//		this._initialScrollLeft += fix;
		//		container.scrollTo(fix, 0);
		//		cpr.core.DeferredUpdateManager.INSTANCE.update();
		//		return;
		//	}
		//
		//	// 오른쪽 경계선 너머로 스크롤.
		//	else if (newScrollLeft + container.getViewPortRect().width > container.getContentPaneRect().width) {
		//		if (this.useInfiniteScroll === false) {
		//			container.scrollTo(container.getContentPaneRect().width - container.getViewPortRect().width, 0);
		//			return;
		//		}
		//		var children = container.getChildren();
		//
		//		// 첫번째 자식을 떼어내어 오른쪽 끝으로 이동시키고 스크롤 상황을 업데이트 함.
		//		var firstChild = children[0];
		//
		//		var fix = firstChild.getOffsetRect().width + this._innerLayout.spacing;
		//		this._initialScrollLeft -= fix;
		//		container.reorderChild(firstChild, children.length);
		//		container.adjustScroll(-fix, 0);
		//		cpr.core.DeferredUpdateManager.INSTANCE.update();
		//		return;
		//	}
		//
		//	container.scrollTo(newScrollLeft, 0);
		//}
		//
		///**
		// * 
		// * @param {MouseEvent} e
		// */
		//SlideView.prototype._onMouseMove = function(e) {
		//	//this._handleMove(e.screenX);
		//	this._handleMove(e.clientX);
		//	e.preventDefault();
		//};
		//
		///**
		// * 
		// * @param {MouseEvent} e
		// */
		//SlideView.prototype._onMouseUp = function(e) {
		//	window.removeEventListener("mouseup", this._onMouseUp);
		//	window.removeEventListener("mousemove", this._onMouseMove);
		//	this._knownScreenX = -1;
		////	this._updateVisibleCtrl();
		////	cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(this._snapToClosestContent.bind(this));
		//	this._snapToClosestContent();
		//	if (this._prevButton && this._nextButton) {
		//		this._prevButton.addEventListener("mouseup", eventStopper);
		//		this._nextButton.addEventListener("mouseup", eventStopper);
		//	}
		//};
		//
		//SlideView.prototype._updateButtons = function() {
		//	if (this._container.getActualRect().width === 0) {
		//		cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(this._updateButtons.bind(this));
		//		return;
		//	}
		//	if (this._container.disposed) {
		//		return;
		//	}
		//	
		//	if (this._prevButton) {
		//		this._prevButton.dispose();
		//		this._prevButton = null;
		//	}
		//	if (this._nextButton) {
		//		this._nextButton.dispose();
		//		this._nextButton = null;
		//	}
		//	if(!this._pagination.control.disposed){
		//		
		//		this._pagination.control.visible = false;
		//		this._doUpdateButtons();
		//	}
		//}
		//
		//SlideView.prototype._doUpdateButtonsImmediatly = function() {
		//	if (this._container.disposed) {
		//		return;
		//	}
		//
		//	this._knownBounds = this._container.getOffsetRect();
		//	
		//	var shouldShowButtons = this._innerContainer.getChildrenCount() > 1 && this._innerContainer.getViewPortRect().width < this._innerContainer.getContentPaneRect().width;
		//	if (false) {
		//		if (this._prevButton) {
		//			this._prevButton.dispose();
		//			this._prevButton = null;
		//		}
		//		if (this._nextButton) {
		//			this._nextButton.dispose();
		//			this._nextButton = null;
		//		}
		//		this._pagination.control.visible = false;
		//	} else {
		//		if (!this._pagination.control.disposed) {
		//			
		//			this._pagination.control.visible = this.showPagination;
		//			if (this.showPagination) {
		//				if (this.adjustPagination) {
		//					this._pagination.control.style.css({
		//						top: "13px",
		//						left: "68px"
		//					});
		//				} else {
		//					this._pagination.control.style.css({
		//						top: this._knownBounds.bottom + "px",
		//						left: this._knownBounds.left + "px",
		//						width: this._knownBounds.width + "px"
		//					});
		//					this._pagination.control.style.animateFrom({
		//						"opacity": "0"
		//					});
		//				}
		//			}
		//		}
		//		if (this.navigationButtonStyle != "none") {
		//			this._prevButton = new cpr.controls.Button();
		//			this._prevButton.style.addClass("slide-button");
		//			this._prevButton.style.addClass("slide-prev-button");
		//			if (this.useInfiniteScroll != true){
		//				this._prevButton.enabled = false;
		//			}
		//			if (this.navigationButtonClassName) {
		//				this._prevButton.style.addClass(this.navigationButtonClassName);
		//			}
		//			this._prevButton.addEventListener("click", (function() {
		//				this.stopAutoPlay();
		//				this.showPrev();
		//				if (this.autoPlayDelay > 0){
		//					this.autoPlay();
		//				} else {
		//					this._prevButton.enabled = false;
		//					this._nextButton.enabled = true;
		//				}
		//			}).bind(this));
		//
		//			this._prevButton.addEventListener("mousedown", eventStopper);
		//			this._prevButton.addEventListener("mouseup", eventStopper);
		//			this._prevButton.addEventListener("click", eventStopper);
		//			
		//			this._nextButton = new cpr.controls.Button();
		//			this._nextButton.style.addClass("slide-button");
		//			this._nextButton.style.addClass("slide-next-button");
		//			if (this.navigationButtonClassName) {
		//				this._nextButton.style.addClass(this.navigationButtonClassName);
		//			}
		//			this._nextButton.addEventListener("click", (function() {
		//				this.stopAutoPlay();
		//				this.showNext();
		//				if (this.autoPlayDelay > 0){
		//					this.autoPlay();
		//				}
		//			}).bind(this));
		//			this._nextButton.addEventListener("mousedown", eventStopper);
		//			this._nextButton.addEventListener("mouseup", eventStopper);
		//			this._nextButton.addEventListener("click", eventStopper);
		//			
		//			/** @type cpr.controls.Container */
		//			var superContainer = this._container.getParent();
		//			var leftCosntraint = {
		//				left: this._knownBounds.left + "px",
		//				top: this._knownBounds.top + "px",
		//				height: this._knownBounds.height + "px",
		//				width: this.navigationButtonWidth + "px"
		//			};
		//			var rightConstraint = {
		//				left: this._knownBounds.right - this.navigationButtonWidth + "px",
		//				top: this._knownBounds.top + "px",
		//				height: this._knownBounds.height + "px",
		//				width: this.navigationButtonWidth + "px"
		//			};
		//			
		//			switch (this.navigationButtonStyle) {
		//				case "inside":
		//					{
		//						break;
		//					}
		//				case "content-hover":
		//					{
		//						var offsetRect = this._innerContainer.getOffsetRect();
		//						leftCosntraint.left = offsetRect.x + "px";
		//						leftCosntraint.top = offsetRect.y + "px";
		//						rightConstraint.left = offsetRect.right - this.navigationButtonWidth + "px";
		//						rightConstraint.top = offsetRect.y + "px";
		//						superContainer = this._container;
		//						break;
		//					}
		//				case "content-outside":
		//					{
		//						var offsetRect = this._innerContainer.getOffsetRect();
		//						leftCosntraint.left = offsetRect.x - this.navigationButtonWidth + "px";
		//						leftCosntraint.top = offsetRect.y + "px";
		//						rightConstraint.left = offsetRect.right + "px";
		//						rightConstraint.top = offsetRect.y + "px";
		//						superContainer = this._container;
		//						break;
		//					}
		//				case "outside":
		//					{
		//						leftCosntraint.left = this._knownBounds.left - this.navigationButtonWidth + "px";
		//						rightConstraint.left = this._knownBounds.right + "px";
		//						break;
		//					}
		//				case "cover":
		//					{
		//						leftCosntraint.left = this._knownBounds.left - (this.navigationButtonWidth / 2) + (this._container.getLayout().leftMargin /2) + "px";
		//						leftCosntraint.height = this.navigationButtonHeight + "px";
		//						leftCosntraint.top = this._knownBounds.top + ((this._knownBounds.height / 2) - (this.navigationButtonHeight / 2)) + "px";
		//						rightConstraint.left = this._knownBounds.right - (this.navigationButtonWidth / 2) - (this._container.getLayout().rightMargin / 2) + "px";
		//						rightConstraint.height = this.navigationButtonHeight + "px";
		//						rightConstraint.top = this._knownBounds.top + ((this._knownBounds.height / 2) - (this.navigationButtonHeight / 2)) + "px";
		//					}
		//			}
		//
		//			superContainer.floatControl(this._prevButton, leftCosntraint);
		//			superContainer.floatControl(this._nextButton, rightConstraint);
		//			this._prevButton.visible = false;
		//			this._nextButton.visible = false;
		//			cpr.core.DeferredUpdateManager.INSTANCE.asyncExec((function() {
		//				if (this._container.disposed) {
		//					return;
		//				}
		//				if (this._prevButton) {
		//					this._prevButton.visible = true;
		//					this._prevButton.style.animateFrom({
		//						"opacity": "0"
		//					});
		//				}
		//				if (this._nextButton) {
		//					this._nextButton.visible = true;
		//					this._nextButton.style.animateFrom({
		//						"opacity": "0"
		//					});
		//				}
		//			}).bind(this));
		//
		//		}
		//		this._snapToClosestContent();
		//	}
		//}
		//
		//SlideView.prototype._doUpdateButtons = function() {
		//	if (this._container.disposed) {
		//		return;
		//	}
		//	this._doUpdateButtonsImmediatly();
		//};
		//
		//SlideView.prototype._onResize = function() {
		//	if (this._container.disposed) {
		//		return;
		//	}
		//
		//	// 처음 그리는 경우.
		//	if (!this._knownBounds) {
		//		this._updateButtons();
		//	}
		//
		//	// 그외의 경우, 컨테이너의 영역이 달라진 경우에만 새로 그림.
		//	else if (this._knownBounds.equals(this._container.getOffsetRect()) === false) {
		//		this._updateButtons();
		//	}
		//};
		//
		//SlideView.prototype.showPrev = function() {
		//	if (this._activeAnimator) {
		//		return;
		//	}
		//	this._snapToClosestContent(0);
		//	this._knownScreenX = 0;
		//	this._initialScrollLeft = this._innerContainer.getViewPortRect().x
		//	var animator = new cpr.animation.Animator(this.autoPlayDuration, cpr.animation.TimingFunction.EASE_IN_OUT);
		//	var me = this;
		//	var fullWidth = this._innerContainer.getViewPortRect().width;
		//	var firstChild = this._innerContainer.getChildren()[0];
		//	var firstChildRect = firstChild.getOffsetRect();
		//	var oneWidth = firstChildRect.width + firstChildRect.left;
		//	
		//	animator.addTask(function(p) {
		//		me._handleMove(p * oneWidth);
		//	});
		//	this._activeAnimator = animator;
		//	animator.run().then((function() {
		//		this._activeAnimator = null;
		//		if(this._prevButton){
		//			var checker = this._findMostCloseControl(this._innerContainer.getViewPortRect().left );
		//			if(checker == firstChild) {
		//				this._prevButton.enabled = false;
		//			}
		//		}
		//	}).bind(this));
		//};
		//
		//SlideView.prototype.showNext = function() {
		//	if (this._activeAnimator) {
		//		return;
		//	}
		//
		//	var target = this._findMostCloseControl(this._innerContainer.getViewPortRect().right);
		//	if (target) {
		//		var offset = target.getOffsetRect().right;
		//		this._innerContainer.scrollTo(offset - this._innerContainer.getViewPortRect().width, 0, this.autoPlayDuration);
		//		
		//		/* 무한 스크롤 상태일 때 처음으로 되돌림 */
		//		if (this.useInfiniteScroll) {
		//			if (this.infiniteTarget == target) {
		//				this._innerContainer.scrollTo(0, 0, this.autoPlayDuration);
		//				return;
		//			} else {
		//				this.infiniteTarget = target;
		//			}
		//		} else {
		//			var last = this._innerContainer.getViewPortRect().left + this._innerContainer.getViewPortRect().right;
		//			//리소스를 덜 소비하는 쪽으로 찾길 바람
		//			/** @type Container */
		//			var child = this._innerContainer.getChildren();
		//			var lastChild = child[child.length-1];
		//			if(this._nextbutton){
		//				
		//				if(lastChild == target) {
		//					this._nextButton.enabled = false;
		//				} else {
		//					this._prevButton.enabled = true;
		//				}
		//			}
		//		}
		//	}
		//};
		//
		///**
		// * 가장 가까운 컨텐츠로 스크롤 시킵니다.
		// * @param {Number} viewportX
		// * @param {Boolean} rightFirst (Optional)
		// */
		//SlideView.prototype._findMostCloseControl = function(viewportX, rightFirst) {
		//	if (rightFirst === undefined) {
		//		rightFirst = false;
		//	}
		//	var shortedDistance = Number.MAX_VALUE;
		//	/** @type cpr.controls.UIControl */
		//	var controlToScroll = null;
		//	var children = this._innerContainer.getChildren();
		//	if (rightFirst) {
		//		children = children.reverse();
		//	}
		//	children.filter(function( /* cpr.controls.UIControl */ each) {
		//		return each.userAttr("-snap-point") == "true";
		//	}).forEach((function( /* cpr.controls.UIControl */ each) {
		//		var eachDistance = Math.abs(each.getOffsetRect().x - this._innerLayout.spacing - viewportX);
		//		if (eachDistance < shortedDistance) {
		//			shortedDistance = eachDistance;
		//			controlToScroll = each;
		//		}
		//	}).bind(this));
		//	return controlToScroll;
		//};
		//
		///**
		// * 가장 가까운 컨텐츠로 스크롤 시킵니다.
		// */
		//SlideView.prototype._snapToClosestContent = function(duration) {
		//	
		//	
		//	if (duration == null) {
		//		duration = this.snapDuration;
		//	}
		//	if (this._container.disposed) {
		//		return;
		//	}
		//	var viewPortRect = this._innerContainer.getViewPortRect();
		//	var controlToScroll = this._findMostCloseControl(viewPortRect.x);
		//	//TODO 슬라이드 시 버튼 활성/비활성화
		//	if (this.useInfiniteScroll == false){
		//		var children = this._innerContainer.getChildren();
		//		if(this._prevButton){
		//			
		//			if(children.indexOf(controlToScroll) != 0) {
		//				this._prevButton.enabled = true;
		//			} else {
		//				this._prevButton.enabled = false;
		//			}
		//		}
		//		if(this._nextButton){
		//			
		//			if(children.indexOf(controlToScroll) + this.showCount == children.length) {
		//				this._nextButton.enabled = false;
		//			} else {
		//				this._nextButton.enabled = true;
		//			}
		//		}
		//	}
		//	if (controlToScroll && viewPortRect.width >= controlToScroll.getOffsetRect().width) {
		//		var mover = controlToScroll.getOffsetRect().x - this._innerLayout.spacing;
		//		this._innerContainer.scrollTo(mover, 0, duration, cpr.animation.TimingFunction.EASE_OUT_CUBIC);
		//	}
		//};
		//
		//
		//SlideView.prototype.getActivePage = function() {
		//	var control = this._findMostCloseControl(this._innerContainer.getViewPortRect().x);
		//	return Math.floor(this._originalChildren.indexOf(control) / this.showCount);
		//};
		//
		///**
		// * @param {Number} page
		// * @param {Number} duration (Optional)
		// */
		//SlideView.prototype.setActivePage = function(page, duration) {
		//	if (this._container.disposed) {
		//		return;
		//	}
		//	if (duration == null) {
		//		duration = 0;
		//	}
		//	var targetControl = this._originalChildren[page * this.showCount];
		//	if (targetControl) {
		//		this._innerContainer.scrollTo(targetControl.getOffsetRect().x - this._innerLayout.spacing, 0, duration);
		//	}
		//};
		//
		//SlideView.prototype._updateActivePageButton = function() {
		//	if (this._container.disposed) {
		//		return;
		//	}
		//	var activePage = this.getActivePage();
		//	this._pagination.control.getChildren().forEach(function( /* cpr.controls.Button */ each, idx) {
		//		if (idx == activePage) {
		//			each.style.addClass("active");
		//		} else {
		//			each.style.removeClass("active");
		//		}
		//	});
		//	if(this.onBeforeChangePagination){
		//		this.onBeforeChangePagination();
		//	}
		//	//2021-04-23 페이지네이션 컨텐츠 밑에 붙게하는 스크립트]
		////	cpr.core.DeferredUpdateManager.INSTANCE.update();
		//	var closer = this._findMostCloseControl(this._innerContainer.getViewPortRect().x);
		//	if(this._pagination.control) {
		//		this._pagination.control.getParent().floatControl(this._pagination.control,{
		//			top : closer.getActualRect().height+"px",
		//		});
		//	}
		//	this._innerContainer.getParent().updateConstraint(this._innerContainer, {
		//		height : closer.getActualRect().height+this._pagination.control.getActualRect().height+"px"
		//	});
		//	if (this.onChangePagination) {
		//		this.onChangePagination();
		//	}
		//	
		//}
		//
		//SlideView.prototype.updateContentHeight = function(){
		//	cpr.core.DeferredUpdateManager.INSTANCE.update()
		//	
		//	var closer = this._findMostCloseControl(this._innerContainer.getViewPortRect().x);
		//	if(this._pagination.control) {
		//		this._pagination.control.getParent().floatControl(this._pagination.control,{
		//			top : closer.getActualRect().height+"px",
		//		});
		//	}
		//	this._innerContainer.getParent().updateConstraint(this._innerContainer, {
		//		height : closer.getActualRect().height+this._pagination.control.getActualRect().height+"px"
		//	});
		//	cpr.core.DeferredUpdateManager.INSTANCE.update()
		//	this._snapToClosestContent(0);
		//}
		//SlideView.prototype._updateVisibleCtrl = function(){
		//	
		//	var closer = this._findMostCloseControl(this._innerContainer.getViewPortRect().x);
		//	this._innerContainer.getParent().updateConstraint(this._innerContainer, {
		//		height : closer.getActualRect().height+this._pagination.control.getActualRect().height+"px"
		//	});
		//	
		//	cpr.core.DeferredUpdateManager.INSTANCE.update();
		//	
		//}
		//
		///**
		// * 슬라이드 페이지인덱서 영역을 생성합니다.
		// * @param {SlideView} owner
		// */
		//function SlidePagination(owner) {
		//	this._owner = owner;
		//	this.control = new cpr.controls.Container();
		//	this.control.visible = false;
		//	this.control.clipContent = false;
		//	this.control.style.addClass("paginations");
		//	var layout = new cpr.controls.layouts.FlowLayout();
		//	if (this.adjustPagination){
		////		layout.topMargin = 0;
		//		layout.rightMargin = 0;
		//		layout.bottomMargin = 0;
		//		layout.leftMargin = 0;
		//		layout.horizontalAlign = "left";
		//		layout.verticalAlign = "middle";
		//	} else {
		//		layout.topMargin = 20;
		//		layout.rightMargin = 0;
		//		layout.bottomMargin = 0;
		//		layout.leftMargin = 0;
		//		layout.horizontalAlign = "center";
		//		layout.verticalAlign = "middle";
		//	}
		//	layout.lineWrap = false;
		//	layout.spacing = 12;
		//	layout.scrollable = false;
		//	this.control.setLayout(layout);
		//	this._populateButtons();
		//};
		//
		///** @type cpr.controls.Container */
		//SlidePagination.prototype.control = null;
		//
		//SlidePagination.prototype._populateButtons = function() {
		//	var pageCount = Math.ceil(this._owner._originalChildren.length / this._owner.showCount);
		//	for (var idx = 0; idx < pageCount; idx++) {
		//		(function(idx) {
		//			var pageButton = new cpr.controls.Output();
		//			pageButton.style.addClass("pagination-blt");
		//			pageButton.addEventListener("click", (function(e) {
		//				this._owner.stopAutoPlay();
		//				if (this._owner._activeAnimator) {
		//					this._owner._activeAnimator.stop();
		//					this._owner._activeAnimator = null;
		//				}
		//				this._owner.setActivePage(idx, this._owner.autoPlayDuration);
		//			}).bind(this));
		//			if(this._owner._originalChildren[idx].visible == true){
		//				
		//				this.control.addChild(pageButton, {
		//					width: "6px",
		//					height: "6px",
		//					autoSize: "both"
		//				});
		//			}
		//		}).bind(this)(idx);
		//	}
		//};
		//
		//
		///**
		// * 페이지네이션이 변경되었을 때의 콜백.
		// */
		//SlideView.prototype.onChangePagination = function() {
		//	
		//}
		//
		//SlideView.prototype.onBeforeChangePagination = function(){
		//	
		//}
		//
		///**
		// * 슬라이더의 한번에 보일 아이템 갯수를 수정하는 경우가 있을 경우, innerCOntainer를 초기화하는함수입니다.
		// * 해당 함수를 수행후 showCount를 변경하고 _transfrom을 수행하십시오.
		// */
		//SlideView.prototype.clear = function(){
		//	if (this._container.getActualRect().width === 0) {
		//		cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(this.clear.bind(this));
		//		return;
		//	}
		//	var vcInnerContainer = this._container;
		//		
		//		this._innerContainer.getChildren().forEach(function(each){
		//		vcInnerContainer.addChild(each, {
		//			width:"100px",
		//			height:"100px",
		//			autoSize:"none"
		//		});
		//		});
		//		
		//		this._innerContainer.dispose();
		//		this._pagination.control.dispose();
		//}
		//
		//SlideView.prototype.paginationRestore = function(){
		//	
		//	this._pagination.control.dispose();
		//	this._pagination.control = null;
		//	this._pagination = new SlidePagination(this);
		//	this._pagination.control.userAttr("swiped", "true");
		//	this._container.getParent().floatControl(this._pagination.control);
		//}
		//SlideView.prototype.restore = function(){
		//	
		//	
		//
		//}
		//
		//SlideView.prototype.getNowVisibleCtrl = function(){
		//	
		//	var vcNowVisibleCtrl = this._findMostCloseControl(this._innerContainer.getViewPortRect().x);
		//	
		//	return vcNowVisibleCtrl;
		//}
		///**
		// * 
		// * @param {cpr.controls.Container} container
		// */
		//exports.slidify = function(container) {
		//	return new SlideView(container);
		//};
		//
		//exports.SlideView = SlideView;
	});
})();
/// end - 202105/swiper_mobile_temp
/// start - 202106/DataTransfer
/*
 * Module URI: 202106/DataTransfer
 * SRC: 202106/DataTransfer.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202106/DataTransfer", function(exports, globals, module){
		//
		//globals.clientUUID ;
		//
		//
		//
		///************************************************
		// * DataTransfer.module.js
		// * Created at 2021. 5. 18. 오전 9:01:14.
		// *
		// * @author HANS
		// ************************************************/
		//String.prototype.replaceAll = function(org,dest) {
		//	return this.split(org).join(dest);
		//}
		//
		//var targetApplication = {
		//		"GetIOValue" : "SOCKET_SERVER",
		//		"WriteIO" : "SCHEDULER",
		//		"DWriteIO" : "SOCKET_SERVER",
		//		"SetEvent" : "APPLICATION_NAME",
		//		"QuerySQL" : "SOCKET_SERVER"
		//}
		//
		//
		///**
		// * 
		// * @param {String} psString
		// */
		//function findAppInstanceWithTitle(psString){
		//	
		//	var vaInstances = cpr.core.Platform.INSTANCE.getAllRunningAppInstances();
		//	var voReturns = null;
		//	
		//	vaInstances = vaInstances.filter(function(each){
		//		if(each.app.id.indexOf("udc") == -1 && each.app.title == psString) {
		//			
		//			return each;
		//		}
		//	});
		//	
		//	if(vaInstances.length > 1) {
		//		voReturns = vaInstances[0];
		//	}
		//	
		//	return voReturns;
		//}
		//
		///**
		// * 
		// * @param {cpr.core.AppInstance} poAppInstance
		// * @param {String} psActionCommand
		// */
		//globals.remakePageParam = function(poAppInstance,psActionCommand){
		//	var aps = poAppInstance;
		//	var allDC = [];
		//	var req = {};
		//	
		//	var voRootApp = aps.getRootAppInstance();
		//	req[voRootApp.app.title] = returnDC(voRootApp);
		//	req[aps.app.title] = returnDC(aps);
		//	
		//	
		//	
		//	
		//	var searchObj = {
		//		searItem : "" 
		//	};
		//	
		//	var requestObj = {
		//		CMD : psActionCommand,
		//		PAGE_NM : aps.app.title,
		//		TAR_APP : targetApplication[psActionCommand],
		//		DAT : req,
		//		SEARCH : searchObj ,
		//	    RP_TOT_CNT : 100, 
		//		RP_CUR_CNT : 0  ,// 서버측에서 체워서 옴  if( response_tot_cnt == response_cur_cnt ) 다시요청 
		//		DLY_TIM    : 500 ,
		//		REQUEST_SEQ      : 1  , //식별자  
		//		RP_TXT : "" ,  //장애등 관련 RETURN 
		//		RP_CD  : "",
		//		COMM_METHOD : "NO_THREAD"
		//		
		//		//리트라이 횟수
		//	}
		//	return requestObj;
		//}
		//
		///**
		// * 
		// * @param {cpr.core.AppInstance} poAppInstance
		// */
		//function returnDC(poAppInstance){
		// 
		//	var aps = poAppInstance;
		//	var vaDc = aps.getAllDataControls();
		//	/** @type cpr.data.DataMap[] */
		//	var vaDm = vaDc.filter(function(each){
		//		if(each instanceof cpr.data.DataMap && each.userAttr("isParamData") == "Y") {
		//			
		//			return each;
		//		}
		//	});
		//	console.log(vaDm);
		//	var res = {};
		//	
		//	vaDm.forEach(function(each){
		//		var req = {};
		//		each.getHeaders().forEach(function(eachCol){
		//			req[eachCol.getName()] = "";
		//		});
		//		res[each.id] = req;
		//	});
		//	
		//	return res;
		//}
		//
		///**
		// * 페이지 로드시 생성되는 웹소켓에서  화면에서 필요한 스테이션과, 각 스테이션별 컬럼에 어떠한 프로토콜명으로 값을 받아와야 하는지를 알려주는 파라미터를 만들어주는 함수입니다.
		// * 모든 화면의 파라미터는 해당 화면에 선언되어있는 데이터셋과 데이터맵의 정보를 근거로 구성되며, 데이터 컴포넌트의 사용자 속성 isParamData가 Y인 데이터 컴포넌트의 컬럼명을 수집하여 사용합니다.
		// * 데이터 컴포넌트의 전체 정보를 파라미터로 넘기는게 아닌,사용자가 직접 작성한 Object를 보내고 싶을 경우, 세번쨰 파라미터 poDataObj에 오브젝트를 입력할 경우 해당 오브젝트가 파라미터에 적재됩니다.
		// * @param {cpr.core.AppInstance} poAppInstance
		// * @param {String} psActionCommand
		// * @param {Object} poDataObj?
		// * @return {Object}
		// */
		//globals.pageParamMake = function(poAppInstance,psActionCommand,poDataObj) {
		//	
		//	var aps = poAppInstance;
		//	var allDC = [];
		//	var req = {};
		//	if(poDataObj != null){
		//		
		//		req = poDataObj
		//	}else {
		//		
		//		allDC = aps.getAllDataControls().filter(function(each){
		//			
		//			if(each.userAttr("isParamData") == "Y") return each;
		//		});;
		//	
		//	var allDs = allDC.filter(function(each){
		//		if(each instanceof cpr.data.DataSet)
		//		return each;
		//	});
		//	var allDm = allDC.filter(function(each){
		//		if(each instanceof cpr.data.DataMap)
		//		return each;
		//	});
		//	
		//	
		//	allDs.forEach(function(/*cpr.data.DataSet*/each){
		//		
		//		var ds = each;
		//		var vsInfo = ds.info;
		//		var res = {};
		//			ds.getHeaders().forEach(function(eachH){
		//				var vsColInfo = eachH.getName();
		////				req[vsInfo].push(vsColInfo);
		////				vsColInfo = vsColInfo.replaceAll("__", ".");
		//				res[vsColInfo] = "";
		//			});
		//			req[vsInfo] = res;
		////		}
		//		
		//	});
		//	allDm.forEach(function(/*cpr.data.DataMap*/each){
		//		var dm = each;
		//		var vsDmInfo = dm.id;
		////		req[vsDmInfo];
		//		/** @type Object */
		//		var res = {};
		//		dm.getHeaders().forEach(function(eachH){
		//			var vsDmColInfo = eachH.getName();
		////			req[vsDmInfo].push(vsDmColInfo);
		//
		//				//vsDmColInfo = vsDmColInfo.replaceAll("__", ".");
		//			res[vsDmColInfo] = "";
		//		});
		//		req[vsDmInfo] = res;
		//	
		//	});
		//	}
		//	//검색조건 
		//	var searchObj = {
		//		searItem : "" 
		//	};
		//	
		//	
		//	var requestObj = {
		//		CMD : psActionCommand,
		//		PAGE_NM : aps.app.title,
		//		TAR_APP : targetApplication[psActionCommand],
		//		DAT : req,
		//		SEARCH : searchObj ,
		//	    RP_TOT_CNT : 100, 
		//		RP_CUR_CNT : 0  ,// 서버측에서 체워서 옴  if( response_tot_cnt == response_cur_cnt ) 다시요청 
		//		DLY_TIM    : 500 ,
		//		REQUEST_SEQ      : 1  , //식별자  
		//		RP_TXT : "" ,  //장애등 관련 RETURN 
		//		RP_CD  : "",
		//		COMM_METHOD : "NO_THREAD"
		//		
		//		//리트라이 횟수
		//	}
		//	return requestObj;
		//}
		//
		///**
		// * 소켓 메세지의 Body영역에 내려온 데이터를 통해, 실제 화면에 구성된 데이터셋의 컬럼들의 값으로 빌드될 수있도록
		// * 스테이션 명으로 데이터컴포넌트를 찾고, Object의 key값들을 수정하는 함수입니다.
		// * 
		// * @param {cpr.core.AppInstance} poAppInstance
		// * @param {string} messageBody
		// */
		//function SocketMessageBuild(poAppInstance,messageBody) {
		//	var message = messageBody;
		//	try {
		//		var json = JSON.parse(message);
		//		json = json["DAT"];
		//		var vaKeys = Object.keys(json);
		//		/** @type cpr.data.DataCollection[] */
		//		var vaDataCtrls = poAppInstance.getAllDataControls();
		//		vaKeys.forEach(function(each) {
		//			/** @type Array */
		//			var data = json[each];
		//			
		//			if (!(data instanceof Array)) {
		//				data = [data];
		//			}
		//			var dataCtrl = vaDataCtrls.find(function(ele) {
		//				if (ele.id == each) {
		//					return ele;
		//				}
		//			});
		//			if(dataCtrl){
		////				/** @type String[] */
		////					var vaColKey = Object.keys(data[0]);
		////					data.forEach(function(eachRow) {
		////						
		////						vaColKey.forEach(function(eachKey){
		////							if(eachKey.indexOf(".") > -1) {
		////								
		////								var vsReplacedKey = eachKey.replaceAll(".", "__");
		////								eachRow[vsReplacedKey] = eachRow[eachKey];
		////								delete eachRow[eachKey];
		////							}
		////						});
		////					});
		//					
		//				if (dataCtrl instanceof cpr.data.DataSet) {
		//					
		//					dataCtrl.build(data);
		//				} else {
		//					dataCtrl.build(data[0]);
		//				}
		//			}
		//		});
		//	} catch (err) {
		//		console.log(err);
		//	}
		//}
		//
		//
		//
		//
		//globals.SocketMessageBuild = SocketMessageBuild;
	});
})();
/// end - 202106/DataTransfer
/// start - 202106/testF/responsiveForm
/*
 * Module URI: 202106/testF/responsiveForm
 * SRC: 202106/testF/responsiveForm.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202106/testF/responsiveForm", function(exports, globals, module){
		//var ATTR_MOBILE_H_MARGIN = "mobile-horizontal-margin";
		//var ATTR_MOBILE_V_MARGIN = "mobile-vertical-margin";
		//var ATTR_TABLET_H_MARGIN = "tablet-horizontal-margin";
		//var ATTR_TABLET_V_MARGIN = "tablet-vertical-margin";
		//
		//var ATTR_MOBILE_COLUMN_COUNT = "mobile-column-count";
		//var ATTR_TABLET_COLUMN_COUNT = "tablet-column-count";
		////폼레이아웃 자식내 모바일일경우 숨김 지정
		//var ATTR_HIDE_ON_MOBILE = "hide-on-mobile";
		//var ATTR_NEEDS_AUTO_HEIGHT = "needs-auto-height";
		//var ATTR_COLLAPSE_DIRECTION = "collapse-direction";
		//
		//var ATTR_MOBILE_MIN_HEIGHT = "mobile-min-height";
		//var ATTR_TABLET_MIN_HEIGHT = "tablet-min-height";
		//
		//var ATTR_MOBILE_INDEX = "mobile-index";
		//var ATTR_TABLET_INDEX = "tablet-index";
		////모바일일 경우 그리드 cell 숨기기.
		//var ATTR_HIDE_CELL_INDICIES = "hide-cell-indicies";
		//
		///**
		// * 
		// * @param {cpr.controls.layouts.FormDivision} div
		// */
		//function copyDiv(div) {
		//	var result = new cpr.controls.layouts.FormDivision(div.lengthExpression);
		//	result.autoSizing = div.autoSizing;
		//	result.hidden = div.hidden;
		//	result.shades = div.shades;
		//	result.customShadeColor = div.customShadeColor;
		//	result.minLength = div.minLength;
		//	return result;
		//}
		//
		///**
		// * 반응형 폼 레이아웃 유틸리티.
		// * @param {cpr.controls.Container} container 폼 레이아웃을 가진 컨테이너.
		// */
		//function RForm(container) {
		//	this._container = container;
		//
		//	this._columnSettings = {};
		//
		//	this._onScreenChange = this._onScreenChange.bind(this);
		//	this._started = false;
		//}
		//
		///**
		// * 화면 크기별 컬럼 설정
		// * @type {{[key:string]:number}}
		// */
		//RForm.prototype._columnSettings = {};
		//
		///** @type cpr.controls.layouts.FormLayout */
		//RForm.prototype._originalLayout = null;
		//
		///** @type cpr.utils.ObjectMap */
		//RForm.prototype._originalConstraints = null;
		//
		///** @type cpr.core.AppInstance */
		//RForm.prototype._appInstance = null;
		//
		///**
		// * 
		// * @param {String} screenName
		// * @param {String[]} colCount
		// */
		//RForm.prototype.setColumnSettings = function(screenName, colCount) {
		//	this._columnSettings[screenName] = colCount;
		//
		//};
		//
		///**
		// * 초기 상태 백업.
		// */
		//RForm.prototype._backup = function() {
		//	// 원래 컨스트레인트들.
		//	this._originalConstraints = new cpr.utils.ObjectMap();
		//
		//	var children = this._container.getChildren();
		//	for (var idx = 0; idx < children.length; idx++) {
		//		var eachChild = children[idx];
		//		var constraint = this._container.getConstraint(eachChild);
		//		this._originalConstraints.put(eachChild, constraint);
		//	}
		//
		//	this._originalLayout = this._container.getLayout();
		//};
		//
		//RForm.prototype.start = function() {
		//	if (this._started) {
		//		return;
		//	}
		//	this._backup();
		//	this._appInstance = this._container.getAppInstance();
		//	this._appInstance.addEventListener("screen-change", this._onScreenChange);
		//	this._container.addEventListenerOnce("dispose", this.stop.bind(this));
		//	this._started = true;
		//};
		//
		//RForm.prototype.stop = function() {
		//	if (!this._started) {
		//		return;
		//	}
		//	if (this._appInstance) {
		//		this._appInstance.removeEventListener("screen-change", this._onScreenChange);
		//		this._appInstance = null;
		//	}
		//
		//	this._started = false;
		//};
		//
		//RForm.prototype._restore = function() {
		//	this._container.setLayout(this._originalLayout);
		//	/** @type cpr.controls.VisibleUIControl[] */
		//	var children = this._container.getChildren();
		//	for (var idx = 0; idx < children.length; idx++) {
		//		var eachChild = children[idx];
		//		eachChild.visible = true;
		//		this._container.replaceConstraint(eachChild, this._originalConstraints.get(eachChild));
		//	}
		//	this._clearCollapseClasses();
		//}
		//
		///**
		// * 
		// * @param {cpr.events.CScreenChangeEvent} e
		// */
		//RForm.prototype._onScreenChange = function(e) {
		//	var colSettings = this._columnSettings[e.screen.name];
		//	if(this._appInstance.id.indexOf("MainPage") != -1)
		//	console.log(colSettings);
		//	if (colSettings == null || colSettings <= 0) {
		//		this._restore();
		//	} else {
		//		this._transform(colSettings);
		//	}
		//};
		//
		///**
		// * @return {cpr.controls.VisibleUIControl[]}
		// */
		//RForm.prototype._getSortedChildren = function() {
		//	var children = this._container.getChildren().slice(0);
		//	var me = this;
		//	var useVerticalFirstSort = this._container.userAttr(ATTR_COLLAPSE_DIRECTION) == "vertical";
		//
		//	/** @type String */
		//	var explictIndexAttribute = null;
		//	switch (this._container.getAppInstance().targetScreen.name) {
		//		case "mobile":
		//			{
		//				explictIndexAttribute = ATTR_MOBILE_INDEX;
		//				break;
		//			}
		//
		//		case "tablet":
		//			{
		//				explictIndexAttribute = ATTR_TABLET_INDEX;
		//				break;
		//			}
		//	}
		//
		//	return children.sort(function( /* cpr.controls.UIControl*/ a, /* cpr.controls.UIControl*/ b) {
		//
		//		var indexA = parseInt(a.userAttr(explictIndexAttribute) || "9999");
		//		var indexB = parseInt(b.userAttr(explictIndexAttribute) || "9999");
		//		var explictIndexGap = indexA - indexB;
		//		if (explictIndexGap !== 0) {
		//			return explictIndexGap;
		//		}
		//
		//		/** @type cpr.controls.layouts.FormConstraint */
		//		var constA = me._originalConstraints.get(a);
		//
		//		/** @type cpr.controls.layouts.FormConstraint */
		//		var constB = me._originalConstraints.get(b);
		//		var rowDiff = constA.rowIndex - constB.rowIndex;
		//		var colDiff = constA.colIndex - constB.colIndex;
		//
		//		if (useVerticalFirstSort) {
		//			return colDiff !== 0 ? colDiff : rowDiff;
		//		} else {
		//			return rowDiff !== 0 ? rowDiff : colDiff;
		//		}
		//	});
		//};
		//
		///**
		// * 
		// * @param {Number} colCount
		// */
		//RForm.prototype._transform = function(colCount) {
		//	var layout = new cpr.controls.layouts.FormLayout();
		//	this._container.setLayout(layout);
		//	console.log(this._container.id);
		//	layout.horizontalMargin = this._originalLayout.horizontalMargin;
		//	layout.verticalMargin = this._originalLayout.verticalMargin;
		//	layout.horizontalSpacing = this._originalLayout.horizontalSpacing;
		//	layout.verticalSpacing = this._originalLayout.verticalSpacing;
		//	layout.horizontalSeparatorWidth = this._originalLayout.horizontalSeparatorWidth;
		//	layout.horizontalSeparatorClass = this._originalLayout.horizontalSeparatorClass;
		//	layout.verticalSeparatorWidth = this._originalLayout.verticalSeparatorWidth;
		//	layout.verticalSeparatorClass = this._originalLayout.verticalSeparatorClass;
		//
		//	switch (this._appInstance.targetScreen.name) {
		//		case "mobile":
		//			if (this._container.userAttr(ATTR_MOBILE_H_MARGIN)) {
		//				layout.horizontalMargin = this._container.userAttr(ATTR_MOBILE_H_MARGIN);
		//			}
		//			if (this._container.userAttr(ATTR_MOBILE_V_MARGIN)) {
		//				layout.verticalMargin = this._container.userAttr(ATTR_MOBILE_V_MARGIN);
		//			}
		//			break;
		//
		//		case "tablet":
		//			if (this._container.userAttr(ATTR_TABLET_H_MARGIN)) {
		//				layout.horizontalMargin = this._container.userAttr(ATTR_TABLET_H_MARGIN);
		//			}
		//			if (this._container.userAttr(ATTR_TABLET_V_MARGIN)) {
		//				layout.verticalMargin = this._container.userAttr(ATTR_TABLET_V_MARGIN);
		//			}
		//			break;
		//
		//	}
		//
		//	var columnDivisions = this._originalLayout.getColumnDivisions();
		//	var colSettings = columnDivisions.slice(0, colCount);
		//
		//	// 모바일이나 태블릿이 컬럼 개수가 더 많은 경우 처리.
		//	while (colSettings.length < colCount) {
		//		colSettings.push(copyDiv(colSettings[colSettings.length - 1]));
		//	}
		//
		//	var rowDiv = new cpr.controls.layouts.FormDivision("1fr");
		//	var vnRowMinLength = 10;
		//	
		//	var rowDivisions = this._originalLayout.getRowDivisions();
		//	colSettings.forEach(function( /* cpr.controls.layouts.FormDivision */ each, idx) {
		//		if(rowDivisions[idx]){
		//			var vsLengthExp  = rowDivisions[idx].lengthExpression;
		//			vsLengthExp = vsLengthExp.replace("px", "");
		//			var vnLengthExp = ValueUtil.fixNumber(vsLengthExp);
		//			if(vnRowMinLength < vnLengthExp){
		//					vnRowMinLength = vnLengthExp;
		//			}	
		//		}
		//		
		//	});
		//	if(vnRowMinLength > 10){
		//		rowDiv.minLength =  vnRowMinLength;	
		//	}
		//	
		//   		
		//
		//	// 세로 컬랩스 처리.
		//	if (this._container.userAttr(ATTR_COLLAPSE_DIRECTION) == "vertical") {
		//		var rowDivisions = this._originalLayout.getRowDivisions();
		//		colSettings.forEach(function( /* cpr.controls.layouts.FormDivision */ each, idx) {
		//			each.shades = rowDivisions[idx].shades;
		//			each.customShadeColor = rowDivisions[idx].customShadeColor;
		//		});
		//		rowDiv.shades = false;
		//	}
		//
		//	var lastColDiv = colSettings[colSettings.length - 1];
		//	lastColDiv.lengthExpression = "1fr";
		//	lastColDiv.shades = false;
		//	layout.setColumnDivisions(colSettings);
		//
		//	var numberOfColumns = colSettings.length;
		//	var sortedChildren = this._getSortedChildren();
		//	var visibleChildren = sortedChildren.filter(function( /* cpr.controls.VisibleUIControl */ each) {
		//		return each.userAttr("hide-on-mobile") != "true";
		//	});
		//
		//	var hiddenChildren = sortedChildren.filter(function( /* cpr.controls.VisibleUIControl */ each) {
		//		return each.userAttr("hide-on-mobile") == "true";
		//	}).forEach(function( /* cpr.controls.VisibleUIControl */ each) {
		//		each.visible = false;
		//	});
		//
		//	var rowIndex = 0;
		//	var columnIndex = 0;
		//	var rowNeedsAutoHeight = false;
		//
		//	/** @type cpr.controls.layouts.FormDivision[] */
		//	var rows = [];
		//
		//	for (var idx = 0; idx < visibleChildren.length; idx++) {
		//		if (rows[rowIndex] == null) {
		//			rows.push(copyDiv(rowDiv));
		//		}
		//		/**
		//		 * 현재 행에 남은 컬럼 수.
		//		 */
		//		var leftColumnsInCurrentLine = numberOfColumns - columnIndex;
		//		var each = visibleChildren[idx];
		//		each.visible = true;
		//
		//		/**
		//		 * 원래 컨스트레인트.
		//		 * @type cpr.controls.layouts.FormConstraint
		//		 */
		//		var originalConstraint = this._originalConstraints.get(each);
		//		var originalColSpan = originalConstraint.colSpan || 1;
		//
		//		var colSpan = Math.min(originalColSpan, leftColumnsInCurrentLine);
		//
		//		this._container.replaceConstraint(each, {
		//			rowIndex: rowIndex,
		//			colIndex: columnIndex,
		//			colSpan: colSpan
		//		});
		//		if(each.userAttr("leng") != "") {
		//			console.log("ㅋㅅㅋ");
		//			rows[rows.length - 1].lengthExpression = each.userAttr("leng");
		//		}
		//
		//		if (each.userAttr(ATTR_NEEDS_AUTO_HEIGHT) == "true") {
		//			rows[rows.length - 1].autoSizing = true;
		//			rows[rows.length - 1].lengthExpression = "25px";
		//		}
		//
		//		if (each.userAttr(ATTR_MOBILE_MIN_HEIGHT)) {
		//			var eachMinLength = parseInt(each.userAttr(ATTR_MOBILE_MIN_HEIGHT));
		//			var knownRow = rows[rows.length - 1];
		//			if (knownRow.lengthExpression.match(".*fr$")) {
		//				knownRow.minLength = Math.max(knownRow.minLength, eachMinLength);
		//			} else {
		//				knownRow.lengthExpression = Math.max(parseInt(knownRow.lengthExpression), eachMinLength) + "px";
		//			}
		//		}
		//
		//		columnIndex = columnIndex + colSpan;
		//
		//		if (columnIndex >= numberOfColumns) {
		//			rowIndex++;
		//			columnIndex = 0;
		//		}
		//	}
		//	console.log(rows);
		//	layout.setRowDivisions(rows);
		//
		//	this._clearCollapseClasses();
		//	this._container.style.addClass("collapsed");
		//	this._container.style.addClass("collapsed-" + colCount);
		//};
		//
		///**
		// * 
		// * @param {Number} colCount
		// */
		//RForm.prototype._clearCollapseClasses = function() {
		//	var classes = this._container.style.getClasses();
		//	var collapseClasses = classes.filter(function( /* String */ each) {
		//		return each.indexOf("collapsed") === 0;
		//	});
		//	collapseClasses.forEach((function( /* String */ each) {
		//		this._container.style.removeClass(each);
		//	}).bind(this));
		//}
		//
		//
		///**
		// * 
		// * @param {cpr.controls.Grid} grid
		// */
		//function RGrid(grid) {
		//	
		//	this._grid = grid;
		//	this._app = grid.getAppInstance();
		//	this._onScreenChange = this._onScreenChange.bind(this);
		//	this._app.addEventListener("screen-change", this._onScreenChange);
		//	grid.addEventListener("dispose", this._handleDispose.bind(this));
		//}
		//
		//RGrid.prototype._handleDispose = function(e) {
		//	this._app.removeEventListener("screen-change", this._onScreenChange);
		//};
		//
		///**
		// * @param {cpr.events.CScreenChangeEvent} e
		// */
		//RGrid.prototype._onScreenChange = function(e) {
		//	switch (e.screen.name) {
		//		case "mobile":
		//			{
		//				this.collapse();
		//				break;
		//			}
		//
		//		default:
		//			{
		//				this.restore();
		//				break;
		//			}
		//	}
		//}
		//
		//RGrid.prototype.collapse = function() {
		//	var indicies = this._grid.userAttr(ATTR_HIDE_CELL_INDICIES).split(/[\s,]+/g).map(function( /* String */ each) {
		//		return parseInt(each);
		//	});
		//	var grid = this._grid;
		//	indicies.forEach(function( /* Number */ each) {
		//		if(grid.header.getColumn(each)){
		//			grid.header.getColumn(each).visible = false;	
		//		}
		//	});
		//};
		//
		//RGrid.prototype.restore = function() {
		//	var indicies = this._grid.userAttr(ATTR_HIDE_CELL_INDICIES).split(/[\s,]+/g).map(function( /* String */ each) {
		//		return parseInt(each);
		//	});
		//	var grid = this._grid;
		//	indicies.forEach(function( /* Number */ each) {
		//		if(grid.header.getColumn(each)){
		//			grid.header.getColumn(each).visible = true;	
		//		}
		//	});
		//};
		//
		//
		///**
		// * 
		// * @param {cpr.controls.Container} container
		// */
		//globals.makeResponsive = function(container) {
		//	return new RForm(container);
		//};
		//
		//cpr.events.EventBus.INSTANCE.addFilter("init", function(e) {
		//	if (e.control instanceof cpr.core.AppInstance) {
		//		/** @type cpr.core.AppInstance */
		//		var appInstance = e.control;
		//		var vaCtl = appInstance.getContainer().getAllRecursiveChildren(true);
		//		vaCtl.some(function(each){
		//			if (each instanceof cpr.controls.Container) {
		//				if (each.getLayout() instanceof cpr.controls.layouts.FormLayout && each.userAttr("mobile-column-count") != "") {
		//					each.userAttr("responsive-configured", "true");
		//					var rForm = new RForm(each);
		//					rForm.setColumnSettings("mobile", parseInt(each.userAttr(ATTR_MOBILE_COLUMN_COUNT) || "0"));
		//					rForm.setColumnSettings("tablet", parseInt(each.userAttr(ATTR_TABLET_COLUMN_COUNT) || "0"));
		//					rForm.start();
		//				}
		//			}
		//			 if(each instanceof cpr.controls.Grid && each.userAttr(ATTR_HIDE_CELL_INDICIES) != ""){
		//				new RGrid(each);
		//			}	
		//		});
		//		
		//		
		////		var targetGroups = appInstance.getContainer().getAllRecursiveChildren(true).filter(function( /* cpr.controls.UIControl */ each) {
		////			if (each instanceof cpr.controls.Container) {
		////				if (each.getLayout() instanceof cpr.controls.layouts.FormLayout && each.userAttr("mobile-column-count") != "") {
		////					return true;
		////				}
		////			}
		////			return false;
		////		});
		////
		////		targetGroups.forEach(function( /* cpr.controls.Container */ each) {
		////			each.userAttr("responsive-configured", "true");
		////			var rForm = new RForm(each);
		////			rForm.setColumnSettings("mobile", parseInt(each.userAttr(ATTR_MOBILE_COLUMN_COUNT) || "0"));
		////			rForm.setColumnSettings("tablet", parseInt(each.userAttr(ATTR_TABLET_COLUMN_COUNT) || "0"));
		////			rForm.start();
		////		});
		//		
		////		appInstance.getContainer().getAllRecursiveChildren(true).filter(function( /* cpr.controls.UIControl */ each) {
		////			return each instanceof cpr.controls.Grid && each.userAttr(ATTR_HIDE_CELL_INDICIES) != "";
		////		}).forEach(function(grid) {
		////			new RGrid(grid);
		////		});
		//		
		//	}
		//});
	});
})();
/// end - 202106/testF/responsiveForm
/// start - 202107/checkGrpResize
/*
 * Module URI: 202107/checkGrpResize
 * SRC: 202107/checkGrpResize.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202107/checkGrpResize", function(exports, globals, module){
		///************************************************
		// * checkGrpResize.module.js
		// * Created at 2021. 7. 26. 오후 4:41:15.
		// *
		// * @author HANS
		// ************************************************/
		//
		//
		//
		//
		//
		///**
		// * 
		// * @param {cpr.core.AppInstance} poAppIns
		// */
		//globals.CheckResponsiveModule = function(poAppIns){
		//	
		//	return new resizeMod(poAppIns);
		//}
		//
		///**
		// * 
		// * @param {cpr.core.AppInstance} poAppIns
		// */
		//var resizeMod = function(poAppIns){
		//		var vcContainer = poAppIns.getContainer();
		//	
		//	/** @type cpr.controls.CheckBoxGroup */
		//	var vaChild = vcContainer.getAllRecursiveChildren().filter(function(each){
		//		return each instanceof cpr.controls.CheckBoxGroup;
		//	}).filter(function(each){
		//		
		//		
		//		if(each.userAttr("ignoreResize") == ""){
		//			
		//			
		//			var voConstraint = each.getParent().getConstraint(each);
		//			var vaConstKey = Object.keys(voConstraint);
		//			if(vaConstKey.indexOf("autoSize") != -1 || vaConstKey.indexOf("rowIndex") != -1) {
		//				
		//				return each;
		//			}
		//		}
		//	});
		//	this.checkGrps = vaChild;
		//	var that = this;
		//	cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function(){
		//		CheckResizer.call(that);
		//	});
		//	this.starting = function() {
		//
		//		var eventListener = CheckResizer.bind(this);
		//		window.addEventListener("resize", eventListener);
		//		
		//		poAppIns.addEventListener("before-unload", function(){
		//			window.removeEventListener("resize", eventListener);
		//		});
		//		
		//	}
		//}
		//
		//function CheckResizer(){
		//	var vaCheckGrps = this.checkGrps;
		//	
		//	vaCheckGrps.forEach(function(each){
		//		
		//		var cbgMinWidth = Number(each.userAttr("min-item-width"));
		//			var rec = each.getActualRect().width;
		//			var colCnt = Math.floor(rec/cbgMinWidth);
		//			if(colCnt < 1) colCnt =1;
		//			
		//			if(each.colCount != colCnt) {
		//				each.colCount = colCnt;
		//			}
		//	});
		//}
	});
})();
/// end - 202107/checkGrpResize
/// start - 202108/checkGrpResize
/*
 * Module URI: 202108/checkGrpResize
 * SRC: 202108/checkGrpResize.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202108/checkGrpResize", function(exports, globals, module){
		/************************************************
		 * checkGrpResize.module.js
		 * Created at 2021. 7. 26. 오후 4:41:15.
		 *
		 * @author HANS
		 ************************************************/
		
		
		
		var attributeNm = "usr-id"
		
		/**
		 * 체크박스를 반응형으로 colCount를 바꾸는 객체 리턴
		 * @param {cpr.core.AppInstance} poAppIns
		 */
		globals.CheckResponsiveModule = function(poAppIns){
			
			return new resizeMod(poAppIns);
		}
		
		/**
		 * 화면상에 있는 체크박스그룹의 fixedWidth에 NumberString이 들어가있는 체크박스인 경우, 해당 컨트롤의 colCount를 수정합니다.
		 * @param {cpr.core.AppInstance} poAppIns
		 */
		var resizeMod = function(poAppIns){
			var that = this;
			cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function(){
				var vcContainer = poAppIns.getContainer();
			
			/** @type cpr.controls.CheckBoxGroup[] */
			var vaChild = vcContainer.getAllRecursiveChildren().filter(function(each){
				if(each instanceof cpr.controls.CheckBoxGroup && typeof each.fixedWidth != "boolean"){
					if(each.userAttr("ignoreResize")==""){
						
						return each;
					}
				}
			});
			
			vaChild.forEach(function(each){
				
				each.htmlAttr(attributeNm,each.uuid);
				
				
				cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function(){
					var findExpress = "*[data-usr-" + attributeNm + "='" + each.uuid + "']";
					var dom = document.querySelector(findExpress);
					var checkBox = dom.querySelector(".cl-checkbox");
					
					var regexp = /[^0-9]/g;
					var paddingLeft = getComputedStyle(checkBox).paddingLeft.replace(regexp, "");
					var paddingRight = getComputedStyle(checkBox).paddingRight.replace(regexp, "");
					var vnPadding= Number(paddingLeft) + Number(paddingRight);
					each.userData("paddingNum",vnPadding)
				});
			});
			that.checkGrps = vaChild;
			
			cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function(){
				CheckResizer.call(that);
			});
			
				
			});
			/**
			 * start를 하면 윈도우 resize 시, colCount를 계산하는 이벤트 리스너를 추가합니다.
			 */
			this.start = function() {
		
				var eventListener = CheckResizer.bind(this);
				window.addEventListener("resize", eventListener);
				
				poAppIns.addEventListener("before-unload", function(){
					window.removeEventListener("resize", eventListener);
				});
				
			}
		}
		
		/**
		 * padding과 fixedWidth를 사용하여 전체 체크박스그룹크기를 나누어 colCount를 지정하는 함수
		 */
		function CheckResizer(){
			/** @type cpr.controls.CheckBoxGroup[] */
			var vaCheckGrps = this.checkGrps;
			
			vaCheckGrps.forEach(function(each){
				
				var vnPadding = each.userData("paddingNum");
				var cbgMinWidth = Number(each.fixedWidth) + vnPadding;
					var rec = each.getActualRect().width;
					var colCnt = Math.floor(rec/cbgMinWidth);
					if(colCnt < 1) colCnt =1;
					
					if(each.colCount != colCnt) {
						each.colCount = colCnt;
					}
			});
		}
	});
})();
/// end - 202108/checkGrpResize
/// start - 202108/comboBoxListPopup
/*
 * Module URI: 202108/comboBoxListPopup
 * SRC: 202108/comboBoxListPopup.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202108/comboBoxListPopup", function(exports, globals, module){
		/************************************************
		 * ComboBoxListPopup.module.js
		 * Created at 2020. 1. 23. 오전 10:27:59.
		 *
		 * Version 1.1
		 * Updated Date : 2021-04-21
		 * 
		 * @author daye
		 ************************************************/
		
		/*
		 * 본 모듈은 콤보박스 리스트가 특정 개수 이상일 경우 팝업으로 열어 확인 및 선택 할 수 있는 모듈입니다.
		 * 그룹을 제외한 컨트롤에 대해 클릭할 경우 팝업을 띄울 수 있습니다. 대상콤보박스는 fieldLabel에 작성합니다.
		 *  
		 * [fieldLabel 작성법]
		 * - 콤보박스의 fieldLabel을 팝업창의 헤더타이틀로 사용됩니다.
		 * - 콤보박스 이외의 다른 컨트롤의 fieldLabel은 타겟 콤보박스 id 를 작성합니다.
		 * 
		 * [확인사항]
		 * 콤보박스에 바인딩 되어있는 데이터셋의 컬럼은 label, value로 작성
		 * 그리드의 콤보박스는 선택행이 있는 경우에만 확인 가능
		 */
		
		cpr.expression.ExpressionEngine.INSTANCE.registerFunction("getHans", function(ps){
			
			if(ps == "aa") {
				
				return true;
			} else {
				return false;
			}
		});
		/************************************************
		 * 사용가능 API
		 ************************************************/
		/**
		 * 모듈 사용 여부
		 * 값이 true일 경우에만 모듈을 사용한다.
		 * @type {Boolean}
		 */
		var mbCreateApp = true; 
		
		/**
		 * 모바일 전용 여부
		 *	true 일경우에 팝업이 화면 아래에 위치합니다.
		 * @type {Boolean}
		 */
		var mbMobile = true;
		
		/**
		 * 라디오버튼 (or 체크박스그룹) 의 아이템 고정너비
		 * 특정 너비를 설정하기 위해서는 넘버값을 설정하세요.
		 * 
		 * @type {Boolean|Number}
		 */
		var mnFixedWidth = true;
		
		/**
		 * 셀렉션 계열 컨트롤 [선택] 아이템 추가여부
		 * @type {Boolean}
		 */
		var mbInsertBlank = false; 
		
		/**
		 * 사용자 속성
		 * @type {String}
		 */
		var ATTR_COMBO_POP = "combo-pop";
		
		/**
		 * 사용자 속성
		 * @type {String}
		 */
		var ATTR_MOBILE_ONLY = "mobile-only";
		
		/**
		 * 다이얼로그 배경 스타일 클래스
		 * @type {String}
		 */
		var msDialogOverlayCls = "cl-overlay";
		
		/**
		 * 다이얼로그 스타일
		 * @type {String}
		 */
		var msDialogCls = "modal-picker";
		
		
		/**
		 * 2021-07-23 조한진 추가
		 * 다이얼로그 컨텐츠 폼레이아웃 클래스명
		 */
		var msFormCls = "picker-body";
		
		/**
		 * 2021-07-23 조한진 추가
		 * 다이얼로그 컨텐츠 라디오버튼 버티컬레이아웃 클래스명
		 */
		var msSelectFormCls = "border-top";
		/**
		 * 라디오버튼 (or 체크박스그룹) 의 스타일 클래스
		 * @type {String}
		 */
		var msSelectCls = "";
		
		/**
		 * 라디오버튼 (or 체크박스그룹) 아이템의 스타일 클래스
		 * @type {String}
		 */
		var msSelectItemCls = "";
		
		/**
		 * 다이얼로그의 [확인] 버튼 스타일 클래스
		 * @deprecated
		 * @type {String}
		 */
		var msBtnConfirmCls = "btn-primary rounded-0";
		
		/**
		 * 폼레이아웃 spacing
		 * @type {Number}
		 */
		var mnFormSpacing = 0;
		
		/**
		 * [확인] 버튼 높이
		 * @type {Number}
		 */
		var mnConfirmBtnHgt = 47;
		
		/**
		 * 모바일 전용 콤보박스 팝업에서 보여지는 최대 아이템 개수
		 * 적용화면사이즈 : tablet, mobile
		 * @type {Number}
		 */
		var mnMobileList = 6;
		
		/**
		 * 팝업을 띄울 콤보박스아이템 개수
		 * 적용화면사이즈 : default
		 * @type {Number}
		 */
		var mnDftItemList = 7; 
		
		/**
		 * 라디오버튼(or 체크박스그룹) 이 한 줄에 보여질 아이템 수
		 * 적용화면사이즈 : default
		 * @type {Number}
		 */
		var mnDftColCount = 6;
		
		/**
		 * 팝업 constraint 
		 * 적용화면사이즈 : default
		 */
		var moDftPopSize = {
			width: 900,
			height: 600
		};
		
		/**
		 * 팝업을 띄울 콤보박스아이템 개수
		 * 적용화면사이즈 : tablet, mobile
		 * @type {Number}
		 */
		var mnMblItemList = 0;
		
		/**
		 * 라디오버튼(or 체크박스그룹) 이 한 줄에 보여질 아이템 수
		 * 적용화면사이즈 : tablet, mobile
		 * @type {Number}
		 */
		var mnMblColCount = 1;
		
		/**
		 * 팝업 constraint 
		 * 적용화면사이즈 : tablet, mobile
		 */
		var moMblPopSize= {
			left : 0,
			right : 0,
			bottom : -100,
			height : 0
		};
		
		/**
		 * 팝업 이름
		 * @type {String}
		 */
		var msDialogName = "dialogName";
		
		/**
		 * 다이얼로그 헤더 타이틀
		 * @type {String}
		 */
		var msTempHeaderTitle = "다이얼로그 팝업";
		
		/**
		 * box-shadow 스타일
		 */
		var moBoxShadow = {
			top : "inset 0px -11px 20px -1px rgba(0,0,0,0.16)",
			bottom : "inset 11px 0px 20px -1px rgba(0,0,0,0.16)",
			middle : "inset 0px -11px 20px -1px rgba(0,0,0,0.16),  inset 11px 0px 20px -1px rgba(0,0,0,0.16)"
		}
		
		/**
		 * up, down 버튼 클래스
		 * @type {String}
		 */
		var msFloatBtnCls = "rounded-circle";
		
		/**
		 * 모바일 팝업 최대높이
		 * @type {Number}
		 */
		var mnMaxHeight = innerHeight*0.8;
		
		/**
		 * 스크롤 버튼 표시 여부 
		 * 적용화면사이즈 : tablet, mobile
		 * 
		 * @type {Boolean}
		 */
		var mbScrollButton = false;
		
		/**
		 * 스크롤 스타일(box-shadow) 표시 여부 
		 * 적용화면사이즈 : tablet, mobile
		 * @type {Boolean}
		 */
		var mbScrollStyle = false;
		
		/************************************************
		 * 내부 시스템 멤버변수 (변경X)
		 ************************************************/
		/**
		 * 앱 ID
		 * @type {String}
		 */
		var msAppId = null; 
		
		/**
		 * 앱 인스턴스
		 * @type {cpr.core.AppInstance}
		 */
		var moAppIns = null;
		
		/**
		 * 타겟 콤보박스
		 * @type {cpr.controls.ComboBox}
		 */
		var mcComboBox = null;
		
		/**
		 * 팝업이 띄워졌는지 여부
		 * @type {Boolean}
		 */
		var mbPop = false;
		
		/**
		 * 팝업을 띄울 콤보박스아이템 개수
		 * @type {Number}
		 */
		var mnList;
		
		/**
		 * 라디오버튼(or 체크박스그룹) 이 한 줄에 보여질 아이템 수
		 * @type {Number}
		 */
		var mnColCount;
		
		/**
		 * 팝업 constraint 
		 */
		var moPopSize;
		
		/************************************************
		 * 이벤트 버스 (load)
		 ************************************************/
		
		if(mbCreateApp) cpr.events.EventBus.INSTANCE.addFilter("click", fn_click);
		if(mbMobile) cpr.events.EventBus.INSTANCE.addFilter("screen-change", fn_screen_change);
		
		function fn_click (e) {
			var control = e.control;
			moAppIns = control.getAppInstance();
		
			// 그룹 제외
			if (control.type == "container" || moAppIns.app == null) {
				return;
			}
			
			// 팝업이 띄워져 있지 않은경우에만 팝업을 띄움
			if(mbPop == false) {
				
				// 그리드 click 시, 선택행이 없을 경우 팝업을 띄우지 않음
				if(control.type == "grid") {
					if(control.getSelectedRowIndex() == -1) {
						return;
					}
				}
				
				_setMobile(mbMobile, mbScrollButton, mbScrollStyle);
				
				/** @type cpr.controls.ComboBox */
				var vcTargetCombo = null;
				if(control.type == "combobox") {
					vcTargetCombo = control;
				} else {
					var vsTargetCmbId = _getTargetComboId(control);
					vcTargetCombo = moAppIns.lookup(vsTargetCmbId);
				}
				
				if((vcTargetCombo != null && vcTargetCombo.type == "combobox")) {
					if(vcTargetCombo.userAttr(ATTR_COMBO_POP) == "true") {
						
						/*
						 * 모바일에서만 해당 기능을 사용 확인(mobile-only = true)
						 * default : 기본 콤보박스 사용
						 * tablet, mobile : 콤보팝업 사용
						 */
						var vsTargetScreen = moAppIns.targetScreen.name;
						if(vsTargetScreen == "default" && vcTargetCombo.userAttr(ATTR_MOBILE_ONLY) == "true") {
							return;
						}
						
						control.preventInput = true;
					
						// 콤보박스 아이템 개수보다 mnCmbItem이 많으면 팝업 띄우지 않음
						var vnItemCnt = vcTargetCombo.getItemCount();
						 if(!mbMobile && vnItemCnt <= mnList) {
							
							// 그리드 안의 콤보박스는 편집행일 경우에만 open 할 수 있음
							if(vcTargetCombo.getParent().type == "grid") {
		
								/** @type cpr.controls.Grid */
								var vcGrid = vcTargetCombo.getParent();
								var vnSelectedRowIndex = vcGrid.getSelectedRowIndex();
								vcGrid.setEditRowIndex(vnSelectedRowIndex);
							}
							
							// FIXME 그리드안의 콤보박스가 팝업이 아닌 open 될경우 아래 코드 주석을 해제하십시오.
		//					cpr.core.DeferredUpdateManager.INSTANCE.update();
							control.preventInput = false;
							vcTargetCombo.open();
							vcTargetCombo.focus();
							return;
						}
						
						cpr.core.DeferredUpdateManager.INSTANCE.update();
						_floatPop(control);
					}
					
				}
			}
		}
		
		/**
		 * 
		 * @param {cpr.events.CScreenChangeEvent} e
		 */
		function fn_screen_change (e) {
			var screen = e.screen.name;
			
			if(screen == "default") {
				_setMobile(false);
			} else {
				_setMobile(true, mbScrollButton, mbScrollStyle);
			}
		}
		
		/**
		 * 
		 * @param {cpr.controls.ComboBox} pcCtrl
		 */
		function _createComboInsteadUDC(pcCtrl){
			var vcSelection = null;
			var vbMultiple = pcCtrl.multiple;
			var voSelected = pcCtrl.values;
						if(vbMultiple == true) {
							vcSelection = new cpr.controls.CheckBoxGroup(); // 다중선택
						} else {
							vcSelection = new cpr.controls.RadioButton(); // 단일선택
						}
						
						// 3. 셀렉션 계열 컨트롤 속성 및 스타일 설정
						/*
						 * 아래 기능은 2021-01-29 릴리즈 버전 이후부터 사용 가능합니다
						 * 		- 라디오버튼(or 체크박스그룹) 아이템의 너비를 고정너비로 설정합니다.
						 * 		- 각 아이템의 텍스트에 말줄임 스타일을 적용하기 위해서 아이템을 반드시 고정너비로 설정해야 합니다.
						 */
						vcSelection.fixedWidth = mnFixedWidth;
						
						
						// TODO 한 행에 보여줄 아이템 개수
						vcSelection.colCount = mnColCount;
						
						//2021-07-23 조한진 추가. 아이템이  7개를 넘어갔을 떄 한줄에 아이템이 2개 보여야함
						if(mcComboBox.getItemCount() > 6) {
							vcSelection.colCount = 2;
						}
						// TODO 컨트롤의 스타일 변경
						// 1) 컨트롤 스타일
						vcSelection.style.addClass(msSelectCls);
		
						// 2) 컨트롤 아이템 스타일
						vcSelection.style.item.addClass(msSelectItemCls);
						
						// 4. 데이터셋 생성
						var vcComboDataSet = new cpr.data.DataSet();
						var voRow = [];
						mcComboBox.getItems().forEach(function(each){
							voRow.push({
								"label": each.label,
								"value": each.value
							});
						});
						vcComboDataSet.parseData({
							"columns" : [
								{"name": "label"},
								{"name": "value"}
							],
							"rows" : voRow
						});
						
						// 5. 라디오버튼일 때, 공백 아이템 추가
						if(mbInsertBlank && vcSelection.type == "radiobutton" && mcComboBox.getItemCount() > 0) { 
							vcComboDataSet.insertRowData(0, false, {
								"label" : "선택취소",
								"value" : ""
							})
						}				
						
						// 6. 셀렉션 컨트롤에 데이터셋 바인딩
						vcSelection.setItemSet(vcComboDataSet, {
							label : "label",
							value : "value",
							tooltip : "label"
						});
							
						// 7. 기존의 선택했던 값이 존재할 경우 값 설정
						if(voSelected.length != 0) {
							vcSelection.values = voSelected;
						}
		//				vcSelection.addEventListener("selection-change", function(e){
		//					newApp.close(e.control.values);
		//				});
		}
		
		/**
		 * 새로운 앱인스턴스 생성
		 */
		function _createApp() {
			
			if(moAppIns == null) {
				return;
			}
		
			msAppId = moAppIns.app.id + "ListPop";
			var newApp = new cpr.core.App(msAppId, {
				
				onPrepare: function(loader){
				},
				
				onCreate: function(/* cpr.core.AppInstance */ newApp, exports){
					var vaRows = (function(pnHeight){
						var rows = [];
						rows.push(pnHeight + "px");
						rows.push("1fr");
						return rows;
					})(mnConfirmBtnHgt)
					
					// 루트 컨테이너 레이아웃 설정 (폼레이아웃)
					var container = newApp.getContainer();
					var voFormlayout = new cpr.controls.layouts.FormLayout();
					voFormlayout.setRows(vaRows);
					voFormlayout.setColumns(["1fr"]);
					voFormlayout.verticalSpacing = mnFormSpacing + "px";
					container.setLayout(voFormlayout);
					container.style.setClasses(msFormCls);
					// 루트 앱인스턴스 로드 이벤트 리스너
					newApp.addEventListener("load", function(e) {	
						
						var vcCtrl = newApp.getHostProperty("initValue");
						var voSelected = []; // 이전에 선택한 값
						moAppIns = vcCtrl.getAppInstance();
						
						// vsInitValue에 해당하는 타겟 콤보박스 저장
						mcComboBox = moAppIns.getContainer().getAllRecursiveChildren().map(function(each){
							var vcCombo = null;
							if(vcCtrl.type == "combobox" && each == vcCtrl) {
								vcCombo = each;
								voSelected = each.values;
							} else {
								var vsTargetId = vcCtrl.fieldLabel;
								if(each.id == vsTargetId && each.type == "combobox") {
									vcCombo = each;
									voSelected = each.values;
								}
							}
							
							// 그리드에 포함되어있는 콤보박스일 경우
							if(vcCombo && vcCombo.getParent().type == "grid") {
								/** @type cpr.controls.Grid */
								var vcGrid = each.getParent();
								var vnSelectedIndex = vcGrid.getSelectedRowIndex();
								
								for(var idx = 0; idx < vcGrid.detail.cellCount; idx++) {
									if(vcGrid.detail.getControl(idx) == each) {
										voSelected = [vcGrid.getCellValue(vnSelectedIndex, idx)];
									}
								}
							}
							
							return vcCombo;
						}).filter(function(each){
							if(each) return each;
						})[0];
						
						if(mcComboBox == null) return;
						
						var vbMultiple = mcComboBox.multiple; // 콤보박스의 multiple 속성값
						
						/*
						 * 2021-07-23 조한진 추가 다이얼로그 헤더 타이틀 대신, 다이얼로그 헤더 하단에 타이틀 구획 추가
						 */
						var vcTitleGroup = new cpr.controls.Container();
						var voTitleVerticalLayout = new cpr.controls.layouts.VerticalLayout();
						voTitleVerticalLayout.leftMargin = 24;
						voTitleVerticalLayout.topMargin = 0;
						voTitleVerticalLayout.rightMargin = 0;
						voTitleVerticalLayout.bottomMargin = 0;
						voTitleVerticalLayout.spacing = 0;
						vcTitleGroup.setLayout(voTitleVerticalLayout);
						
						var vcOptTitle = new cpr.controls.Output();
						vcOptTitle.style.setClasses(["fs-base", "fw-bold"]);
						vcOptTitle.value = mcComboBox.fieldLabel;
						vcTitleGroup.addChild(vcOptTitle, {
							"width" : "100px",
							"height": "24px",
							"autoSize":"height"
						});
						
						container.addChild(vcTitleGroup, {
							rowIndex : 0,
							colIndex : 0
						});
						/*
						 * ---------------------------- start ----------------------------
						 * 드롭다운 리스트 아이템을 보여주기 위함 컨트롤 배치
						 */
						// 1. 셀렉션 계열 컨트롤을 감싸는 그룹 생성(버티컬 레이아웃)
						var vcGroup = new cpr.controls.Container();
						var voVerticalLayout = new cpr.controls.layouts.VerticalLayout();
						vcGroup.setLayout(voVerticalLayout);
						vcGroup.style.setClasses(msSelectFormCls);
						// 2. 셀렉션 계열 컨트롤 생성 (라디오, 체크박스그룹)
						var vcSelection = null;
						if(vbMultiple == true) {
							vcSelection = new cpr.controls.CheckBoxGroup(); // 다중선택
						} else {
							vcSelection = new cpr.controls.RadioButton(); // 단일선택
						}
						
						// 3. 셀렉션 계열 컨트롤 속성 및 스타일 설정
						/*
						 * 아래 기능은 2021-01-29 릴리즈 버전 이후부터 사용 가능합니다
						 * 		- 라디오버튼(or 체크박스그룹) 아이템의 너비를 고정너비로 설정합니다.
						 * 		- 각 아이템의 텍스트에 말줄임 스타일을 적용하기 위해서 아이템을 반드시 고정너비로 설정해야 합니다.
						 */
						vcSelection.fixedWidth = mnFixedWidth;
						
						
						// TODO 한 행에 보여줄 아이템 개수
						vcSelection.colCount = mnColCount;
						
						//2021-07-23 조한진 추가. 아이템이  7개를 넘어갔을 떄 한줄에 아이템이 2개 보여야함
						if(mcComboBox.getItemCount() > 6) {
							vcSelection.colCount = 2;
						}
						// TODO 컨트롤의 스타일 변경
						// 1) 컨트롤 스타일
						vcSelection.style.addClass(msSelectCls);
		
						// 2) 컨트롤 아이템 스타일
						vcSelection.style.item.addClass(msSelectItemCls);
						
						// 4. 데이터셋 생성
						var vcComboDataSet = new cpr.data.DataSet();
						var voRow = [];
						mcComboBox.getItems().forEach(function(each){
							voRow.push({
								"label": each.label,
								"value": each.value
							});
						});
						vcComboDataSet.parseData({
							"columns" : [
								{"name": "label"},
								{"name": "value"}
							],
							"rows" : voRow
						});
						
						// 5. 라디오버튼일 때, 공백 아이템 추가
						if(mbInsertBlank && vcSelection.type == "radiobutton" && mcComboBox.getItemCount() > 0) { 
							vcComboDataSet.insertRowData(0, false, {
								"label" : "선택취소",
								"value" : ""
							})
						}				
						
						// 6. 셀렉션 컨트롤에 데이터셋 바인딩
						vcSelection.setItemSet(vcComboDataSet, {
							label : "label",
							value : "value",
							tooltip : "label"
						});
							
						// 7. 기존의 선택했던 값이 존재할 경우 값 설정
						if(voSelected.length != 0) {
							vcSelection.values = voSelected;
						}
		//				vcSelection.addEventListener("selection-change", function(e){
		//					newApp.close(e.control.values);
		//				});
						// 8. 컨트롤 추가
						vcGroup.addChild(vcSelection, {
							autoSize : "height"
						});
						container.addChild(vcGroup, {
							rowIndex : 1,
							colIndex : 0
						});
						/*
						 * 드롭다운 리스트 아이템을 보여주기 위함 컨트롤 배치
						 * ---------------------------- end ----------------------------
						 */
						//2021-07-23 조한진 삭제. 확인버튼 제거
						// [확인] 버튼 컨트롤
		//				var vcButton = new cpr.controls.Button();
		//				vcButton.value = "확인";
		//				vcButton.style.addClass(msBtnConfirmCls); // 버튼 style 적용
		//				vcButton.addEventListener("click", function(e){
		//					// 콤보박스 아이템 선택 및 팝업닫힘
		//					newApp.close(vcSelection.values);
		//				});
		//				container.addChild(vcButton, {
		//					rowIndex : 1,
		//					colIndex : 0
		//				})
						
						cpr.core.DeferredUpdateManager.INSTANCE.update();
						
						/*
						 * 팝업이 열린 후 팝업 사이즈 재설정
						 * (모바일 전용 한정) 
						 */
						var dialog = newApp.getHost();
						if(dialog && dialog instanceof cpr.controls.Dialog) {
							if(mbMobile) {;
								var elDialog = document.getElementById("uuid-"+dialog.uuid).querySelector(".cl-dialog-header");
								var dialogHeaderHgt = getComputedStyle(elDialog).height; // 다이얼로그 헤더 높이
								
								var vnViewItemCount = vcSelection.getItemCount();
								var vnItemCnt = vnViewItemCount <= mnMobileList ? vnViewItemCount : mnMobileList; // 다이얼로그에 최대 보여줄 아이템 개수check
								var vnItemBorders = vnViewItemCount <= mnMobileList ? vnViewItemCount : 0; // 스크롤이 없는 상태에서 각 아이템 border 사이즈 추가
								
								var elSelectionItem = document.getElementById("uuid-"+vcSelection.uuid);
								var vnSelectionItemHgt = 0; // 셀력션 아이템의 높이
								if(vnViewItemCount > 0) {
									if(vbMultiple) {
										// 멀티셀렉션
										vnSelectionItemHgt = getComputedStyle(elSelectionItem.querySelector(".cl-checkbox")).height;
									} else {
										// 단일셀렉션
										vnSelectionItemHgt = getComputedStyle(elSelectionItem.querySelector(".cl-radiobutton-item")).height;
									}
								}
								
								/*
								 * 최종 다이얼로그 높이
								 * (보여지는 아이템 개수 * 각 아이템 높이) + 다이얼로그 헤더 높이 + [확인버튼]높이 + 보여지는 아이템 보더개수 + 폼레이아웃 스페이싱
								 */
								var vnTotalDialogHgt = (vnItemCnt * parseInt(vnSelectionItemHgt)) + parseInt(dialogHeaderHgt) + mnConfirmBtnHgt + vnItemBorders + mnFormSpacing;
								
								// 다이얼로그 최대 높이 = 화면높이*0.8
								if(mnMaxHeight  <= vnTotalDialogHgt) {
									vnTotalDialogHgt = mnMaxHeight ;
								}
								
								// 스크롤이 있는 경우 버튼 생성
								var vnRealSelectionHeight = vcSelection.getActualRect().height; // 실제 전체  selection컨트롤의 rect
								var vnSelectionViewHeight = vnTotalDialogHgt - (parseInt(dialogHeaderHgt) + mnConfirmBtnHgt); //  selection컨트롤의 viewPort
								if(vnRealSelectionHeight > vnSelectionViewHeight) {
									// 다이얼로그 최소 높이 
									var vnMin = (parseInt(dialogHeaderHgt) + mnConfirmBtnHgt) + 90;
									if(vnMin >= vnTotalDialogHgt) {
										var maxHeight = (parseInt(vnSelectionItemHgt) * vcSelection.getItemCount()) + parseInt(dialogHeaderHgt) + mnConfirmBtnHgt + vnItemBorders + mnFormSpacing;
										vnTotalDialogHgt = vnMin > maxHeight? maxHeight : vnMin;
									}
								}
														
								var vnSelectionViewHeight2 = vnTotalDialogHgt - (parseInt(dialogHeaderHgt) + mnConfirmBtnHgt); // 변경된 vnTotalDialogHgt 로 다시 계산한 selection컨트롤의 viewPort
								if(mbScrollButton && vnRealSelectionHeight > vnSelectionViewHeight2) { // 스크롤이 있는 경우에만
									// 1) 최초 box-shadow 설정
									vcGroup.style.css({
										"box-shadow" : moBoxShadow.top
									})
									
									// 2) 버튼 추가 
									// TODO 디자인 수정
									var vcUpBtn = new cpr.controls.Button("btnUp");
									vcUpBtn.value = "▲";
									vcUpBtn.style.addClass(msFloatBtnCls);
									vcUpBtn.enabled = false;
									vcUpBtn.addEventListener("click", function(e){
										vcGroup.scrollTo(0, 0, 0.3, cpr.animation.TimingFunction.EASE_IN_OUT_CUBIC);
									});
									dialog.getEmbeddedAppInstance().floatControl(vcUpBtn, {
										top : "10px",
										right : "20px",
										width : "30px",
										height : "30px",
									});
									
									var vcDownBtn = new cpr.controls.Button("btnDown");
									vcDownBtn.value = "▼";
									vcDownBtn.style.addClass(msFloatBtnCls);
									vcDownBtn.addEventListener("click", function(e){
										vcGroup.scrollTo(0, vnRealSelectionHeight, 0.3, cpr.animation.TimingFunction.EASE_IN_OUT_CUBIC);
									});
									
									dialog.getEmbeddedAppInstance().floatControl(vcDownBtn, {
										top : (vnSelectionViewHeight2- 40) + "px",
										right : "20px",
										width : "30px",
										height : "30px",
									});
								}
								
								vcGroup.addEventListener("scroll", function(e){
									var voViewportRect = e.control.getViewPortRect();
									var top = voViewportRect.top;
									var bottom = voViewportRect.bottom;
									
									if(mbScrollButton) {
										if(top == 0) {
											// 가장 위
											vcUpBtn.enabled = false;
											vcDownBtn.enabled = true;
										} else if(bottom == vnRealSelectionHeight) {
											// 가장 아래
											vcUpBtn.enabled = true;
											vcDownBtn.enabled = false;
										} else {
											// 중간
											vcUpBtn.enabled = true;
											vcDownBtn.enabled = true;
										}
									}
									
									if(mbScrollStyle) {
										if(top == 0) {
											// 가장 위
											vcGroup.style.css({
												"box-shadow" : moBoxShadow.top
											})
										} else if(bottom == vnRealSelectionHeight) {
											// 가장 아래
											vcGroup.style.css({
												"box-shadow" : moBoxShadow.bottom
											})
										} else {
											// 중간
											vcGroup.style.css({
												"box-shadow" : moBoxShadow.middle
											})
										}
									}
								});
								
								dialog.style.animateTo({
									"transform":"translateY("+moMblPopSize.bottom+"px)",
									"max-height" : vnTotalDialogHgt + "px",
								}, 0.3, cpr.animation.TimingFunction.EASE_IN_OUT_CUBIC);
								
								cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function() {
									var dialogManager = dialog.getAppInstance().dialogManager;
									var oldConstraint = dialogManager.getConstraintByName(msDialogName);
									var newConstraint = oldConstraint;
									newConstraint.height = vnTotalDialogHgt;
									dialogManager.replaceConstraintByName(msDialogName, newConstraint);
								});
							}
						}
					});
				}
			});
			
			// 앱 생성
			cpr.core.Platform.INSTANCE.register(newApp);
			
			return newApp;
		}
		
		
		/**
		 * 콤보박스 리스트가 open되었을 경우 방지
		 * 아이템 개수가 mnCmbItem보다 많은 경우에만 팝업으로 띄운다.
		 * @param {Event} e
		 */
		cpr.events.EventBus.INSTANCE.addFilter("open", function(e){
			var control = e.control;
			
			if(control.type == "combobox" && control.userAttr(ATTR_COMBO_POP) == "true") {
				
				/*
				 * 모바일에서만 해당 기능을 사용 확인(mobile-only = true)
				 * default : 기본 콤보박스 사용
				 * tablet, mobile : 콤보팝업 사용
				 */
				var voAppInstance = control.getAppInstance();
				if(voAppInstance && voAppInstance instanceof cpr.core.AppInstance) {
					var vsTargetScreen = voAppInstance.targetScreen.name;
			 		if(vsTargetScreen == "default" && control.userAttr(ATTR_MOBILE_ONLY) == "true") return;
				}
				
				var vnItemCnt = control.getItemCount();
				if(vnItemCnt > mnList) {
					e.preventDefault();
				}
			}
		});
		
		
		/**
		 * 타겟 콤보박스 확인
		 *  fieldLabel이 있는 경우 fieldLabel 반환
		 *  fieldLabel이 없는 경우 컨트롤 id 반환
		 * @param {cpr.controls.UIControl} pcControl
		 */
		function _getTargetComboId (pcControl) {
			
			var vsLabel = null;
			
			if(pcControl.fieldLabel != null && pcControl.fieldLabel != "") {
				vsLabel = pcControl.fieldLabel;
			} else {
				vsLabel = pcControl.id;
			}
			
			return vsLabel;
		}
		
		
		/**
		 * 팝업 띄우기
		 * @param {cpr.controls.UIControl} pcControl
		 */
		function _floatPop (pcControl) {
			
			mbPop = true;
			
			var voDialogApp = _createApp();
			
			/** @type cpr.core.AppInstance */
			var voRootAppIns = moAppIns.getRootAppInstance();
			
			var vcTargetCtrl = null;
			var vsHeaderTitle = null;
			
			if(pcControl.type == "combobox") {
				vcTargetCtrl = pcControl;
				var control = pcControl.getAppInstance().lookup(pcControl.fieldLabel);
				if(control) {
					vsHeaderTitle = control.value;
				} else {
					vsHeaderTitle = pcControl.fieldLabel;
				}
			} else {
				vcTargetCtrl = moAppIns.lookup(_getTargetComboId(pcControl));
				var control = pcControl.getAppInstance().lookup(vcTargetCtrl.fieldLabel);
				if(control) {
					vsHeaderTitle = control.value;
				} else {
					vsHeaderTitle = vcTargetCtrl.fieldLabel;
				}
			}
			
			if(vsHeaderTitle == null) {
				vsHeaderTitle = msTempHeaderTitle;
			}
			
			// TODO 다이얼로그 관련 설정 변경
			// 다이얼로그 사이즈 width, height 변경
			voRootAppIns.dialogManager.openDialog(voDialogApp, msDialogName, moPopSize, function(/* cpr.controls.Dialog */ dialog){
				dialog.headerTitle = "";
				dialog.initValue = pcControl;
				dialog.resizable = false;
				dialog.headerMovable = false;
				dialog.headerClose = true;
				
				// 다이얼로그 스타일
				dialog.style.addClass(msDialogCls);
				dialog.style.overlay.addClass(msDialogOverlayCls);
				
				dialog.addEventListener("overlay-click", function(e){
					dialog.close();
				});
				
				dialog.addEventListener("init", function(e){
					dialog.getEmbeddedAppInstance().getContainer().getLayout().scrollable = false;
				});
				
				dialog.addEventListener("transitionend", function(e){
					dialog.getEmbeddedAppInstance().getContainer().getLayout().scrollable = true;
					dialog.redraw();
				});
				
				// TODO 다이얼로그가 닫힐 때 발생하는 이벤트
				dialog.addEventListenerOnce("close", function(e){
					var returnValue = e.control.returnValue ;
					
					// TODO 팝업에서 선택한 값(returnValue) 저장
					if (returnValue) {
						
						// 콤보박스의 상위컨트롤이 그리드인 경우, 그리드 내 콤보박스 셀에 returnValue 저장
						if(vcTargetCtrl.getParent().type == "grid") {
							
							/** @type cpr.controls.Grid */
							var vcGrid = vcTargetCtrl.getParent();
							var vnSelectedRowIndex = vcGrid.getSelectedRowIndex();
				
							var voDetail = vcGrid.detail;
							for(var idx = 0; idx < voDetail.cellCount; idx++) {
								if(voDetail.getControl(idx) ==vcTargetCtrl) {
									vcGrid.setCellValue(vnSelectedRowIndex, idx, returnValue);
								}		
							}
						} else {
							// 콤보박스의 상위컨트롤이 그리드가 아닌경우
							vcTargetCtrl.clearSelection();
		
							for(var idx = 0; idx < returnValue.length; idx++) {
								vcTargetCtrl.selectItemByValue(returnValue[idx]);
							}
						}
					}
					
					mbPop = false;
					cpr.core.Platform.INSTANCE.unregister(dialog.app);
				});
			});
		}
		
		/**
		 * 모바일 버전의 콤보박스 사용 여부
		 * @param {Boolean} pbMobile 모바일 여부(true:모바일/false:데스크탑)
		 * @param {Boolean} pbScrollButton? 모바일버전-스크롤 버튼 사용 여부 (default:false)
		 * @param {Boolean} pbScrollStyle? 모바일버전-스크롤 스타일(box-shadow)사용여부 (default:false)
		 */
		globals.setComboPopMobile = function(pbMobile, pbScrollButton, pbScrollStyle) {
			_setMobile(pbMobile, pbScrollButton, pbScrollStyle);
		}
		
		
		/**
		 * 모바일/데스크탑 기준 size,colcount 설정
		 * @param {Boolean} pbMobile 
		 * @param {Boolean} pbScrollButton?
		 * @param {Boolean} pbScrollStyle?
		 */
		function _setMobile (pbMobile, pbScrollButton, pbScrollStyle) {
			mbMobile = pbMobile;
			
			if(pbMobile) {
				// tablet, mobile 화면일 경우
				mnColCount = mnMblColCount;
				moPopSize = moMblPopSize;
				mnList = mnMblItemList;
				
				if(pbScrollButton != null) {
					mbScrollButton = pbScrollButton;
				}
				
				if(pbScrollStyle != null) {
					mbScrollStyle = pbScrollStyle
				}
			} else {
				// default 화면일 경우
				mnColCount = mnDftColCount;
				moPopSize = moDftPopSize;
				mnList = mnDftItemList;
			}
		}
	});
})();
/// end - 202108/comboBoxListPopup
/// start - 202108/fetch
/*
 * Module URI: 202108/fetch
 * SRC: 202108/fetch.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202108/fetch", function(exports, globals, module){
		/************************************************
		 * fetch.module.js
		 * Created at 2021. 7. 26. 오전 10:56:57.
		 *
		 * @author HANS
		 ************************************************/
		
		/**
		 * 
		 * @param {cpr.core.AppInstance} poAppIns
		 * @param {cpr.controls.UIControl} pcTargetCtrl
		 */
		globals.fetchContainer = function(poAppIns,pcTargetCtrl){
		//	return new FecthModule(poAppIns,pcTargetCtrl);
		
			var vcContainer = poAppIns.getContainer();
			var voLayout = vcContainer.getLayout();
			var knownBottomReached = false;
			
			if(!(voLayout instanceof cpr.controls.layouts.VerticalLayout)) {
				return;
			}
			vcContainer.addEventListener("scroll", function(e){
				
				var viewport = vcContainer.getViewPortRect();
				var loader = vcContainer.getLastChild();
			
			var bottomReached = viewport.intersects(loader.getOffsetRect());
			if (knownBottomReached != bottomReached && bottomReached) {
				
				if (fetchCount >= maxFetchCount) {
					loader.style.animateAndReverse({
						"transform": "scale(1.3)",
						"color": "red"
					}, 0.2);
				} else {
					_fetch();
				}
			}
			knownBottomReached = bottomReached;
			});
		}
		
		
		function _fetch(){
			
		}
		
		
		globals.tempFetchModuler = function(poAppIns,pcTargetCtrl,pnMaxCnt) {
			
			return new FetchModel();
		}
		
		/**
		 * 
		 * @param {cpr.core.AppInstance} poAppIns
		 * @param {cpr.controls.UIControl} pcTargetCtrl
		 * @param {Number} pnMaxCnt
		 */
		var FetchModel = function(poAppIns,pcTargetCtrl,pnMaxCnt){
			this.aps = poAppIns;
			this.reached = false;
			this.copyMod = createCtrlCopyModule();
			this.max = pnMaxCnt;
			
			this.scroll();
		
		}
		
		FetchModel.prototype.scroll = function(){
			
			var vcContainer = this.aps.getContainer();
			var mine = this;
			vcContainer.addEventListener("scroll", function(e){
				var viewport = vcContainer.getViewPortRect();
				var loader = vcContainer.getLastChild();
			
			var bottomReached = viewport.intersects(loader.getOffsetRect());
			if (mine.reached != bottomReached && bottomReached) {
				
				if (fetchCount >= maxFetchCount) {
					loader.style.animateAndReverse({
						"transform": "scale(1.3)",
						"color": "red"
					}, 0.2);
				} else {
					_fetch();
				}
			}
			mine.rec = bottomReached;
			});
		}
	});
})();
/// end - 202108/fetch
/// start - 202108/goodday
/*
 * Module URI: 202108/goodday
 * SRC: 202108/goodday.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202108/goodday", function(exports, globals, module){
		///************************************************
		// * checkGrpResize.module.js
		// * Created at 2021. 7. 26. 오후 4:41:15.
		// *
		// * @author HANS
		// ************************************************/
		//
		//var attributeNm = "user-id";
		//
		//
		//
		///**
		// * 
		// * @param {cpr.core.AppInstance} poAppIns
		// */
		//globals.CheckResponsiveModule = function(poAppIns){
		//	
		//	return new resizeMod(poAppIns);
		//}
		//
		///**
		// * 
		// * @param {cpr.core.AppInstance} poAppIns
		// */
		//var resizeMod = function(poAppIns){
		//		var vcContainer = poAppIns.getContainer();
		//	
		//	/** @type cpr.controls.CheckBoxGroup[] */
		//	var vaChild = vcContainer.getAllRecursiveChildren().filter(function(each){
		//		return each instanceof cpr.controls.CheckBoxGroup;
		//	}).filter(function(each){
		//		
		//		
		//		if(each.userAttr("ignoreResize") == ""){
		//			
		//			
		//			var voConstraint = each.getParent().getConstraint(each);
		//			var vaConstKey = Object.keys(voConstraint);
		//			if(vaConstKey.indexOf("autoSize") != -1 || vaConstKey.indexOf("rowIndex") != -1) {
		//				
		//				return each;
		//			}
		//		}
		//	});
		//	
		//	vaChild.forEach(function(each){
		//		each.htmlAttr(attributeNm,each.uuid);
		//		
		//		
		//		cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function(){
		//			var findExpress = "*[data-usr-" + attributeNm + "='" + each.uuid + "']";
		//			var dom = document.querySelector(findExpress);
		////			each.userData("doom",dom);
		//			var checkBoxs = dom.querySelectorAll(".cl-checkbox");
		//			var itemLen = [];
		//			var width = checkBoxs.item(0).querySelector(".cl-icon-wrapper").offsetWidth;
		//			for(var i=0; i<checkBoxs.length; i++) {
		//				var item = checkBoxs.item(i);
		//				var font = getComputedStyle(item).font;
		//				var label = each.getItem(i).label;
		//				
		//				var vnLength = Math.round(getTextWidth(label, font)/.01 *.01);
		//				itemLen.push(vnLength+width+9);
		//			};
		//			
		//			each.userData("doom", itemLen);
		//			console.log(itemLen);
		//		});
		//	});
		//	
		//	this.checkGrps = vaChild;
		//	var that = this;
		//	cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function(){
		//		CheckResizer.call(that);
		//	});
		//	this.starting = function() {
		//
		//		var eventListener = CheckResizer.bind(this);
		//		window.addEventListener("resize", eventListener);
		//		
		//		poAppIns.addEventListener("before-unload", function(){
		//			window.removeEventListener("resize", eventListener);
		//		});
		//		
		//	}
		//}
		//
		//
		//function CheckResizer(){
		//	/** @type cpr.controls.CheckBoxGroup[] */
		//	var vaCheckGrps = this.checkGrps;
		//	
		//	vaCheckGrps.forEach(function(each){
		//		var dom = each.userData("doom");
		//		
		//		var a = _divider(dom, each.getActualRect().width);
		//		console.log(a);
		//		each.colCount = a.index + 1;
		//	});
		//}
		//function getTextWidth(text, font) {
		//    // re-use canvas object for better performance
		//    var canvas = getTextWidth.canvas || (getTextWidth.canvas = document.createElement("canvas"));
		//    var context = canvas.getContext("2d");
		//    context.font = font;
		//    var metrics = context.measureText(text);
		//    return metrics.width;
		//}
		//
		//function _vouch(array,width){
		//	/** @type Number[] */
		//	var vaArr = array;
		//	/** @type Number */
		//	var vnWidth = width;
		//	var vaHan = [];
		//	var len = vaArr.length;
		//	var isUpper = 0;
		//	
		//	while(len > isUpper){
		//		
		//		var a = _divider(vaArr, vnWidth);
		//		vaArr = a.remain;
		//		isUpper += a.index;
		//		vaHan.push(a.index);
		//	}
		//	
		//}
		//
		//function _divider(array, width) {
		//	/** @type Number[] */
		//	var vaArr = array;
		//	/** @type Number */
		//	var vnWidth = width;
		//	var sum = 0;
		//	var index = 0;
		//	for(var i=0; i < vaArr.length; i++){
		//		index = i-1;
		//			sum += vaArr[i];
		//		if(vnWidth<= sum){
		//			break;		
		//		}
		//	}
		//	var vaRemain = vaArr.slice(index);
		//	return {
		//		remain : vaRemain,
		//		index : index
		//	}
		//}
	});
})();
/// end - 202108/goodday
/// start - 202111/bok/hanjinEmbeddedPage
/*
 * Module URI: 202111/bok/hanjinEmbeddedPage
 * SRC: 202111/bok/hanjinEmbeddedPage.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("202111/bok/hanjinEmbeddedPage", function(exports, globals, module){
		/************************************************
		 * hanjinEmbeddedPage.module.js
		 * Created at 2021. 11. 19. 오후 3:05:22.
		 *
		 * @author HANS
		 ************************************************/
		
		
		cpr.events.EventBus.INSTANCE.addFilter("load", function(e){
			var control = e.control;
			
			console.log("LOADED~");
			if(control instanceof cpr.core.AppInstance) {
				
				if(!control.isUDCInstance()){
					
					var voAps = control;
					
					var vaChildren = voAps.getContainer().getAllRecursiveChildren();
					
					
					var vaPages = vaChildren.filter(function(each){
						return each instanceof cpr.controls.EmbeddedPage;
					});
					
					if(vaPages.length < 0) {
						return;
					}
					
					vaPages.forEach(function(each){
						
		//				var framName = each.frameName;
						each.addEventListenerOnce("load", function(ev){
							
							var vcEmp = each;
							var vsFrameName = vcEmp.frameName;
							
							try{
								
								var voContent = document.getElementsByName(vsFrameName).item(0).contentWindow;
								/** @type NodeList */
								var vaFocusable = voContent.document.querySelectorAll('button, [href], input, [tabindex="0"], select, textarea, [contentEditable=true]');
								
								var vaEb6Native = voContent.document.querySelectorAll('.cl-control');
								console.log(vaEb6Native);
								if(vaEb6Native.length > 0) {
									console.log(voContent);
								} else {
									
									if(vaFocusable.length > 0) {
										var voFirstChild = vaFocusable[0];
										var voLastChild = vaFocusable[vaFocusable.length-1];
										console.log(vaFocusable);
										console.log(voFirstChild);
										console.log(voLastChild);
										var ctrl = each;
										(function(a,b,c){setPrevFocusableCtrl(a,b,c)})(vaChildren,each,voFirstChild);
										(function(a,b,c){setNextFocusableCtrl(a,b,c)})(vaChildren,each,voLastChild);
									}
								}
							} catch(error){
								return false;
							}
							
							
						})
					});
				}
			}
		});
		
		function getNodes(EmbeddedControl){
			
		}
		
		/**
		 * 
		 * @param {cpr.controls.UIControl[]} paCtrls
		 * @param {cpr.controls.EmbeddedPage} pcTargetCtrl
		 * @param {Element} pcChildElement
		 */
		function setPrevFocusableCtrl(paCtrls, pcTargetCtrl,pcChildElement){
			
			var vnIndex = paCtrls.indexOf(pcTargetCtrl);
			for(var i = vnIndex-1; i > 0 ; i--) {
				var vcUIControl = paCtrls[i];
				if(vcUIControl.focusable) {
					var focusa = pcChildElement;
					vcUIControl.addEventListener("keydown", function(/*cpr.events.CKeyboardEvent*/e){
						if(e.keyCode == cpr.events.KeyCode.TAB && !e.shiftKey) {
							e.preventDefault();
							focusa.focus();
						}
					});
					break;
				}
			}
		}
		
		/**
		 * 
		 * @param {cpr.controls.UIControl[]} paCtrls
		 * @param {cpr.controls.EmbeddedPage} pcTargetCtrl
		 * @param {Element} pcChildElement
		 */
		function setNextFocusableCtrl(paCtrls, pcTargetCtrl,pcChildElement) {
			
			var vnIndex = paCtrls.indexOf(pcTargetCtrl);
			if(vnIndex == paCtrls.length-1) {
				vnIndex = -1
			}
			for(var i = vnIndex+1; i < paCtrls.length-1 ; i++) {
				var vcUIControl = paCtrls[i];
				if(vcUIControl.focusable && vcUIControl.tabIndex != -1) {
					var focusa = pcChildElement;
					vcUIControl.addEventListener("keydown", function(/*cpr.events.CKeyboardEvent*/e){
						if(e.keyCode == cpr.events.KeyCode.TAB && e.shiftKey) {
							e.preventDefault();
							focusa.focus();
						}
					});
					break;
				}
			}
		}
		
		function checkFocusable(ctrl){
			
		}
	});
})();
/// end - 202111/bok/hanjinEmbeddedPage
/// start - designGui/viewHint
/*
 * Module URI: designGui/viewHint
 * SRC: designGui/viewHint.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("designGui/viewHint", function(exports, globals, module){
		/************************************************
		 * viewHint.module.js
		 * Created at 2020. 3. 19. 오전 11:46:40.
		 * Modified at 2020.04.02 조한진
		 * 변경점 : DesignGuide와  함께 사용 방법이 제공되었습니다.
		 * 		 일시적으로 useClassHintMode를 사용하지 않아도 모든 컨트롤이 가진 클래스가 제공되도록 수정되었습니다.
		 * 		현재 그리드내에 배치된 컨트롤들의 클래스들을 확인할 수 없는 문제가 있습니다.
		 * Modified at 2020.04.01 조한진
		 * 변경점 : 생성되는 힌트박스의 스타일이 변경되었습니다.
		 *		  이제 constraint 크기를 표시하는 힌트박스가 다른 힌트박스와 동일하게 배치됩니다.
		 * 		  폼레이아웃의 row-shade-color,column-shade-color 가 표시됩니다.
		 * 		 useStyleInfoMode 사용자 속성으로 통제하는 스타일 상세에 대한 힌트는 아직 구상중에 있습니다.
		 * @author HANS
		 ************************************************/
		
		
		/**
		 * 1.useClassHintMode : ("true" or anyting) 컨트롤이 가지고 있는 클래스에 대한 정보를 힌트로 제공할지의 여부를 체크합니다. 모든 컨트롤이 사용할 수 있는 사용자속성
		 * 2.useGridHintMode : ("true" or anything) 그리드가 가지고있는 크기 들에 대한 정보를 힌트로 제공할지의 여부를 체크합니다. 그리드만
		 * 3.useStyleInfoMode : ("true" or anything) 컨트롤이 가지고있는  스타일 상세에 대한 대체적으로 크기와 관련된 정보를 힌트로 제공할지의 여부를 체크합니다. 그리드를 제외한 모든 컨트롤, 검토중
		 * 4.useConstraintHintMode : ("true" or anything) 컨트롤이 배치되어있는 컨테이너(그룹)내에서 배치된 컨트롤간의 간격과 여백에 대한 크기 정보를 힌트로 제공할지의 여부를 체크합니다.
		 */
		
		var vaClassInfoHints = [];
		var vaGridInfoHints = [];
		var vaConstraintInfoHints = [];
		var vaStyleInfoHint = [];
		
		function HintKit(){
			
		}
		
		/**
		 * 현재 보여지고 있는 화면에 대해서 컨트롤이 가지고 있는 스타일 클래스 명을 표기해주는  함수입니다. 토글형식의 컨트롤이나 체크박스와 함께 사용할 수 있습니다.
		 * @param {cpr.core.AppInstance} _app
		 * @param {Boolean} bools
		 */
		HintKit.prototype.configClassInfoHints =  function(_app, bools) {
		
			if (bools) {
		
				var vcContainer = _app.getContainer();
				var voViewPortRect = vcContainer.getViewPortRect();
		
				vcContainer.getAllRecursiveChildren().forEach(function(/** cpr.controls.UIControl*/ each) {
		
		//			if (each.userAttr("useClassHintMode") == "true") {
						
						var classes = each.style.getClasses();
						var voActualRect = each.getActualRect().bottomLeft;
		
					if(classes != "" && each.getVisualParentControl().type !="grid") {
					
						var vcOptHint = new cpr.controls.Output();
						vcOptHint.value = "class : " + classes;
						vcOptHint.unselectable = false;
						vcOptHint.style.setClasses("hint-box-class");
						
						vcContainer.floatControl(vcOptHint, {
							"left": voActualRect.x + 20 + "px",
							"top": voActualRect.y + voViewPortRect.top - 10 + "px"
						});
						vaClassInfoHints.push(vcOptHint);
		
						vcOptHint.addEventListener("mouseenter", function(e) {
							vcOptHint.style.css("z-index", "5");
						});
						vcOptHint.addEventListener("mouseleave", function(e) {
							vcOptHint.style.removeStyle("z-index");
						});
					}
		//			}
		
				});
		
			} else {
		
				vaClassInfoHints.forEach(function(each) {
					each.dispose();
				});
		
			}
		}
		
		/**
		 * 
		 * @param {cpr.core.AppInstance} _app
		 * @param {Boolean} bools
		 */
		HintKit.prototype.configGridInfoHints = function(_app, bools) {
			if (bools) {
		
				var vcContainer = _app.getContainer();
				var voViewPortRect = vcContainer.getViewPortRect();
				vcContainer.getAllRecursiveChildren().forEach(function( /** cpr.controls.UIControl*/ each, idx) {
		
					if (each instanceof cpr.controls.Grid) {
						
						if(each.userAttr("useGridHintMode") == "true") {
						var vaRowHeights = each.header.getRowHeights();
						var vaDetailHeights = each.detail.getRowHeights();
						
						var gridAR = each.getActualRect();
		
						var topRight = gridAR.topRight;
						var trY = topRight.y;
						var trX = topRight.x;
						var topLeft = gridAR.topLeft;
		
						var totalHeights = vaRowHeights.concat(vaDetailHeights);
		
						var width = 40;
						var height = 40;
		
						totalHeights.forEach(function(eachs) {
							if (eachs.height) {
		
								var horizontal = new udc.Horizontal();
		
								vcContainer.floatControl(horizontal, {
									"width": width + "px",
									"height": eachs.height + "px",
									"left": topRight.x - width + "px",
									"top": trY + voViewPortRect.top + "px"
								});
								var hints = _createHintBox(vcContainer, eachs.height+"px",{
									"left" : topRight.x - width + "px",
									"top" : trY + voViewPortRect.top + 20 +"px"
								});
								
								trY += eachs.height;
							}
							vaGridInfoHints.push(horizontal);
							vaGridInfoHints.push(hints);
						});
		
						var vsFixedWidth1 = each.getColumnWidths()[0];
						var vnFixedWidth1 = Number(vsFixedWidth1.substring(0, vsFixedWidth1.length - 2));
						var vsFixedWidth2 = each.getColumnWidths()[1];
						var vnFixedWidth2 = Number(vsFixedWidth2.substring(0, vsFixedWidth2.length - 2));
		
						var vertical = new udc.Vertical();
		
						vcContainer.floatControl(vertical, {
							"width": vsFixedWidth1,
							"height": height + "px",
							"left": topLeft.x + "px",
							"top": topLeft.y + voViewPortRect.top - height / 2 + "px"
		
						});
						var hints = _createHintBox(vcContainer, vsFixedWidth1,{
									"left" : topLeft.x + "px",
									"top" : topLeft.y + voViewPortRect.top -height/2 +30 +"px"
								});
						vaGridInfoHints.push(vertical);
						vaGridInfoHints.push(hints);
						var vertical2 = new udc.Vertical();
						vcContainer.floatControl(vertical2, {
							"width": vsFixedWidth2,
							"height": height + "px",
							"left": topLeft.x + vnFixedWidth1 + "px",
							"top": topLeft.y + voViewPortRect.top - height / 2 + "px"
						});
						var hints2 = _createHintBox(vcContainer, vsFixedWidth2,{
									"left" : topLeft.x + vnFixedWidth1 + "px",
									"top" : topLeft.y + voViewPortRect.top -height/2 + 30 +"px"
								});
						vaGridInfoHints.push(vertical2);
						vaGridInfoHints.push(hints2);
						//여기까지 그리드 헤더 디테일, 특수컬럼 크기 그리는 영역
						}
					}
				});
			} else {
		
				vaGridInfoHints.forEach(function(each) {
					each.dispose();
				});
			}
		
		};
		
		/**
		 * 컨트롤이 가지고있는 스타일 상세를 알고싶을 때 사용할 예정
		 * @param {cpr.core.AppInstance} _app
		 * @param {Boolean} bools
		 */
		HintKit.prototype.configStyleInfoHint = function(_app, bools) {
			
			
		}
		
		/**
		 * 컨테이너 위주의 단위를 보여줄때 Container내부 컨트롤 간의 spacing, margin 등등
		 * @param {cpr.core.AppInstance} _app
		 * @param {Boolean} bools
		 */
		HintKit.prototype.configConstriantInfoHints = function(_app, bools) {
			if (bools) {
		
				var vcContainer = _app.getContainer();
				var voViewPortRect = vcContainer.getViewPortRect();
		
				vcContainer.getAllRecursiveChildren(true).forEach(function( /** cpr.controls.Container*/ each) {
					
					if(each.userAttr("useConstraintHintMode") == "true") {
						
						var voLayout = each.getLayout();
						if(voLayout instanceof cpr.controls.layouts.XYLayout) {
						
							var children = each.getChildren();
							var child = children[0];
							var verticalSpacing = 0;
							var horizontalSpacing = 0;
							
							for (var idx = 1 ; idx < each.getChildrenCount() ; idx++) {
								
								if(children[idx].getOffsetRect().left - child.getOffsetRect().right > 0) {
									
									if(verticalSpacing != children[idx].getOffsetRect().left - child.getOffsetRect().right) {
										
										verticalSpacing = children[idx].getOffsetRect().left - child.getOffsetRect().right;
										
										var spacing = new udc.Vertical();
		//								spacing.optValue = verticalSpacing;
										each.floatControl(spacing,{
											"width" : verticalSpacing+"px",
											"height" : "20px",
											"top" : child.getOffsetRect().top + "px",
											"left": child.getOffsetRect().right + "px"
										});
										var hintSpacing = _createHintBox(vcContainer, verticalSpacing+"px",{
											"top" : child.getOffsetRect().top+ 20 +"px",
											"left" : child.getOffsetRect().right + "px"
										});
										
										vaConstraintInfoHints.push(hintSpacing);
										vaConstraintInfoHints.push(spacing);
									}
								}
								
								if(children[idx].getOffsetRect().top - child.getOffsetRect().top  > 0) {
									
									if(horizontalSpacing != children[idx].getOffsetRect().top - child.getOffsetRect().top) {
										
										horizontalSpacing = children[idx].getOffsetRect().top - child.getOffsetRect().bottom;
										
										var spacing = new udc.Horizontal();
										each.floatControl(spacing,{
											"width" : "20px",
											"height" : horizontalSpacing + "px",
											"top" : children[idx].getOffsetRect().top-horizontalSpacing+"px",
											"left" : children[idx].getOffsetRect().left+ "px"
										});
										var hintSpacing2 = _createHintBox(vcContainer, verticalSpacing+"px",{
											"top" : children[idx].getOffsetRect().top-horizontalSpacing + 20 +"px",
											"left" : children[idx].getOffsetRect().left + "px"
										});
										
										vaConstraintInfoHints.push(hintSpacing2);
										vaConstraintInfoHints.push(spacing);								
									}
								}
								
								child = children[idx];
								
							}												
						}
						else if(voLayout instanceof cpr.controls.layouts.FormLayout) {
							var horizontalSpacing = voLayout.horizontalSpacing;
							var horizontalMargin = voLayout.horizontalMargin;
							var verticalSpacing = voLayout.verticalSpacing;
							var verticalMargin = voLayout.verticalMargin;
							
							var marginHorizontal = new udc.Horizontal();
							each.floatControl(marginHorizontal, {
								"width" :  "40px",
								"height" : horizontalMargin,
								"left" : "calc(50%)",
								"top" : "0px"
							});
							var hintMH = _createHintBox(each, horizontalMargin,{
								"top" : "10px",
								"left" : "calc(50%)"
							});
							vaConstraintInfoHints.push(hintMH);
							vaConstraintInfoHints.push(marginHorizontal);
							
							var spacingHorizontal = new udc.Horizontal();
							each.floatControl(spacingHorizontal, {
								"width" : "30px",
								"height" : horizontalSpacing,
								"left" : "calc(30%)",
								"top" : each.getChildren()[0].getOffsetRect().bottom +"px"
							});
							
							var hintSH = _createHintBox(each, horizontalSpacing,{
								"top" : each.getChildren()[0].getOffsetRect().bottom +10+"px",
								"left" : "calc(30%)"
							});
							vaConstraintInfoHints.push(hintSH);
							vaConstraintInfoHints.push(spacingHorizontal);
							
							var marginVertical = new udc.Vertical();
							each.floatControl(marginVertical,{
								"width" : verticalMargin,
								"height" : "30px",
								"left" : "0px",
								"top" : horizontalMargin
							});
							var hintMV = _createHintBox(each, verticalMargin,{
								"top" : "0px",
								"left" : horizontalMargin
							});
							vaConstraintInfoHints.push(hintMV);
							vaConstraintInfoHints.push(marginVertical);
							var spacingVertical = new udc.Vertical();
							each.floatControl(spacingVertical,{
								"width" : verticalSpacing,
								"height" : "30px",
								"left" : each.getChildren()[0].getOffsetRect().right+"px",
								"top" : "10px"
							});
							
							var hintSV = _createHintBox(each, verticalSpacing,{
								"top" : "20px",
								"left" : each.getChildren()[0].getOffsetRect().right+"px"
							});
							vaConstraintInfoHints.push(hintSV);
							vaConstraintInfoHints.push(spacingVertical);
							
							voLayout.getRows().some(function(eachs,idx){
								if(voLayout.isUseRowShade(idx)) {
									var vsClass = "";
									each.style.getClasses().forEach(function(clas){
										vsClass +="." + clas
									});
									var rowShade = getComputedStyle(document.querySelector(vsClass+" .cl-formlayout-row-shade")).backgroundColor;
									var vsRowShadeColor = rgbToHex(rowShade);
		//					
									var hintRSC =_createHintBox(each, vsRowShadeColor,{
										"top" : eachs,
										"left" : "calc(10%)"
									});
									vaConstraintInfoHints.push(hintRSC);
									return each;
								}
							});
							
							voLayout.getColumns().some(function(eachs,idx){
								if(voLayout.isUseColumnShade(idx)) {
									var vsClass = "";
									each.style.getClasses().forEach(function(clas){
										vsClass += "." + clas;
									});
									var columnShade = getComputedStyle(document.querySelector(vsClass+" .cl-formlayout-column-shade")).backgroundColor;
									var vsColumnShadeColor = rgbToHex(columnShade);
									
									var hintCSC = _createHintBox(each,vsColumnShadeColor,{
										"bottom" : "calc(5%)",
										"left" : eachs 
									});
									vaConstraintInfoHints.push(hintCSC);
									return each;
								}
							});
							
						}
						else if(voLayout instanceof cpr.controls.layouts.VerticalLayout) {
		
							var topHorizontal = new udc.Horizontal();
							each.floatControl(topHorizontal, {
								"width" : "40px",
								"height" : voLayout.topMargin+"px",
								"top" : "0px",
								"left" : "calc(50%)"
							});
							var hintTH = _createHintBox(each, voLayout.topMargin+"px",{
								"top" : "0px",
								"left" : "calc(50%)"
							});
							vaConstraintInfoHints.push(hintTH);
							vaConstraintInfoHints.push(topHorizontal);
		
							var bottomHorizontal = new udc.Horizontal();
							each.floatControl(bottomHorizontal, {
								"width" : "40px",
								"height" : voLayout.bottomMargin+"px",
								"bottom" : "0px",
								"left" : "calc(50%)"
							});
							var hintBH = _createHintBox(each, voLayout.bottomMargin+"px",{
								"left" : "calc(50%)",
								"bottom" : "0px"
							});
							vaConstraintInfoHints.push(hintBH);
							vaConstraintInfoHints.push(bottomHorizontal);
							
							var spacingHorizontal = new udc.Horizontal();
							each.floatControl(spacingHorizontal, {
								"width" : "40px",
								"height" : voLayout.spacing+"px",
								"top" : each.getFirstChild().getActualRect().bottom + "px",
								"left" : "calc(50%)"
							});
							var hintSH = _createHintBox(each, voLayout.spacing+"px",{
								"top" : each.getFirstChild().getActualRect().bottom + 10 + "px",
								"left" : "calc(50%)"
							});
							vaConstraintInfoHints.push(hintSH);
							vaConstraintInfoHints.push(spacingHorizontal);
							
							var leftVertical = new udc.Vertical();
							each.floatControl(leftVertical, {
								"width" : voLayout.leftMargin+"px",
								"height" : "30px",
								"left" : "0px",
								"top" : "calc(50%)"
							});
							var hintLV = _createHintBox(each, voLayout.leftMargin+"px",{
								"top" : "calc(50%)",
								"left" : "0px"
							});
							vaConstraintInfoHints.push(hintLV);
							vaConstraintInfoHints.push(leftVertical);
							
							var rightVertical = new udc.Vertical();
							each.floatControl(rightVertical,{
								"width" : voLayout.rightMargin +"px",
								"height": "30px",
								"right" : "0px",
								"top" : "calc(50%)"
							});
							var hintRV = _createHintBox(each, voLayout.rightMargin+"px",{
								"top" : "calc(50%)",
								"right" : "0px"
							});
							vaConstraintInfoHints.push(hintRV);
							vaConstraintInfoHints.push(rightVertical);	
							
						}
						else if(voLayout instanceof cpr.controls.layouts.FlowLayout) {
							
							var spacingHorizontal = new udc.Horizontal();
							var firstChild = each.getFirstChild();
							each.floatControl(spacingHorizontal,{
								"width" : "40px",
								"height" : voLayout.spacing +"px",
								"top" : firstChild.getActualRect().bottom + "px",
								"left" : firstChild.getActualRect().bottomCenter.x +"px"
							});
							
							vaConstraintInfoHints.push(spacingHorizontal);
							var spacingVertical = new udc.Vertical();
							
							each.floatControl(spacingVertical,{
								"width" : voLayout.spacing + "px",
								"height" : "40px",
								"top" : firstChild.getActualRect().top +"px",
								"left" : firstChild.getActualRect().right +"px"
							});
							vaConstraintInfoHints.push(spacingVertical);
						}
					}
						
				});
			} else {
				vaConstraintInfoHints.forEach(function(each){
					each.dispose();
				});
			}
		
		}
		
		function rgbToHex(rgbType) {
			  var rgb = rgbType.replace( /[^%,.\d]/g, "" ); 
		        // 쉼표(,)를 기준으로 분리해서, 배열에 담기. 
		        rgb = rgb.split( "," ); 
		
		  return "#" + Number(rgb[0]).toString(16) + Number(rgb[1]).toString(16) + Number(rgb[2]).toString(16);
		}
		
		
		/**
		 * 
		 * @param {cpr.controls.Container} vcContainer
		 * @param {String} values
		 * @param {cpr.controls.layouts.Constraint} Constraint
		 */
		function _createHintBox(vcContainer,values,Constraint){
			var vcOptHint = new cpr.controls.Output();
						vcOptHint.value = values;
						vcOptHint.unselectable = false;
						vcOptHint.style.setClasses("hint-box");
						vcContainer.floatControl(vcOptHint,Constraint);
		//				vaClassInfoHints.push(vcOptHint);
		
						vcOptHint.addEventListener("mouseenter", function(e) {
							vcOptHint.style.css("z-index", "5");
						});
						vcOptHint.addEventListener("mouseleave", function(e) {
							vcOptHint.style.removeStyle("z-index");
						});
				return vcOptHint;
		}
		
		
		
		/**
		 * 
		 * @param {cpr.core.AppInstance} _app
		 * @param {Boolean} bools
		 */
		HintKit.prototype.showFormDivision = function(_app,bools){
			
			var voAppIns = _app;
			
			voAppIns.getContainer().getAllRecursiveChildren().forEach(function(/*cpr.controls.Control*/each){
				
				if(each instanceof cpr.controls.Container) {
					
					if(each.getLayout() instanceof cpr.controls.layouts.FormLayout) {
						
						drawHorizontalPlan(each,bools);
						drawVerticalPlan(each,bools);
					}
				}
			});
		}
		/**
		 * 
		 * @param {cpr.controls.layouts.FormLayout} layout
		 */
		function calcWidthFr(layout){
			
			var lay = layout;
			
			
			var cols = lay.getColumns();//컬럼 구획 크기 가져오기
			var colSp = lay.horizontalSpacing;//가로 간격
			var leftM = lay.leftMargin;//좌 여백
			var rightM = lay.rightMargin;//우 여백
			
			var corFr = cols.filter(function(each){
				return each.indexOf("fr") >=0;
			});
			corFr = corFr.map(function(each){
				return parseInt(each.replace("fr", ""));
			});
			var res = 0 ;
			corFr.forEach(function(each){
				res+= each;
			});
					//컬럼 구획 fr인 애들 전부 더하기
			
			if(leftM.indexOf("fr") >=0) {
				
				res += parseInt(leftM.replace("fr", ""));
			}//좌 마진이 fr이면 더하기
			if(rightM.indexOf("fr") >= 0) {
				
				res += parseInt(rightM.replace("fr",""));
			}//우 마진이 fr이면 더하기
			
			if(colSp.indexOf("fr") >= 0) {
				
				res += parseInt(colSp.replace("fr", "")) * (cols.length -1)
			}//간격이 fr이면 간격만큼 더하기
			
			return res;
		}
		
		/**
		 * 
		 * @param {cpr.controls.layouts.FormLayout} layout
		 */
		function calcHeightFr(layout) {
			
			var lay = layout;
			
			var rows = lay.getRows();
			var rowSp = lay.verticalSpacing;
			var topM = lay.topMargin;
			var botM = lay.bottomMargin;
			
			var rowFr = rows.filter(function(each){
				return each.indexOf("fr") >=0;
			});
			
			rowFr = rowFr.map(function(each){
				return parseInt(each.replace("fr", ""));
			});
			
			var res = 0;
			rowFr.forEach(function(each){
				res += each;
			});
			if(topM.indexOf("fr") >=0) {
				
				res += parseInt(topM.replace("fr", ""));
			}//좌 마진이 fr이면 더하기
			if(botM.indexOf("fr") >= 0) {
				
				res += parseInt(botM.replace("fr",""));
			}//우 마진이 fr이면 더하기
			
			if(rowSp.indexOf("fr") >= 0) {
				
				res += parseInt(rowSp.replace("fr", "")) * (rows.length -1)
			}//간격이 fr이면 간격만큼 더하기
			
			return res;
		}
		
		var horizontals = [];
		
		/**
		 * 
		 * @param {cpr.controls.Container} pcContainer
		 * @param {Boolean} pb
		 */
		function drawHorizontalPlan(pcContainer,pb){
			if(pb) {
				
			var grp = pcContainer;
		/** @type cpr.controls.layouts.FormLayout */
			var layouts = grp.getLayout();
			var allFr = calcWidthFr(layouts);
			var cols = layouts.getColumns();
			
			var width = grp.getActualRect().width;
			
			var colPx = cols.filter(function(each){
				return each.indexOf("px") >= 0;
			});
			var survivedWidth = width;
			
			colPx.forEach(function(each){
				var pxWidth = parseInt(each.replace("px",""));
				
				survivedWidth -= pxWidth;
			});
		
			if(layouts.rightMargin.indexOf("px") >= 0){
				survivedWidth -= parseInt(layouts.rightMargin.replace("px", ""));
			}
			
			var startMan = grp.getActualRect().left;
			var margin = 0;
			if(layouts.leftMargin.indexOf("fr") >= 0 ) {
				margin = survivedWidth * parseInt(layouts.leftMargin.replace("fr","")) / allFr;
				startMan += margin
			} else {
				survivedWidth -= parseInt(layouts.leftMargin.replace("px",""));
				margin = parseInt(layouts.leftMargin.replace("px", ""));
				startMan += margin;
			}
			
			var spacing = 0;
			if(layouts.horizontalSpacing.indexOf("fr") >= 0 ) {
				spacing = survivedWidth * parseInt(layouts.horizontalSpacing.replace("fr","")) / allFr;
			} else {
				spacing = parseInt(layouts.horizontalSpacing.replace("px", ""));
				survivedWidth -= parseInt(layouts.horizontalSpacing.replace("px",""))*(cols.length-1);
			}
			
			cols.forEach(function(each){
				var button = new cpr.controls.Button();
				button.value = each;
				button.style.addClass("btn-outline-light");
				var constraint = {
					"left" : startMan+"px",
					"top" : grp.getActualRect().bottom+"px",
					"width" : "",
					"height" : "25px"
				}	
				if(each.indexOf("fr") >= 0) {
					
					constraint.width = survivedWidth * parseInt(each.replace("fr", "")) / allFr +"px";
				} else {
					
					constraint.width = each;
				}
				
				pcContainer.getAppInstance().getContainer().floatControl(button, constraint);
				horizontals.push(button);
				startMan += parseInt(constraint.width.replace("px", "")) + spacing
		 	});
		 	} else {
		 		
		 		horizontals.forEach(function(each){
		 			each.dispose();
		 		})
		 	}
		}
		
		
		var verticals = [];
		/**
		 * 
		 * @param {cpr.controls.Container} pcContainer
		 * @param {Boolean} pb
		 */
		function drawVerticalPlan(pcContainer,pb) {
			if(pb){
				
			var grp = pcContainer;
		/** @type cpr.controls.layouts.FormLayout */
			var layouts = grp.getLayout();
			var allFr = calcHeightFr(layouts);
			var rows = layouts.getRows();
			var height = grp.getActualRect().height;
			
			var rowPx = rows.filter(function(each){
				return each.indexOf("px") >= 0;
			});
			var survivedHeight = height;
			
			rowPx.forEach(function(each){
				var psHeight = parseInt(each.replace("px",""));
				
				survivedHeight -= psHeight;
			});
		
			if(layouts.bottomMargin.indexOf("px") >= 0){
				survivedHeight -= parseInt(layouts.bottomMargin.replace("px", ""));
			}
			
			var startMan = grp.getActualRect().top;
			var margin = 0;
			if(layouts.topMargin.indexOf("fr") >= 0 ) {
				margin = survivedHeight * parseInt(layouts.topMargin.replace("fr","")) / allFr;
				startMan += margin
			} else {
				survivedHeight -= parseInt(layouts.topMargin.replace("px",""));
				margin = parseInt(layouts.topMargin.replace("px", ""));
				startMan += margin;
			}
			
			var spacing = 0;
			if(layouts.verticalSpacing.indexOf("fr") >= 0 ) {
				spacing = survivedHeight * parseInt(layouts.verticalSpacing.replace("fr","")) / allFr;
			} else {
				spacing = parseInt(layouts.verticalSpacing.replace("px", ""));
				survivedHeight -= parseInt(layouts.verticalSpacing.replace("px",""))*(rows.length-1);
			}
		
			rows.forEach(function(each){
				var button = new cpr.controls.Button();
				button.value = each;
				button.style.addClass("btn-outline-light");
				var constraint = {
					"left" : grp.getActualRect().right+"px",
					"top" : startMan+"px",
					"width" : "100px",
					"height" : ""
				}	
				if(each.indexOf("fr") >= 0) {
					
					constraint.height = survivedHeight * parseInt(each.replace("fr", "")) / allFr +"px";
				} else {
					
					constraint.height = each;
				}
				
				pcContainer.getAppInstance().getContainer().floatControl(button, constraint);
				verticals.push(button);
				startMan += parseInt(constraint.height.replace("px", "")) + spacing
		 	});
		 	} else {
		 		
		 		verticals.forEach(function(each){
		 			
		 			each.dispose();
		 		});
		 	}
		}
		
		globals.createNewHintKit = function(){
			return new HintKit();
		}
	});
})();
/// end - designGui/viewHint
/// start - drawSlash
/*
 * Module URI: drawSlash
 * SRC: drawSlash.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("drawSlash", function(exports, globals, module){
		///************************************************
		// * isHan.module.js
		// * Created at 2020. 1. 31. 오전 11:02:38.
		// *
		// * @author HANS
		// ************************************************/
		//
		//
		///**
		// * svg요소의 line요소를 사용해서 대각선을 HTMLSnippe에 집어넣고 리턴하는 메서드입니다.
		// * @param {Number} x 전체 요소의 가로크기
		// * @param {Number} y 전체 요소의 세로크기
		// */
		//function _createSlash(x,y) {
		//	var snippet = new cpr.controls.HTMLSnippet();
		//	snippet.style.addClass("slash");
		//	snippet.value ='<svg height="'+y+'" width="'+x+'">'
		//	 + '<line x1="0" y1="0" x2="'+x+'" y2="'+y+'" style="stroke:rgb(255,0,0);stroke-width:1"/>'
		//	  + '</svg>';
		//	  
		//	  return snippet;
		//}
		//
		//
		//function _createReverseSlash(x,y) {
		//	
		//	var snippet = new cpr.controls.HTMLSnippet();
		//	snippet.style.addClass("slash");
		//	snippet.value ='<svg height="'+y+'" width="'+x+'">'
		//	 + '<line x1="'+x+'" y1="0" x2="0" y2="'+y+'" style="stroke:rgb(255,0,0);stroke-width:1"/>'
		//	  + '</svg>';
		//	  
		//	  return snippet;
		//}
		///**
		// * HTMLSnippet 객체를 추가하여 아이템 간의 slash를 붙여주는 메서드입니다.
		// * @param {cpr.core.AppInstance} _app
		// * @param {cpr.controls.UIControl} pcCtrl1
		// * @param {cpr.controls.UIControl} pcCtrl2
		// */
		//function drawSlash (_app, pcCtrl1,pcCtrl2){
		//	/** @type cpr.controls.Container */
		//	var vcGrpCn = _app.getAppProperty("atten"); // 컨텐츠 내부 컨테이너 객체
		//	
		//	var voGrpCnRect = vcGrpCn.getActualRect(); // 컨텐츠 내부 컨테이너 크기
		//	var voCtrl1Rect = pcCtrl1.getActualRect(); // 컨트롤1의 크기
		//	var voCtrl2Rect = pcCtrl2.getActualRect(); // 컨트롤2의 크기
		//	
		//	var vnWidth = voCtrl2Rect.topCenter.x - voCtrl1Rect.bottomCenter.x; // 너비
		//	var vnHeight = voCtrl2Rect.topCenter.y - voCtrl1Rect.bottomCenter.y; // 높이
		//	
		//	var x = 0; // x 좌표
		//	var y = 0; // y 좌표
		//	
		//	var vcOpt;
		//	/* 차트의 위치에 의해 과거일 때는 선을 긋지 않도록 방지 */
		//	if (vnWidth < 0 || vnHeight < 0){
		//		vnWidth = Math.abs(vnWidth);
		//		vcOpt = _createReverseSlash(vnWidth, vnHeight);
		//		x = voCtrl2Rect.topCenter.x; // x 좌표 계산
		//	}
		//	else {
		//		x = voCtrl1Rect.bottomCenter.x - voGrpCnRect.left; // x 좌표 계산
		//		vcOpt = _createSlash(vnWidth, vnHeight);
		//	}
		//	
		//	/* 선 동적 생성 */
		////	var vcOpt = _createSlash(vnWidth,vnHeight);
		//	
		//	
		//	y = voCtrl1Rect.bottomCenter.y - voGrpCnRect.top; // y 좌표 계산
		//	
		//	/* 컨텐츠 내부 영역에 선을 띄움 */
		//	vcGrpCn.floatControl(vcOpt, {
		//		"width" : vnWidth+"px",
		//		"height" : vnHeight+"px",
		//		"left" : x +"px",
		//		"top" : y +"px"
		//	});
		//}
		//
		////globals.toDegrees = function(paramDouble){
		////	return 180/Math.PI * paramDouble;
		////}
		//
		//
		/////**
		//// * 모든 스크롤 감지 후 경우에 따라 특정 스크립트 동작 정의 
		//// * @param {Event} e
		//// */
		////cpr.events.EventBus.INSTANCE.addFilter("scroll", function(e){
		////	/** @type cpr.controls.UIControl */
		////	var control = e.control;
		////	
		////	var voApp = control.getAppInstance();
		////	
		////	voApp.removeAllFloatingControls(true);
		////	
		////	var vaAllChildren = voApp.getContainer().getAllRecursiveChildren();
		////	vaAllChildren.filter(function(each){
		////		return each.style.hasClass("slash");
		////	}).forEach(function(each){
		////		voApp.lookup("grpCutCn").removeChild(each);
		////	});
		////});
		//
		//
		///* 마우스 오버 시 선 긋기 */
		//cpr.events.EventBus.INSTANCE.addFilter("mouseenter", function(e){
		//	
		///** @type cpr.controls.UIControl */
		//	var control = e.control;
		//	
		//	/* 전로, 정련, 연주 또는 차트에만 선이 그어져야 하므로 해당 컨트롤 필터 */
		//	if(control instanceof cpr.controls.Output || control instanceof cpr.controls.HTMLSnippet || control instanceof cpr.controls.Button) {
		//		var voApp = control.getAppInstance();
		//		var vaAllChildren = voApp.getContainer().getAllRecursiveChildren();
		//		
		//		/* 같은 작업 순서 아이템을 필터 */
		//		var vaFilteredCtrl = vaAllChildren.filter(function(each){
		//				if(each.userAttr("cast-no") != "" && each.userAttr("cast-no") == control.userAttr("cast-no")) {
		//					/* 마우스가 아이템을 벗어날 때 선 삭제 */
		//					each.addEventListenerOnce("mouseleave", function(e){
		//						voApp.getContainer().getAllRecursiveChildren().forEach(function(each){
		//							if(each.style.hasClass("slash")) {
		//								voApp.getAppProperty("atten").removeChild(each);
		//							}
		//						});
		//					});
		//					return each;
		//				}
		//		});
		//		
		//		/* 일부 데이터에 한하여 선이 그어질 수 없으므로 자식요소가 1개 이상일 때만 선 긋기 */
		//		if(vaFilteredCtrl.length > 0) {
		//			/* 위치에 따라 컨트롤 정렬 */
		//			vaFilteredCtrl.sort(function(a,b) {
		//				
		//				return a.getActualRect().top - b.getActualRect().top ;
		//			});
		//			
		//			/* 컨트롤과 다음 컨트롤을 인자로  */
		//			for(var idx = 0 ; idx+1 < vaFilteredCtrl.length ; idx ++) {
		//				drawSlash(voApp, vaFilteredCtrl[idx], vaFilteredCtrl[idx+1]);
		//			}
		//		}
		//	}
		//});
	});
})();
/// end - drawSlash
/// start - hana/report_post
/*
 * Module URI: hana/report_post
 * SRC: hana/report_post.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("hana/report_post", function(exports, globals, module){
		/************************************************
		 * report.module.js
		 * Created at 2020. 5. 18. 오전 10:07:11.
		 *
		 * @author daye
		 ************************************************/
		
		/*
		 * 본 모듈은 Clip Report 를 연동할 수 있는 기능을 제공합니다.
		 * Clip Report 외에도 Post방식으로 레포트를 연동할 경우에,  
		 * [옵션 추가], [파라미터 추가] 부분에서 각 레포트 파라미터 형식에 맞게 수정하여 사용 할 수 있습니다.
		 *
		 * 
		 * <사용방법>
		 * 조회 시 setReportPost API를 호출합니다.
		 *  poParam에서 url, filePath는 필수입력항목입니다. 나머지 필요 옵션들은 options 내에 JSON 타입으로 작성해 주십시오.
		 */
		
		
		/**
		 * @param {cpr.core.AppInstance} app
		 * @param {#embeddedpage} psEmbpageId
		 * @param {any} paDataMapId
		 * @param {
		 * 		url: String <!-- postMehod action URL -->, 
		 * 		filePath : String <!-- 레포트 파일 경로 -->,
		 * 		options? : JSON <!-- viewer 옵션 설정 -->
		 * }  poParam
		 */
		globals.setReportPost = function (app, psEmbpageId, paDataMapId, poParam) {
			
			/** @type cpr.controls.EmbeddedPage */
			var vcEmbPage = app.lookup(psEmbpageId);
			
			/* HttpPostMehtod 객체 생성 */
			var vsReportUrl = poParam.url;
			var postMethod = vcEmbPage.getPostMethod(vsReportUrl);
		
			if(!(paDataMapId instanceof Array)){
				paDataMapId = [paDataMapId];
			}
			
			/* 옵션 추가 */
			Object.keys(poParam.options).forEach(function(each) {
				postMethod.addParameter(each, poParam[each]);
			});
				
			/* 파라미터 추가 */
			paDataMapId.forEach(function(each) {
				/** @type cpr.data.DataMap */
				var vcDataMap = app.lookup(each);
				var vaColNms = vcDataMap.getColumnNames();
				vaColNms.forEach(function(each, index){
				   postMethod.addParameter("viewerParameter", index+":="+vcDataMap.getValue(each)); 
				   // rd fileName send
				});
			})
			
			/* 파라미터 전송 */
			postMethod.submit();
		
			/* postMethod 초기화 */
			postMethod.dispose();    
		}
		
	});
})();
/// end - hana/report_post
/// start - hintViewSave
/*
 * Module URI: hintViewSave
 * SRC: hintViewSave.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("hintViewSave", function(exports, globals, module){
		﻿/************************************************
		 * viewHint.module.js
		 * Created at 2020. 3. 19. 오전 11:46:40.
		 * Modified at 2020.04.02 조한진
		 * 변경점 : DesignGuide와  함께 사용 방법이 제공되었습니다.
		 * 		 일시적으로 useClassHintMode를 사용하지 않아도 모든 컨트롤이 가진 클래스가 제공되도록 수정되었습니다.
		 * 		현재 그리드내에 배치된 컨트롤들의 클래스들을 확인할 수 없는 문제가 있습니다.
		 * Modified at 2020.04.01 조한진
		 * 변경점 : 생성되는 힌트박스의 스타일이 변경되었습니다.
		 *		  이제 constraint 크기를 표시하는 힌트박스가 다른 힌트박스와 동일하게 배치됩니다.
		 * 		  폼레이아웃의 row-shade-color,column-shade-color 가 표시됩니다.
		 * 		 useStyleInfoMode 사용자 속성으로 통제하는 스타일 상세에 대한 힌트는 아직 구상중에 있습니다.
		 * @author HANS
		 ************************************************/
		
		cpr.events.EventBus.INSTANCE.addFilter("load", function(e){
			var control = e.control;
			if(control instanceof cpr.core.AppInstance) {
		
				if(control.app.id.indexOf("DesignGuide") != -1) {
			var util = createNewHintKit();
			var vcHintCheckBox = new cpr.controls.Container();
			var vLayout = new cpr.controls.layouts.VerticalLayout();
		
			vcHintCheckBox.setLayout(vLayout);
			vcHintCheckBox.style.css({
				"background-color" : "#ffffff",
				"opacity" : 0.9
			});
		
			var vcClassCheck = new cpr.controls.CheckBox();
			vcClassCheck.text = "클래스 정보확인"
			vcClassCheck.addEventListener("value-change", function(e){
				util.configClassInfoHints(control, e.newValue);
			});
			var vcConstraintCheck = new cpr.controls.CheckBox();
			vcConstraintCheck.text = "Layouts";
			vcConstraintCheck.addEventListener("value-change", function(e){
				util.configConstriantInfoHints(control, e.newValue);
			});
			var vcGridCheck = new cpr.controls.CheckBox();
			vcGridCheck.text = "그리드 정보확인";
			vcGridCheck.addEventListener("value-change", function(e){
				util.configGridInfoHints(control, e.newValue);
			});
		
			var vcFormDivisionCheck = new cpr.controls.CheckBox();
			vcFormDivisionCheck.text = "FormDivision";
			vcFormDivisionCheck.addEventListener("value-change", function(e){
				util.showFormDivision(control, e.newValue);
			});
		
			vcHintCheckBox.addChild(vcClassCheck, {
				"width" : "100px",
				"height" : "30px",
				"autoSize" : "none"
			});
			vcHintCheckBox.addChild(vcConstraintCheck, {
				"width" : "100px",
				"height" : "30px",
				"autoSize" : "none"
			});
			vcHintCheckBox.addChild(vcGridCheck, {
				"width" : "100px",
				"height" : "30px",
				"autoSize" : "none"
			});
			vcHintCheckBox.addChild(vcFormDivisionCheck, {
				"width" : "100px",
				"height" : "30px",
				"autoSize" : "none"
			});
		
			control.floatControl(vcHintCheckBox,{
				"top" : "calc(50% - 50px)",
				"right" : "20px",
				"width" : "150px"
			});
		
		
			var vcSnippet = new cpr.controls.HTMLSnippet();
				vcSnippet.style.css("background-color","red");
				vcSnippet.value =
				"<style type='text/css'>"+
				".cl-output.hintman {"+
		  		"background-color: #4D5052;"+
		  		"opacity: 0.5;"+
				"border-radius: 5px;"+
		  		"color: white;"+
		  		"padding-left: 10px;"+
				"}"+
				".cl-output.hintman:not(.cl-selected):hover {"+
		  		"opacity: 1;"+
				"}"+
				".importan {"
		//		 + "border : solid 2px red !important}"+
				+"box-shadow: 0px 0px 0px 2px rgba(255,0,0,1)"+
				"</style>"
		
				control.floatControl(vcSnippet,{
					"width":"1px",
					"height":"1px",
					"top":"0px",
					"left":"0px"
				});
				vcSnippet.visible = false;
				}
			}
		});
		
		/**
		 * 1.useClassHintMode : ("true" or anyting) 컨트롤이 가지고 있는 클래스에 대한 정보를 힌트로 제공할지의 여부를 체크합니다. 모든 컨트롤이 사용할 수 있는 사용자속성
		 * 2.useGridHintMode : ("true" or anything) 그리드가 가지고있는 크기 들에 대한 정보를 힌트로 제공할지의 여부를 체크합니다. 그리드만
		 * 3.useStyleInfoMode : ("true" or anything) 컨트롤이 가지고있는  스타일 상세에 대한 대체적으로 크기와 관련된 정보를 힌트로 제공할지의 여부를 체크합니다. 그리드를 제외한 모든 컨트롤, 검토중
		 * 4.useConstraintHintMode : ("true" or anything) 컨트롤이 배치되어있는 컨테이너(그룹)내에서 배치된 컨트롤간의 간격과 여백에 대한 크기 정보를 힌트로 제공할지의 여부를 체크합니다.
		 */
		
		var vaClassInfoHints = [];
		var vaGridInfoHints = [];
		var vaConstraintInfoHints = [];
		var vaStyleInfoHint = [];
		
		//var vcSnippet;
		function HintKit(){
		
		}
		
		/**
		 * 현재 보여지고 있는 화면에 대해서 컨트롤이 가지고 있는 스타일 클래스 명을 표기해주는  함수입니다. 토글형식의 컨트롤이나 체크박스와 함께 사용할 수 있습니다.
		 * @param {cpr.core.AppInstance} _app
		 * @param {Boolean} bools
		 */
		HintKit.prototype.configClassInfoHints =  function(_app, bools) {
		
			if (bools) {
		
				var vcContainer = _app.getContainer();
				var voViewPortRect = vcContainer.getViewPortRect();
		
				vcContainer.getAllRecursiveChildren().forEach(function(/** cpr.controls.UIControl*/ each) {
		
		//			if (each.userAttr("useClassHintMode") == "true") {
		
						var classes = each.style.getClasses();
						var voActualRect = each.getActualRect().bottomLeft;
		
					if(classes != "" && each.getVisualParentControl().type !="grid") {
		
						var vcOptHint = new cpr.controls.Output();
						vcOptHint.value = "class : " + classes;
						vcOptHint.unselectable = false;
						vcOptHint.style.setClasses("hintman");
		
						vcContainer.floatControl(vcOptHint, {
							"left": voActualRect.x + 20 + "px",
							"top": voActualRect.y + voViewPortRect.top - 10 + "px"
						});
						vaClassInfoHints.push(vcOptHint);
						vcOptHint.addEventListener("mouseenter", function(e) {
							vcOptHint.style.css("z-index", "5");
							each.style.addClass("importan");
						});
						vcOptHint.addEventListener("mouseleave", function(e) {
							vcOptHint.style.removeStyle("z-index");
							each.style.removeClass("importan");
						});
					}
		//			}
		
				});
		
			} else {
		
				vaClassInfoHints.forEach(function(each) {
					each.dispose();
				});
		
			}
		}
		
		/**
		 *
		 * @param {cpr.core.AppInstance} _app
		 * @param {Boolean} bools
		 */
		HintKit.prototype.configGridInfoHints = function(_app, bools) {
			if (bools) {
		
				var vcContainer = _app.getContainer();
				var voViewPortRect = vcContainer.getViewPortRect();
				vcContainer.getAllRecursiveChildren().forEach(function( /** cpr.controls.UIControl*/ each, idx) {
		
					if (each instanceof cpr.controls.Grid) {
		
		//				if(each.userAttr("useGridHintMode") == "true") {
						var vaRowHeights = each.header.getRowHeights();
						var vaDetailHeights = each.detail.getRowHeights();
						var gridAR = each.getActualRect();
		
						var topRight = gridAR.topLeft;
						var trY = topRight.y;
		//				var trX = topRight.x;
						var topLeft = gridAR.topLeft;
		
						var totalHeights = vaRowHeights.concat(vaDetailHeights);
		
						var width = 40;
						var height = 40;
		
						totalHeights.forEach(function(eachs) {
							if (eachs.height) {
		
								var horizontal = _createHorizontal();
		
								vcContainer.floatControl(horizontal, {
									"width": width + "px",
									"height": eachs.height + "px",
									"left": topRight.x + "px",
									"top": trY + voViewPortRect.top + "px"
								});
								var hints = _createHintBox(vcContainer, eachs.height+"px",{
									"left" : topRight.x + "px",
									"top" : trY + voViewPortRect.top + 20 +"px"
								});
		
								trY += eachs.height;
							}
							vaGridInfoHints.push(horizontal);
							vaGridInfoHints.push(hints);
						});
						//푸터 높이 구하는 스크립트
						var vaFootrerHeights = each.footer.getRowHeights();
						if (vaFootrerHeights.length > 0) {
							var voFooterDiv = document.querySelector(".cl-grid-footer");
							var footerRect = voFooterDiv.getBoundingClientRect();
		
							vaFootrerHeights.forEach(function(eachF) {
								if (eachF.height) {
		
									var horizontal = _createHorizontal();
									vcContainer.floatControl(horizontal, {
										"width": width + "px",
										"height": eachF.height + "px",
										"left": topRight.x  + "px",
										"top":footerRect.y+"px"
									});
									var hints = _createHintBox(vcContainer, eachF.height+"px", {
										"left" : topRight.x  +"px",
										"top" : footerRect.y + voViewPortRect.top + 20 +"px"
									})
								}
								vaGridInfoHints.push(horizontal);
								vaGridInfoHints.push(hints);
							});
						}
		
					}
				});
			} else {
		
				vaGridInfoHints.forEach(function(each) {
					each.dispose();
				});
			}
		
		};
		
		/**
		 * 컨트롤이 가지고있는 스타일 상세를 알고싶을 때 사용할 예정
		 * @param {cpr.core.AppInstance} _app
		 * @param {Boolean} bools
		 */
		HintKit.prototype.configStyleInfoHint = function(_app, bools) {
		
		
		}
		
		/**
		 * 컨테이너 위주의 단위를 보여줄때 Container내부 컨트롤 간의 spacing, margin 등등
		 * @param {cpr.core.AppInstance} _app
		 * @param {Boolean} bools
		 */
		HintKit.prototype.configConstriantInfoHints = function(_app, bools) {
			if (bools) {
		
				var vcContainer = _app.getContainer();
				var voViewPortRect = vcContainer.getViewPortRect();
		
				var vaContainerChild = vcContainer.getChildren().filter(function(each){
					return each instanceof cpr.controls.Container;
				});
				vaContainerChild.forEach(function( /** cpr.controls.Container*/ each) {
		
						var voLayout = each.getLayout();
						if(voLayout instanceof cpr.controls.layouts.XYLayout) {
		
							var children = each.getChildren();
							var child = children[0];
							var verticalSpacing = 0;
							var horizontalSpacing = 0;
		
							for (var idx = 1 ; idx < each.getChildrenCount() ; idx++) {
		
								if(children[idx].getOffsetRect().left - child.getOffsetRect().right > 0) {
		
									if(verticalSpacing != children[idx].getOffsetRect().left - child.getOffsetRect().right) {
		
										verticalSpacing = children[idx].getOffsetRect().left - child.getOffsetRect().right;
		
										var spacing = _createVertical();
		//								spacing.optValue = verticalSpacing;
										each.floatControl(spacing,{
											"width" : verticalSpacing+"px",
											"height" : "20px",
											"top" : child.getOffsetRect().top + "px",
											"left": child.getOffsetRect().right + "px"
										});
											spacing.addEventListener("mouseenter", function(e) {
		
												each.style.addClass("importan");
											});
											spacing.addEventListener("mouseleave", function(e) {
												each.style.removeClass("importan");
											});
										var hintSpacing = _createHintBox(vcContainer, verticalSpacing+"px",{
											"top" : child.getOffsetRect().top+ 20 +"px",
											"left" : child.getOffsetRect().right + "px"
										});
		
										vaConstraintInfoHints.push(hintSpacing);
										vaConstraintInfoHints.push(spacing);
									}
								}
		
								if(children[idx].getOffsetRect().top - child.getOffsetRect().top  > 0) {
		
									if(horizontalSpacing != children[idx].getOffsetRect().top - child.getOffsetRect().top) {
		
										horizontalSpacing = children[idx].getOffsetRect().top - child.getOffsetRect().bottom;
		
										var spacing = _createHorizontal();
										each.floatControl(spacing,{
											"width" : "20px",
											"height" : horizontalSpacing + "px",
											"top" : children[idx].getOffsetRect().top-horizontalSpacing+"px",
											"left" : children[idx].getOffsetRect().left+ "px"
										});
										spacing.addEventListener("mouseenter", function(e) {
		
											each.style.addClass("importan");
										});
										spacing.addEventListener("mouseleave", function(e) {
											each.style.removeClass("importan");
										});
										var hintSpacing2 = _createHintBox(vcContainer, verticalSpacing+"px",{
											"top" : children[idx].getOffsetRect().top-horizontalSpacing + 20 +"px",
											"left" : children[idx].getOffsetRect().left + "px"
										});
		
										vaConstraintInfoHints.push(hintSpacing2);
										vaConstraintInfoHints.push(spacing);
									}
								}
		
								child = children[idx];
		
							}
						}
						else if(voLayout instanceof cpr.controls.layouts.FormLayout) {
							var horizontalSpacing = voLayout.horizontalSpacing;
							var horizontalMargin = voLayout.horizontalMargin;
							var verticalSpacing = voLayout.verticalSpacing;
							var verticalMargin = voLayout.verticalMargin;
		
							var marginHorizontal = _createHorizontal();
							each.floatControl(marginHorizontal, {
								"width" :  "40px",
								"height" : horizontalMargin,
								"left" : "calc(50%)",
								"top" : "0px"
							});
							marginHorizontal.addEventListener("mouseenter", function(e){
		
								each.style.addClass("importan");
							});
							marginHorizontal.addEventListener("mouseleave", function(e){
								each.style.removeClass("importan");
							});
							var hintMH = _createHintBox(each, horizontalMargin,{
								"top" : "10px",
								"left" : "calc(50%)"
							});
							vaConstraintInfoHints.push(hintMH);
							vaConstraintInfoHints.push(marginHorizontal);
		
							var spacingHorizontal = _createHorizontal();
							each.floatControl(spacingHorizontal, {
								"width" : "30px",
								"height" : horizontalSpacing,
								"left" : "calc(30%)",
								"top" : each.getChildren()[0].getOffsetRect().bottom +"px"
							});
							spacingHorizontal.addEventListener("mouseenter", function(e){
								each.style.addClass("importan");
							});
							spacingHorizontal.addEventListener("mouseleave", function(e){
								each.style.removeClass("importan");
							});
							var hintSH = _createHintBox(each, horizontalSpacing,{
								"top" : each.getChildren()[0].getOffsetRect().bottom +10+"px",
								"left" : "calc(30%)"
							});
							vaConstraintInfoHints.push(hintSH);
							vaConstraintInfoHints.push(spacingHorizontal);
		
							var marginVertical = _createVertical();
							each.floatControl(marginVertical,{
								"width" : verticalMargin,
								"height" : "30px",
								"left" : "0px",
								"top" : horizontalMargin
							});
							marginVertical.addEventListener("mouseenter", function(e){
		
								each.style.addClass("importan");
							});
							marginVertical.addEventListener("mouseleave", function(e){
								each.style.removeClass("importan");
							});
							var hintMV = _createHintBox(each, verticalMargin,{
								"top" : "0px",
								"left" : horizontalMargin
							});
							vaConstraintInfoHints.push(hintMV);
							vaConstraintInfoHints.push(marginVertical);
							var spacingVertical = _createVertical();
							each.floatControl(spacingVertical,{
								"width" : verticalSpacing,
								"height" : "30px",
								"left" : each.getChildren()[0].getOffsetRect().right+"px",
								"top" : "10px"
							});
							spacingVertical.addEventListener("mouseenter", function(e){
		
								each.style.addClass("importan");
							});
							spacingVertical.addEventListener("mouseleave", function(e){
								each.style.removeClass("importan");
							});
							var hintSV = _createHintBox(each, verticalSpacing,{
								"top" : "20px",
								"left" : each.getChildren()[0].getOffsetRect().right+"px"
							});
							vaConstraintInfoHints.push(hintSV);
							vaConstraintInfoHints.push(spacingVertical);
		
							voLayout.getRows().some(function(eachs,idx){
								if(voLayout.isUseRowShade(idx)) {
									var vsClass = "";
									each.style.getClasses().forEach(function(clas){
										vsClass +="." + clas
									});
									var rowShade = getComputedStyle(document.querySelector(vsClass+" .cl-formlayout-row-shade")).backgroundColor;
									var vsRowShadeColor = rgbToHex(rowShade);
		//
									var hintRSC =_createHintBox(each, vsRowShadeColor,{
										"top" : eachs,
										"left" : "calc(10%)"
									});
									vaConstraintInfoHints.push(hintRSC);
									return each;
								}
							});
		
							voLayout.getColumns().some(function(eachs,idx){
								if(voLayout.isUseColumnShade(idx)) {
									var vsClass = "";
									each.style.getClasses().forEach(function(clas){
										vsClass += "." + clas;
									});
									var columnShade = getComputedStyle(document.querySelector(vsClass+" .cl-formlayout-column-shade")).backgroundColor;
									var vsColumnShadeColor = rgbToHex(columnShade);
		
									var hintCSC = _createHintBox(each,vsColumnShadeColor,{
										"bottom" : "calc(5%)",
										"left" : eachs
									});
									vaConstraintInfoHints.push(hintCSC);
									return each;
								}
							});
		
						}
						else if(voLayout instanceof cpr.controls.layouts.VerticalLayout) {
		
							var topHorizontal = _createHorizontal();
							each.floatControl(topHorizontal, {
								"width" : "40px",
								"height" : voLayout.topMargin+"px",
								"top" : "0px",
								"left" : "calc(50%)"
							});
							topHorizontal.addEventListener("mouseenter", function(e) {
		
								each.style.addClass("importan");
							});
							topHorizontal.addEventListener("mouseleave", function(e) {
								each.style.removeClass("importan");
							});
							var hintTH = _createHintBox(each, voLayout.topMargin+"px",{
								"top" : "0px",
								"left" : "calc(50%)"
							});
							vaConstraintInfoHints.push(hintTH);
							vaConstraintInfoHints.push(topHorizontal);
		
							var bottomHorizontal = _createHorizontal();
							each.floatControl(bottomHorizontal, {
								"width" : "40px",
								"height" : voLayout.bottomMargin+"px",
								"bottom" : "0px",
								"left" : "calc(50%)"
							});
							bottomHorizontal.addEventListener("mouseenter", function(e) {
		
								each.style.addClass("importan");
							});
							bottomHorizontal.addEventListener("mouseleave", function(e) {
								each.style.removeClass("importan");
							});
							var hintBH = _createHintBox(each, voLayout.bottomMargin+"px",{
								"left" : "calc(50%)",
								"bottom" : "0px"
							});
							vaConstraintInfoHints.push(hintBH);
							vaConstraintInfoHints.push(bottomHorizontal);
		
							var spacingHorizontal = _createHorizontal();
							each.floatControl(spacingHorizontal, {
								"width" : "40px",
								"height" : voLayout.spacing+"px",
								"top" : each.getFirstChild().getActualRect().bottom + "px",
								"left" : "calc(50%)"
							});
							spacingHorizontal.addEventListener("mouseenter", function(e) {
		
								each.style.addClass("importan");
							});
							spacingHorizontal.addEventListener("mouseleave", function(e) {
								each.style.removeClass("importan");
							});
							var hintSH = _createHintBox(each, voLayout.spacing+"px",{
								"top" : each.getFirstChild().getActualRect().bottom + 10 + "px",
								"left" : "calc(50%)"
							});
							vaConstraintInfoHints.push(hintSH);
							vaConstraintInfoHints.push(spacingHorizontal);
		
							var leftVertical = _createVertical();
							each.floatControl(leftVertical, {
								"width" : voLayout.leftMargin+"px",
								"height" : "30px",
								"left" : "0px",
								"top" : "calc(50%)"
							});
							leftVertical.addEventListener("mouseenter", function(e) {
		
								each.style.addClass("importan");
							});
							leftVertical.addEventListener("mouseleave", function(e) {
								each.style.removeClass("importan");
							});
							var hintLV = _createHintBox(each, voLayout.leftMargin+"px",{
								"top" : "calc(50%)",
								"left" : "0px"
							});
							vaConstraintInfoHints.push(hintLV);
							vaConstraintInfoHints.push(leftVertical);
		
							var rightVertical = _createVertical();
							each.floatControl(rightVertical,{
								"width" : voLayout.rightMargin +"px",
								"height": "30px",
								"right" : "0px",
								"top" : "calc(50%)"
							});
							rightVertical.addEventListener("mouseenter", function(e) {
		
								each.style.addClass("importan");
							});
							rightVertical.addEventListener("mouseleave", function(e) {
								each.style.removeClass("importan");
							});
							var hintRV = _createHintBox(each, voLayout.rightMargin+"px",{
								"top" : "calc(50%)",
								"right" : "0px"
							});
							vaConstraintInfoHints.push(hintRV);
							vaConstraintInfoHints.push(rightVertical);
		
						}
						else if(voLayout instanceof cpr.controls.layouts.FlowLayout) {
		
							var spacingHorizontal = _createHorizontal();
							var firstChild = each.getFirstChild();
							each.floatControl(spacingHorizontal,{
								"width" : "40px",
								"height" : voLayout.spacing +"px",
								"top" : firstChild.getActualRect().bottom + "px",
								"left" : firstChild.getActualRect().bottomCenter.x +"px"
							});
		
							vaConstraintInfoHints.push(spacingHorizontal);
							var spacingVertical = _createVertical();
		
							each.floatControl(spacingVertical,{
								"width" : voLayout.spacing + "px",
								"height" : "40px",
								"top" : firstChild.getActualRect().top +"px",
								"left" : firstChild.getActualRect().right +"px"
							});
							vaConstraintInfoHints.push(spacingVertical);
						}
		//			}
		
				});
			} else {
				vaConstraintInfoHints.forEach(function(each){
					each.dispose();
				});
			}
		
		}
		
		function rgbToHex(rgbType) {
			  var rgb = rgbType.replace( /[^%,.\d]/g, "" );
		        // 쉼표(,)를 기준으로 분리해서, 배열에 담기.
		        rgb = rgb.split( "," );
		
		  return "#" + Number(rgb[0]).toString(16) + Number(rgb[1]).toString(16) + Number(rgb[2]).toString(16);
		}
		
		
		/**
		 *
		 * @param {cpr.controls.Container} vcContainer
		 * @param {String} values
		 * @param {cpr.controls.layouts.Constraint} Constraint
		 */
		function _createHintBox(vcContainer,values,Constraint){
			var vcOptHint = new cpr.controls.Output();
						vcOptHint.value = values;
						vcOptHint.unselectable = false;
		//				vcOptHint.style.setClasses("hint-box");
						vcContainer.floatControl(vcOptHint,Constraint);
		//				vaClassInfoHints.push(vcOptHint);
		
						vcOptHint.addEventListener("mouseenter", function(e) {
							vcOptHint.style.css("z-index", "5");
						});
						vcOptHint.addEventListener("mouseleave", function(e) {
							vcOptHint.style.removeStyle("z-index");
						});
				return vcOptHint;
		}
		
		function _createHorizontal() {
		
			var group_1 = new cpr.controls.Container();
			group_1.style.css({
				"border-top-width": "1px",
				"border-bottom-color": "red",
				"border-bottom-width": "1px",
				"border-top-color": "red",
				"border-bottom-style": "solid",
				"border-top-style": "solid"
			});
			// Layout
			var formLayout_1 = new cpr.controls.layouts.FormLayout();
			formLayout_1.topMargin = "0px";
			formLayout_1.rightMargin = "0px";
			formLayout_1.bottomMargin = "0px";
			formLayout_1.leftMargin = "0px";
			formLayout_1.horizontalSpacing = "0px";
			formLayout_1.verticalSpacing = "0px";
			formLayout_1.verticalSeparatorWidth = 1;
			formLayout_1.verticalSeparatorColor = "red";
			formLayout_1.setColumns(["1fr", "1fr"]);
			formLayout_1.setRows(["1fr"]);
			group_1.setLayout(formLayout_1);
			(function(container) {})(group_1);
		
			return group_1;
		}
		
		function _createVertical() {
		
			var group_2 = new cpr.controls.Container();
			group_2.style.css({
				"border-right-style": "solid",
				"border-right-width": "1px",
				"border-left-style": "solid",
				"border-left-color": "red",
				"border-right-color": "red",
				"border-left-width": "1px"
			});
			// Layout
			var formLayout_2 = new cpr.controls.layouts.FormLayout();
			formLayout_2.topMargin = "0px";
			formLayout_2.rightMargin = "0px";
			formLayout_2.bottomMargin = "0px";
			formLayout_2.leftMargin = "0px";
			formLayout_2.horizontalSpacing = "0px";
			formLayout_2.verticalSpacing = "0px";
			formLayout_2.horizontalSeparatorWidth = 1;
			formLayout_2.horizontalSeparatorColor = "red";
			formLayout_2.setColumns(["1fr"]);
			formLayout_2.setRows(["1fr", "1fr"]);
			group_2.setLayout(formLayout_2);
			(function(container) {})(group_2);
		
			return group_2;
		}
		/**
		 *
		 * @param {cpr.core.AppInstance} _app
		 * @param {Boolean} bools
		 */
		HintKit.prototype.showFormDivision = function(_app,bools){
		
			var voAppIns = _app;
		
			voAppIns.getContainer().getAllRecursiveChildren().forEach(function(/*cpr.controls.Control*/each){
		
				if(each instanceof cpr.controls.Container) {
		
					if(each.getLayout() instanceof cpr.controls.layouts.FormLayout) {
		
						drawHorizontalPlan(each,bools);
						drawVerticalPlan(each,bools);
					}
				}
			});
		}
		/**
		 *
		 * @param {cpr.controls.layouts.FormLayout} layout
		 */
		function calcWidthFr(layout){
		
			var lay = layout;
		
		
			var cols = lay.getColumns();//컬럼 구획 크기 가져오기
			var colSp = lay.horizontalSpacing;//가로 간격
			var leftM = lay.leftMargin;//좌 여백
			var rightM = lay.rightMargin;//우 여백
		
			var corFr = cols.filter(function(each){
				return each.indexOf("fr") >=0;
			});
			corFr = corFr.map(function(each){
				return parseInt(each.replace("fr", ""));
			});
			var res = 0 ;
			corFr.forEach(function(each){
				res+= each;
			});
					//컬럼 구획 fr인 애들 전부 더하기
		
			if(leftM.indexOf("fr") >=0) {
		
				res += parseInt(leftM.replace("fr", ""));
			}//좌 마진이 fr이면 더하기
			if(rightM.indexOf("fr") >= 0) {
		
				res += parseInt(rightM.replace("fr",""));
			}//우 마진이 fr이면 더하기
		
			if(colSp.indexOf("fr") >= 0) {
		
				res += parseInt(colSp.replace("fr", "")) * (cols.length -1)
			}//간격이 fr이면 간격만큼 더하기
		
			return res;
		}
		
		/**
		 *
		 * @param {cpr.controls.layouts.FormLayout} layout
		 */
		function calcHeightFr(layout) {
		
			var lay = layout;
		
			var rows = lay.getRows();
			var rowSp = lay.verticalSpacing;
			var topM = lay.topMargin;
			var botM = lay.bottomMargin;
		
			var rowFr = rows.filter(function(each){
				return each.indexOf("fr") >=0;
			});
		
			rowFr = rowFr.map(function(each){
				return parseInt(each.replace("fr", ""));
			});
		
			var res = 0;
			rowFr.forEach(function(each){
				res += each;
			});
			if(topM.indexOf("fr") >=0) {
		
				res += parseInt(topM.replace("fr", ""));
			}//좌 마진이 fr이면 더하기
			if(botM.indexOf("fr") >= 0) {
		
				res += parseInt(botM.replace("fr",""));
			}//우 마진이 fr이면 더하기
		
			if(rowSp.indexOf("fr") >= 0) {
		
				res += parseInt(rowSp.replace("fr", "")) * (rows.length -1)
			}//간격이 fr이면 간격만큼 더하기
		
			return res;
		}
		
		var horizontals = [];
		
		/**
		 *
		 * @param {cpr.controls.Container} pcContainer
		 * @param {Boolean} pb
		 */
		function drawHorizontalPlan(pcContainer,pb){
			if(pb) {
		
			var grp = pcContainer;
		/** @type cpr.controls.layouts.FormLayout */
			var layouts = grp.getLayout();
			var allFr = calcWidthFr(layouts);
			var cols = layouts.getColumns();
		
			var width = grp.getActualRect().width;
		
			var colPx = cols.filter(function(each){
				return each.indexOf("px") >= 0;
			});
			var survivedWidth = width;
		
			colPx.forEach(function(each){
				var pxWidth = parseInt(each.replace("px",""));
		
				survivedWidth -= pxWidth;
			});
		
			if(layouts.rightMargin.indexOf("px") >= 0){
				survivedWidth -= parseInt(layouts.rightMargin.replace("px", ""));
			}
		
			var startMan = grp.getActualRect().left;
			var margin = 0;
			if(layouts.leftMargin.indexOf("fr") >= 0 ) {
				margin = survivedWidth * parseInt(layouts.leftMargin.replace("fr","")) / allFr;
				startMan += margin
			} else {
				survivedWidth -= parseInt(layouts.leftMargin.replace("px",""));
				margin = parseInt(layouts.leftMargin.replace("px", ""));
				startMan += margin;
			}
		
			var spacing = 0;
			if(layouts.horizontalSpacing.indexOf("fr") >= 0 ) {
				spacing = survivedWidth * parseInt(layouts.horizontalSpacing.replace("fr","")) / allFr;
			} else {
				spacing = parseInt(layouts.horizontalSpacing.replace("px", ""));
				survivedWidth -= parseInt(layouts.horizontalSpacing.replace("px",""))*(cols.length-1);
			}
		
			cols.forEach(function(each){
				var button = new cpr.controls.Button();
				button.value = each;
				button.style.addClass("btn-outline-light");
				var constraint = {
					"left" : startMan+"px",
					"top" : grp.getActualRect().bottom+"px",
					"width" : "",
					"height" : "25px"
				}
				if(each.indexOf("fr") >= 0) {
		
					constraint.width = survivedWidth * parseInt(each.replace("fr", "")) / allFr +"px";
				} else {
		
					constraint.width = each;
				}
		
				pcContainer.getAppInstance().getContainer().floatControl(button, constraint);
				horizontals.push(button);
				startMan += parseInt(constraint.width.replace("px", "")) + spacing
		 	});
		 	} else {
		
		 		horizontals.forEach(function(each){
		 			each.dispose();
		 		})
		 	}
		}
		
		
		var verticals = [];
		/**
		 *
		 * @param {cpr.controls.Container} pcContainer
		 * @param {Boolean} pb
		 */
		function drawVerticalPlan(pcContainer,pb) {
			if(pb){
		
			var grp = pcContainer;
		/** @type cpr.controls.layouts.FormLayout */
			var layouts = grp.getLayout();
			var allFr = calcHeightFr(layouts);
			var rows = layouts.getRows();
			var height = grp.getActualRect().height;
		
			var rowPx = rows.filter(function(each){
				return each.indexOf("px") >= 0;
			});
			var survivedHeight = height;
		
			rowPx.forEach(function(each){
				var psHeight = parseInt(each.replace("px",""));
		
				survivedHeight -= psHeight;
			});
		
			if(layouts.bottomMargin.indexOf("px") >= 0){
				survivedHeight -= parseInt(layouts.bottomMargin.replace("px", ""));
			}
		
			var startMan = grp.getActualRect().top;
			var margin = 0;
			if(layouts.topMargin.indexOf("fr") >= 0 ) {
				margin = survivedHeight * parseInt(layouts.topMargin.replace("fr","")) / allFr;
				startMan += margin
			} else {
				survivedHeight -= parseInt(layouts.topMargin.replace("px",""));
				margin = parseInt(layouts.topMargin.replace("px", ""));
				startMan += margin;
			}
		
			var spacing = 0;
			if(layouts.verticalSpacing.indexOf("fr") >= 0 ) {
				spacing = survivedHeight * parseInt(layouts.verticalSpacing.replace("fr","")) / allFr;
			} else {
				spacing = parseInt(layouts.verticalSpacing.replace("px", ""));
				survivedHeight -= parseInt(layouts.verticalSpacing.replace("px",""))*(rows.length-1);
			}
		
			rows.forEach(function(each){
				var button = new cpr.controls.Button();
				button.value = each;
				button.style.addClass("btn-outline-light");
				var constraint = {
					"left" : grp.getActualRect().right+"px",
					"top" : startMan+"px",
					"width" : "100px",
					"height" : ""
				}
				if(each.indexOf("fr") >= 0) {
		
					constraint.height = survivedHeight * parseInt(each.replace("fr", "")) / allFr +"px";
				} else {
		
					constraint.height = each;
				}
		
				pcContainer.getAppInstance().getContainer().floatControl(button, constraint);
				verticals.push(button);
				startMan += parseInt(constraint.height.replace("px", "")) + spacing
		 	});
		 	} else {
		
		 		verticals.forEach(function(each){
		
		 			each.dispose();
		 		});
		 	}
		}
		
		function createNewHintKit() {
			return new HintKit();
		}
		globals.createNewHintKit = createNewHintKit;
	});
})();
/// end - hintViewSave
/// start - languageTransfer
/*
 * Module URI: languageTransfer
 * SRC: languageTransfer.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("languageTransfer", function(exports, globals, module){
		///************************************************
		// * languageTransfer.module.js
		// * Created at 2020. 4. 27. 오전 9:40:22.
		// *
		// * @author HANS
		// ************************************************/
		//
		//
		//var useTranslate = false;
		//
		///**
		// * 다국어 변환 기능 사용여부를 설정할 수 있습니다. 
		// * @param {any} pBool
		// */
		//globals.setUseTranslate = function(pBool){
		//	useTranslate = pBool;
		//};
		//
		///**
		// * 다국어 변환 기능을 사용 여부를 반환 받습니다.
		// */
		//globals.getUseTranslate = function(){
		//	return useTranslate;
		//}
		//
		//var vsLangCode = "ko";
		//
		///**
		// * 다국어 변환할 언어코드를 설정합니다.
		// * @param {cpr.core.AppInstance} _app
		// * @param {"ko"|"en"} psLangCode
		// */
		//globals.setLanguageCode = function(_app,psLangCode) {
		//	
		//	vsLangCode = psLangCode;
		//	
		//	//2020.07/27 조한진. 임시 스크립트 추가
		////	var vcContainer = _app.getContainer();
		////	
		////	var vaChildren = vcContainer.getAllRecursiveChildren().filter(function(each){
		////		return  each.getBindInfo("value") === undefined;
		////	});
		////	
		////	var voLocaleData = cpr.I18N.INSTANCE.getLocaleData(vsLangCode);
		////	
		////	vaChildren.forEach(function(each,idx){
		////		
		////		if(!ValueUtil.isNull(voLocaleData[each.value])) {
		////			each.value = voLocaleData[each.value];
		////		}
		////	});
		////	vcContainer.redraw();
		//}
		//
		///**
		// * 다국어 변환 언어코드를 반환 받습니다.
		// */
		//globals.getLanguageCode = function(){
		//	
		//	return vsLangCode;
		//}
		//
		//cpr.events.EventBus.INSTANCE.addFilter("init", function(e) {
		//	var control = e.control;
		//
		//	if (useTranslate) {
		//
		//		if (control instanceof cpr.core.AppInstance) {
		//
		//			var vcContainer = control.getContainer();
		//
		//			var vaChildren = vcContainer.getAllRecursiveChildren().filter(function(each) {
		//				return each.getBindInfo("value") === undefined;
		//			});
		//
		//			var localeData = cpr.I18N.INSTANCE.getLocaleData(vsLangCode);
		//
		//			vaChildren.forEach(function(each, idx) {
		//				
		//				if(!ValueUtil.isNull(localeData[each.value])){
		//					
		//					each.value = localeData[each.value];
		//				}
		//
		//			});
		//		}
		//	}
		//});
	});
})();
/// end - languageTransfer
/// start - module/changer2
/*
 * Module URI: module/changer2
 * SRC: module/changer2.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/changer2", function(exports, globals, module){
		///************************************************
		// * changer.module.js
		// * Created at 2021. 4. 12. 오후 1:17:51.
		// *
		// * @author HANS
		// ************************************************/
		//// 의존 모듈 선언.
		//module.depends("module/swiper_mobile");
		//var mob = cpr.core.Module.require("module/swiper_mobile");
		//var originConstraint;
		//var originParent;
		//var slid ;
		//cpr.events.EventBus.INSTANCE.addFilter("screen-change", function(e) {
		//	var control = e.control;
		//	if (control instanceof cpr.core.AppInstance) {
		//		
		//		if (control.id.indexOf("udc") != 0) {
		//			
		//			/** @type cpr.controls.Container[]*/
		//			var vaSwipedContainer = control.getContainer().getAllRecursiveChildren().filter(function(ele) {
		//				if (ele.userAttr("mobile-swiped") == "true") {
		//					
		//					return ele;
		//				}
		//			});
		//			
		//			if(vaSwipedContainer.length < 1) {
		//				return;
		//			}
		//			var btns = vaSwipedContainer[0].getParent().getAllRecursiveChildren().find(function(ele){
		//				if(ele.id =="btnFamilyInsert"){
		//					return ele;
		//				}
		//			});
		//			
		//		
		//			if (e.screen.name != "default") {
		//				cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function() {
		//						if(btns) {
		//				console.log("ztz");
		//				originConstraint = btns.getParent().getConstraint(btns);
		//				originParent = btns.getParent();
		//			}
		//					if (vaSwipedContainer[0].getLayout() instanceof cpr.controls.layouts.VerticalLayout) {
		//						vaSwipedContainer.forEach(function(each) {
		//							
		//							var vcSwipedContainer = each;
		////							var voConst = vcSwipedContainer.getParent().getConstraint(vcSwipedContainer);
		////							var vcSwipedContainer = new cpr.controls.Container();
		////							vcSwipedContainer.style.setClasses("card-group vertical");
		////							vcSwipedContainer.userAttr("mobile-swiped", "true");
		//							var voFlowLayout = new cpr.controls.layouts.FlowLayout();
		//							voFlowLayout.scrollable = false;
		//							voFlowLayout.lineWrap = false;
		//							voFlowLayout.spacing = 0;
		//							vcSwipedContainer.setLayout(voFlowLayout);
		////							vcSwipedContainer.getParent().addChild(vcSwipedContainer, voConst);
		//							var vnOriginChildLength = vcSwipedContainer.getChildren().length;
		//							var visier;
		//							vcSwipedContainer.getChildren().forEach(function(each, idx) {
		//								var han = each.getParent().getConstraint(each);
		//								if (vnOriginChildLength - 1 <= idx) {
		//									each.addChild(btns,{
		//										"width": "100px",
		//										"height": "35px",
		//										"autoSize": "none"
		//									})
		////									vcSwipeCtrl.addChild(each, han);
		//								} else {
		////									each.visible = false;
		////									visier = each;
		//								}
		//									vcSwipedContainer.addChild(each, han);
		//								
		//							});
		//							
		//
		////							vcSwipedContainer.dispose();
		//							cpr.core.DeferredUpdateManager.INSTANCE.asyncExec(function() {
		//								
		//								slid = mob.slidify(vcSwipedContainer);
		//								slid.showCount = 1;
		//								slid.itemSize = 0;
		//								slid.navigationButtonClassName = "slide-btn-none"
		//								slid.start();
		//								btns.addEventListener("click", function(e){
		//								var last = vcSwipedContainer.getChildren()[0];
		//								console.log(last.getLayout());
		//								last.addChild(e.control,{
		//									"width": "100px",
		//									"height": "35px",
		//									"autoSize": "none"
		//								})
		//								slid.clear();
		//								slid.initialPage = vcSwipedContainer.getChildren().length-1;
		//								slid.start();
		//							});
		////								btnq.addEventListener("click", function(e) {
		////									/** @type cpr.controls.UIControl */
		////									var ctrl = vcSwipeCtrl.getChildren()[0].getChildren()[0];
		////									var hh = visier.getParent().getConstraint(visier)
		////									vcSwipeCtrl.getChildren()[0].addChild(visier, hh);
		////									visier.visible = true;
		////									slid.clear();
		////									
		////									slid.initialPage = 3;
		////									slid.start();
		////								});
		//							});
		//						});
		//					}
		//				});
		//				
		//			} else {
		//				if (vaSwipedContainer[0].getLayout() instanceof cpr.controls.layouts.FlowLayout) {
		//					vaSwipedContainer.forEach(function(each) {
		//						var vcSwipedContainer = each;
		//						
		//						var voConstraint = vcSwipedContainer.getParent().getConstraint(vcSwipedContainer);
		//						/** @type cpr.controls.Container */
		//						var childParent = vcSwipedContainer.getChildren()[0];
		//						
		////						var vcSwipedContainer = new cpr.controls.Container();
		//						var voVerticalLayout = new cpr.controls.layouts.VerticalLayout();
		//						voVerticalLayout.spacing = 0;
		//						voVerticalLayout.scrollable = false;
		//						vcSwipedContainer.setLayout(voVerticalLayout);
		////						vcSwipedContainer.style.setClasses("card-group vertical");
		////						vcSwipedContainer.userAttr("mobile-swiped", "true");
		//						
		//						childParent.getChildren().forEach(function(each) {
		//							
		//							each.visible = true;
		//							vcSwipedContainer.addChild(each, {
		//								width: "1214px",
		//								height: "300px",
		//								autoSize: "height"
		//							});
		//						});
		//						originParent.addChild(btns,originConstraint);
		//						console.log(originParent);
		//						console.log(originConstraint);
		//						childParent.dispose();
		//						slid.disposs();
		////						vcSwipedContainer.getParent().addChild(vcSwipedContainer, voConstraint);
		////						vcSwipedContainer.dispose();
		//					});
		//				}
		//			}
		//		}
		//	}
		//});
	});
})();
/// end - module/changer2
/// start - module/comboBoxListPopup
/*
 * Module URI: module/comboBoxListPopup
 * SRC: module/comboBoxListPopup.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/comboBoxListPopup", function(exports, globals, module){
		/************************************************
		 * ComboBoxListPopup.module.js
		 * Created at 2020. 1. 23. 오전 10:27:59.
		 *
		 * @author daye
		 ************************************************/
		
		/*
		 * 본 모듈은 콤보박스 리스트가 특정 개수 이상일 경우 팝업으로 열어 확인 및 선택 할 수 있는 모듈입니다.
		 * 그룹을 제외한 컨트롤에 대해 클릭할 경우 팝업을 띄울 수 있습니다. 대상콤보박스는 fieldLabel에 작성합니다.
		 *  
		 * [fieldLabel 작성법]
		 * - 콤보박스의 fieldLabel을 팝업창의 헤더타이틀로 사용됩니다.
		 * - 콤보박스 이외의 다른 컨트롤의 fieldLabel은 타겟 콤보박스 id 를 작성합니다.
		 * 
		 * [확인사항]
		 * 콤보박스에 바인딩 되어있는 데이터셋의 컬럼은 label, value로 작성
		 * 그리드의 콤보박스는 선택행이 있는 경우에만 확인 가능
		 */
		
		
		/************************************************
		 * 사용가능 API
		 ************************************************/
		/**
		 * 모듈 사용 여부
		 * 값이 true일 경우에만 모듈을 사용한다.
		 * @type {Boolean}
		 */
		var mbCreateApp = true; 
		
		/**
		 * 모바일 전용 여부
		 *	true 일경우에 팝업이 화면 아래에 위치합니다.
		 * @type {Boolean}
		 */
		var mbMobile = true;
		
		/**
		 * 라디오버튼 (or 체크박스그룹) 의 아이템 고정너비
		 * 특정 너비를 설정하기 위해서는 넘버값을 설정하세요.
		 * 
		 * @type {Boolean|Number}
		 */
		var mnFixedWidth = false;
		
		/**
		 * 셀렉션 계열 컨트롤 [선택] 아이템 추가여부
		 * @type {Boolean}
		 */
		var mbInsertBlank = true; 
		
		/**
		 * 사용자 속성
		 * @type {String}
		 */
		var ATTR_COMBO_POP = "combo-pop";
		
		/**
		 * 다이얼로그 배경 스타일 클래스
		 * @type {String}
		 */
		var msDialogOverlayCls = "cl-overlay";
		
		/**
		 * 다이얼로그 스타일
		 * @type {String}
		 */
		var msDialogCls = "rounded-0";
		
		/**
		 * 라디오버튼 (or 체크박스그룹) 의 스타일 클래스
		 * @type {String}
		 */
		var msSelectCls = "";
		
		/**
		 * 라디오버튼 (or 체크박스그룹) 아이템의 스타일 클래스
		 * @type {String}
		 */
		var msSelectItemCls = "align-text-top";
		
		/**
		 * 다이얼로그의 [확인] 버튼 스타일 클래스
		 * @type {String}
		 */
		var msBtnConfirmCls = "btn-primary rounded-0";
		
		/**
		 * 폼레이아웃 spacing
		 * @type {Number}
		 */
		var mnFormSpacing = 0;
		
		/**
		 * [확인] 버튼 높이
		 * @type {Number}
		 */
		var mnConfirmBtnHgt = 50;
		
		/**
		 * 모바일 전용 콤보박스 팝업에서 보여지는 최대 아이템 개수
		 * 적용화면사이즈 : tablet, mobile
		 * @type {Number}
		 */
		var mnMobileList = 6;
		
		/**
		 * 팝업을 띄울 콤보박스아이템 개수
		 * 적용화면사이즈 : default
		 * @type {Number}
		 */
		var mnDftItemList =1; 
		
		/**
		 * 라디오버튼(or 체크박스그룹) 이 한 줄에 보여질 아이템 수
		 * 적용화면사이즈 : default
		 * @type {Number}
		 */
		var mnDftColCount = 6;
		
		/**
		 * 팝업 constraint 
		 * 적용화면사이즈 : default
		 */
		var moDftPopSize = {
			width: 900,
			height: 600
		};
		
		/**
		 * 팝업을 띄울 콤보박스아이템 개수
		 * 적용화면사이즈 : tablet, mobile
		 * @type {Number}
		 */
		var mnMblItemList = 0;
		
		/**
		 * 라디오버튼(or 체크박스그룹) 이 한 줄에 보여질 아이템 수
		 * 적용화면사이즈 : tablet, mobile
		 * @type {Number}
		 */
		var mnMblColCount = 1;
		
		/**
		 * 팝업 constraint 
		 * 적용화면사이즈 : tablet, mobile
		 */
		var moMblPopSize= {
			left : 0,
			right : 0,
			bottom : -100,
			height : 0
		};
		
		/**
		 * 팝업 이름
		 * @type {String}
		 */
		var msDialogName = "dialogName";
		
		/**
		 * 다이얼로그 헤더 타이틀
		 * @type {String}
		 */
		var msTempHeaderTitle = "다이얼로그 팝업";
		
		/**
		 * box-shadow 스타일
		 */
		var moBoxShadow = {
			top : "inset 0px -11px 20px -1px rgba(0,0,0,0.16)",
			bottom : "inset 11px 0px 20px -1px rgba(0,0,0,0.16)",
			middle : "inset 0px -11px 20px -1px rgba(0,0,0,0.16),  inset 11px 0px 20px -1px rgba(0,0,0,0.16)"
		}
		
		/**
		 * up, down 버튼 클래스
		 * @type {String}
		 */
		var msFloatBtnCls = "rounded-circle";
		
		/**
		 * 모바일 팝업 최대높이
		 * @type {Number}
		 */
		var mnMaxHeight = innerHeight*0.8;
		
		/**
		 * 스크롤 버튼 표시 여부 
		 * 적용화면사이즈 : tablet, mobile
		 * 
		 * @type {Boolean}
		 */
		var mbScrollButton = false;
		
		/**
		 * 스크롤 스타일(box-shadow) 표시 여부 
		 * 적용화면사이즈 : tablet, mobile
		 * @type {Boolean}
		 */
		var mbScrollStyle = false;
		
		/************************************************
		 * 내부 시스템 멤버변수 (변경X)
		 ************************************************/
		/**
		 * 앱 ID
		 * @type {String}
		 */
		var msAppId = null; 
		
		/**
		 * 앱 인스턴스
		 * @type {cpr.core.AppInstance}
		 */
		var moAppIns = null;
		
		/**
		 * 타겟 콤보박스
		 * @type {cpr.controls.ComboBox}
		 */
		var mcComboBox = null;
		
		/**
		 * 팝업이 띄워졌는지 여부
		 * @type {Boolean}
		 */
		var mbPop = false;
		
		/**
		 * 팝업을 띄울 콤보박스아이템 개수
		 * @type {Number}
		 */
		var mnList;
		
		/**
		 * 라디오버튼(or 체크박스그룹) 이 한 줄에 보여질 아이템 수
		 * @type {Number}
		 */
		var mnColCount;
		
		/**
		 * 팝업 constraint 
		 */
		var moPopSize;
		
		/************************************************
		 * 이벤트 버스 (load)
		 ************************************************/
		
		if(mbCreateApp) cpr.events.EventBus.INSTANCE.addFilter("click", fn_click);
		if(mbMobile) cpr.events.EventBus.INSTANCE.addFilter("screen-change", fn_screen_change);
		
		function fn_click (e) {
			
			var control = e.control;
			moAppIns = control.getAppInstance();
		
			// 그룹 제외
			if (control.type == "container" || moAppIns.app == null) {
				return;
			}
			// 팝업이 띄워져 있지 않은경우에만 팝업을 띄움
			if(mbPop == false) {
				// 그리드 click 시, 선택행이 없을 경우 팝업을 띄우지 않음
				if(control.type == "grid") {
					if(control.getSelectedRowIndex() == -1) {
						return;
					}
				}
				
				_setMobile(mbMobile, mbScrollButton, mbScrollStyle);
				/** @type cpr.controls.ComboBox */
				var vcTargetCombo = null;
				if(control.type == "combobox") {
					vcTargetCombo = control;
				} else {
					var vsTargetCmbId = _getTargetComboId(control);
					vcTargetCombo = moAppIns.lookup(vsTargetCmbId);
				}
				
				if((vcTargetCombo != null && vcTargetCombo.type == "combobox")) {
					if(vcTargetCombo.userAttr(ATTR_COMBO_POP) == "true") {
						control.preventInput = true;
					
						// 콤보박스 아이템 개수보다 mnCmbItem이 많으면 팝업 띄우지 않음
						var vnItemCnt = vcTargetCombo.getItemCount();
						 if(!mbMobile && vnItemCnt <= mnList) {
							
							// 그리드 안의 콤보박스는 편집행일 경우에만 open 할 수 있음
							if(vcTargetCombo.getParent().type == "grid") {
		
								/** @type cpr.controls.Grid */
								var vcGrid = vcTargetCombo.getParent();
								var vnSelectedRowIndex = vcGrid.getSelectedRowIndex();
								vcGrid.setEditRowIndex(vnSelectedRowIndex);
							}
							
							// FIXME 그리드안의 콤보박스가 팝업이 아닌 open 될경우 아래 코드 주석을 해제하십시오.
		//					cpr.core.DeferredUpdateManager.INSTANCE.update();
							control.preventInput = false;
							vcTargetCombo.open();
							vcTargetCombo.focus();
							return;
						}
						
						cpr.core.DeferredUpdateManager.INSTANCE.update();
						_floatPop(control);
					}
					
				}
			}
		}
		
		/**
		 * 
		 * @param {cpr.events.CScreenChangeEvent} e
		 */
		function fn_screen_change (e) {
			var screen = e.screen.name;
			
			if(screen == "default") {
				_setMobile(false);
			} else {
				_setMobile(true, mbScrollButton, mbScrollStyle);
			}
		}
		
		
		/**
		 * 새로운 앱인스턴스 생성
		 */
		function _createApp() {
			
			if(moAppIns == null) {
				return;
			}
		
			msAppId = moAppIns.app.id + "ListPop";
			var newApp = new cpr.core.App(msAppId, {
				
				onPrepare: function(loader){
				},
				
				onCreate: function(/* cpr.core.AppInstance */ newApp, exports){
					var vaRows = (function(pnHeight){
						var rows = [];
						rows.push("1fr");
						rows.push(pnHeight + "px");
						return rows;
					})(mnConfirmBtnHgt)
					
					// 루트 컨테이너 레이아웃 설정 (폼레이아웃)
					var container = newApp.getContainer();
					var voFormlayout = new cpr.controls.layouts.FormLayout();
					voFormlayout.setRows(vaRows);
					voFormlayout.setColumns(["1fr"]);
					voFormlayout.verticalSpacing = mnFormSpacing + "px";
					container.setLayout(voFormlayout);
					
					// 루트 앱인스턴스 로드 이벤트 리스너
					newApp.addEventListener("load", function(e) {	
						
						var vcCtrl = newApp.getHostProperty("initValue");
						var voSelected = []; // 이전에 선택한 값
						moAppIns = vcCtrl.getAppInstance();
						
						// vsInitValue에 해당하는 타겟 콤보박스 저장
						mcComboBox = moAppIns.getContainer().getAllRecursiveChildren().map(function(each){
							var vcCombo = null;
							if(vcCtrl.type == "combobox" && each == vcCtrl) {
								vcCombo = each;
								voSelected = each.values;
							} else {
								var vsTargetId = vcCtrl.fieldLabel;
								if(each.id == vsTargetId && each.type == "combobox") {
									vcCombo = each;
									voSelected = each.values;
								}
							}
							
							// 그리드에 포함되어있는 콤보박스일 경우
							if(vcCombo && vcCombo.getParent().type == "grid") {
								/** @type cpr.controls.Grid */
								var vcGrid = each.getParent();
								var vnSelectedIndex = vcGrid.getSelectedRowIndex();
								
								for(var idx = 0; idx < vcGrid.detail.cellCount; idx++) {
									if(vcGrid.detail.getControl(idx) == each) {
										voSelected = [vcGrid.getCellValue(vnSelectedIndex, idx)];
									}
								}
							}
							
							return vcCombo;
						}).filter(function(each){
							if(each) return each;
						})[0];
						
						if(mcComboBox == null) return;
						
						var vbMultiple = mcComboBox.multiple; // 콤보박스의 multiple 속성값
		
						/*
						 * ---------------------------- start ----------------------------
						 * 드롭다운 리스트 아이템을 보여주기 위함 컨트롤 배치
						 */
						// 1. 셀렉션 계열 컨트롤을 감싸는 그룹 생성(버티컬 레이아웃)
						var vcGroup = new cpr.controls.Container();
						var voVerticalLayout = new cpr.controls.layouts.VerticalLayout();
						vcGroup.setLayout(voVerticalLayout);
						
						// 2. 셀렉션 계열 컨트롤 생성 (라디오, 체크박스그룹)
						var vcSelection = null;
						if(vbMultiple == true) {
							vcSelection = new cpr.controls.CheckBoxGroup(); // 다중선택
						} else {
							vcSelection = new cpr.controls.RadioButton(); // 단일선택
						}
						
						// 3. 셀렉션 계열 컨트롤 속성 및 스타일 설정
						/*
						 * 아래 기능은 2021-01-29 릴리즈 버전 이후부터 사용 가능합니다
						 * 		- 라디오버튼(or 체크박스그룹) 아이템의 너비를 고정너비로 설정합니다.
						 * 		- 각 아이템의 텍스트에 말줄임 스타일을 적용하기 위해서 아이템을 반드시 고정너비로 설정해야 합니다.
						 */
						vcSelection.fixedWidth = mnFixedWidth;
						
						// TODO 한 행에 보여줄 아이템 개수
						vcSelection.colCount = mnColCount;
		
						// TODO 컨트롤의 스타일 변경
						// 1) 컨트롤 스타일
						vcSelection.style.addClass(msSelectCls);
		
						// 2) 컨트롤 아이템 스타일
						vcSelection.style.item.addClass(msSelectItemCls);
						
						// 4. 데이터셋 생성
						var vcComboDataSet = new cpr.data.DataSet();
						var voRow = [];
						mcComboBox.getItems().forEach(function(each){
							voRow.push({
								"label": each.label,
								"value": each.value
							});
						});
						vcComboDataSet.parseData({
							"columns" : [
								{"name": "label"},
								{"name": "value"}
							],
							"rows" : voRow
						});
						
						// 5. 라디오버튼일 때, 공백 아이템 추가
						if(mbInsertBlank && vcSelection.type == "radiobutton" && mcComboBox.getItemCount() > 0) { 
							vcComboDataSet.insertRowData(0, false, {
								"label" : "선택취소",
								"value" : ""
							})
						}				
						
						// 6. 셀렉션 컨트롤에 데이터셋 바인딩
						vcSelection.setItemSet(vcComboDataSet, {
							label : "label",
							value : "value",
							tooltip : "label"
						});
							
						// 7. 기존의 선택했던 값이 존재할 경우 값 설정
						if(voSelected.length != 0) {
							vcSelection.values = voSelected;
						}
						
						// 8. 컨트롤 추가
						vcGroup.addChild(vcSelection, {
							autoSize : "height"
						});
						container.addChild(vcGroup, {
							rowIndex : 0,
							colIndex : 0
						});
						/*
						 * 드롭다운 리스트 아이템을 보여주기 위함 컨트롤 배치
						 * ---------------------------- end ----------------------------
						 */
						
						// [확인] 버튼 컨트롤
						var vcButton = new cpr.controls.Button();
						vcButton.value = "확인";
						vcButton.style.addClass(msBtnConfirmCls); // 버튼 style 적용
						vcButton.addEventListener("click", function(e){
							// 콤보박스 아이템 선택 및 팝업닫힘
							newApp.close(vcSelection.values);
						});
						container.addChild(vcButton, {
							rowIndex : 1,
							colIndex : 0
						})
						
						cpr.core.DeferredUpdateManager.INSTANCE.update();
						
						/*
						 * 팝업이 열린 후 팝업 사이즈 재설정
						 * (모바일 전용 한정) 
						 */
						var dialog = newApp.getHost();
						if(dialog && dialog instanceof cpr.controls.Dialog) {
							if(mbMobile) {
								var elDialog = document.getElementById("uuid-"+dialog.uuid).querySelector(".cl-dialog-header");
								var dialogHeaderHgt = getComputedStyle(elDialog).height; // 다이얼로그 헤더 높이
								
								var vnViewItemCount = vcSelection.getItemCount();
								var vnItemCnt = vnViewItemCount <= mnMobileList ? vnViewItemCount : mnMobileList; // 다이얼로그에 최대 보여줄 아이템 개수
								var vnItemBorders = vnViewItemCount <= mnMobileList ? vnViewItemCount : 0; // 스크롤이 없는 상태에서 각 아이템 border 사이즈 추가
								
								var elSelectionItem = document.getElementById("uuid-"+vcSelection.uuid);
								var vnSelectionItemHgt = 0; // 셀력션 아이템의 높이
								if(vnViewItemCount > 0) {
									if(vbMultiple) {
										// 멀티셀렉션
										vnSelectionItemHgt = getComputedStyle(elSelectionItem.querySelector(".cl-checkbox")).height;
									} else {
										// 단일셀렉션
										vnSelectionItemHgt = getComputedStyle(elSelectionItem.querySelector(".cl-radiobutton-item")).height;
									}
								}
								
								/*
								 * 최종 다이얼로그 높이
								 * (보여지는 아이템 개수 * 각 아이템 높이) + 다이얼로그 헤더 높이 + [확인버튼]높이 + 보여지는 아이템 보더개수 + 폼레이아웃 스페이싱
								 */
								var vnTotalDialogHgt = (vnItemCnt * parseInt(vnSelectionItemHgt)) + parseInt(dialogHeaderHgt) + mnConfirmBtnHgt + vnItemBorders + mnFormSpacing;
								
								// 다이얼로그 최대 높이 = 화면높이*0.8
								if(mnMaxHeight  <= vnTotalDialogHgt) {
									vnTotalDialogHgt = mnMaxHeight ;
								}
								
								// 스크롤이 있는 경우 버튼 생성
								var vnRealSelectionHeight = vcSelection.getActualRect().height; // 실제 전체  selection컨트롤의 rect
								var vnSelectionViewHeight = vnTotalDialogHgt - (parseInt(dialogHeaderHgt) + mnConfirmBtnHgt); //  selection컨트롤의 viewPort
								if(vnRealSelectionHeight > vnSelectionViewHeight) {
									// 다이얼로그 최소 높이 
									var vnMin = (parseInt(dialogHeaderHgt) + mnConfirmBtnHgt) + 90;
									if(vnMin >= vnTotalDialogHgt) {
										var maxHeight = (parseInt(vnSelectionItemHgt) * vcSelection.getItemCount()) + parseInt(dialogHeaderHgt) + mnConfirmBtnHgt + vnItemBorders + mnFormSpacing;
										vnTotalDialogHgt = vnMin > maxHeight? maxHeight : vnMin;
									}
								}
														
								var vnSelectionViewHeight2 = vnTotalDialogHgt - (parseInt(dialogHeaderHgt) + mnConfirmBtnHgt); // 변경된 vnTotalDialogHgt 로 다시 계산한 selection컨트롤의 viewPort
								if(mbScrollButton && vnRealSelectionHeight > vnSelectionViewHeight2) { // 스크롤이 있는 경우에만
									// 1) 최초 box-shadow 설정
									vcGroup.style.css({
										"box-shadow" : moBoxShadow.top
									})
									
									// 2) 버튼 추가 
									// TODO 디자인 수정
									var vcUpBtn = new cpr.controls.Button("btnUp");
									vcUpBtn.value = "▲";
									vcUpBtn.style.addClass(msFloatBtnCls);
									vcUpBtn.enabled = false;
									vcUpBtn.addEventListener("click", function(e){
										vcGroup.scrollTo(0, 0, 0.3, cpr.animation.TimingFunction.EASE_IN_OUT_CUBIC);
									});
									dialog.getEmbeddedAppInstance().floatControl(vcUpBtn, {
										top : "10px",
										right : "20px",
										width : "30px",
										height : "30px",
									});
									
									var vcDownBtn = new cpr.controls.Button("btnDown");
									vcDownBtn.value = "▼";
									vcDownBtn.style.addClass(msFloatBtnCls);
									vcDownBtn.addEventListener("click", function(e){
										vcGroup.scrollTo(0, vnRealSelectionHeight, 0.3, cpr.animation.TimingFunction.EASE_IN_OUT_CUBIC);
									});
									
									dialog.getEmbeddedAppInstance().floatControl(vcDownBtn, {
										top : (vnSelectionViewHeight2- 40) + "px",
										right : "20px",
										width : "30px",
										height : "30px",
									});
								}
								
								vcGroup.addEventListener("scroll", function(e){
									var voViewportRect = e.control.getViewPortRect();
									var top = voViewportRect.top;
									var bottom = voViewportRect.bottom;
									
									if(mbScrollButton) {
										if(top == 0) {
											// 가장 위
											vcUpBtn.enabled = false;
											vcDownBtn.enabled = true;
										} else if(bottom == vnRealSelectionHeight) {
											// 가장 아래
											vcUpBtn.enabled = true;
											vcDownBtn.enabled = false;
										} else {
											// 중간
											vcUpBtn.enabled = true;
											vcDownBtn.enabled = true;
										}
									}
									
									if(mbScrollStyle) {
										if(top == 0) {
											// 가장 위
											vcGroup.style.css({
												"box-shadow" : moBoxShadow.top
											})
										} else if(bottom == vnRealSelectionHeight) {
											// 가장 아래
											vcGroup.style.css({
												"box-shadow" : moBoxShadow.bottom
											})
										} else {
											// 중간
											vcGroup.style.css({
												"box-shadow" : moBoxShadow.middle
											})
										}
									}
								});
									
								dialog.style.animateTo({
									height :  vnTotalDialogHgt + "px",
									bottom : "0px"
								}, 0.3, cpr.animation.TimingFunction.EASE_IN_OUT_CUBIC);
							}
						}
					});
				}
			});
			
			// 앱 생성
			cpr.core.Platform.INSTANCE.register(newApp);
			
			return newApp;
		}
		
		
		/**
		 * 콤보박스 리스트가 open되었을 경우 방지
		 * 아이템 개수가 mnCmbItem보다 많은 경우에만 팝업으로 띄운다.
		 * @param {Event} e
		 */
		cpr.events.EventBus.INSTANCE.addFilter("open", function(e){
			var control = e.control;
			
			if(control.type == "combobox" && control.userAttr(ATTR_COMBO_POP) == "true") {
				var vnItemCnt = control.getItemCount();
				if(vnItemCnt > mnList) {
					e.preventDefault();
				}
			}
		});
		
		
		/**
		 * 타겟 콤보박스 확인
		 *  fieldLabel이 있는 경우 fieldLabel 반환
		 *  fieldLabel이 없는 경우 컨트롤 id 반환
		 * @param {cpr.controls.UIControl} pcControl
		 */
		function _getTargetComboId (pcControl) {
			
			var vsLabel = null;
			
			if(pcControl.fieldLabel != null && pcControl.fieldLabel != "") {
				vsLabel = pcControl.fieldLabel;
			} else {
				vsLabel = pcControl.id;
			}
			
			return vsLabel;
		}
		
		
		/**
		 * 팝업 띄우기
		 * @param {cpr.controls.UIControl} pcControl
		 */
		function _floatPop (pcControl) {
			
			mbPop = true;
			
			var voDialogApp = _createApp();
			
			/** @type cpr.core.AppInstance */
			var voRootAppIns = moAppIns.getRootAppInstance();
			
			var vcTargetCtrl = null;
			var vsHeaderTitle = null;
			if(pcControl.type == "combobox") {
				vcTargetCtrl = pcControl;
				var control = pcControl.getAppInstance().lookup(pcControl.fieldLabel);
				if(control) {
					vsHeaderTitle = control.value;
				} else {
					vsHeaderTitle = pcControl.fieldLabel;
				}
			} else {
				vcTargetCtrl = moAppIns.lookup(_getTargetComboId(pcControl));
				var control = pcControl.getAppInstance().lookup(vcTargetCtrl.fieldLabel);
				if(control) {
					vsHeaderTitle = control.value;
				} else {
					vsHeaderTitle = vcTargetCtrl.fieldLabel;
				}
			}
			
			if(vsHeaderTitle == null) {
				vsHeaderTitle = msTempHeaderTitle;
			}
			
			// TODO 다이얼로그 관련 설정 변경
			// 다이얼로그 사이즈 width, height 변경
			voRootAppIns.dialogManager.openDialog(voDialogApp, msDialogName, moPopSize, function(/* cpr.controls.Dialog */ dialog){
				dialog.headerTitle = vsHeaderTitle;
				dialog.initValue = pcControl;
				dialog.resizable = false;
				dialog.headerMovable = false;
				dialog.headerClose = false;
				
				// 다이얼로그 스타일
				dialog.style.addClass(msDialogCls);
				dialog.style.overlay.addClass(msDialogOverlayCls);
				
				dialog.addEventListener("overlay-click", function(e){
					dialog.close();
				});
				
				dialog.addEventListener("init", function(e){
					dialog.getEmbeddedAppInstance().getContainer().getLayout().scrollable = false;
				});
				
				dialog.addEventListener("transitionend", function(e){
					dialog.getEmbeddedAppInstance().getContainer().getLayout().scrollable = true;
					dialog.redraw();
				});
				
				// TODO 다이얼로그가 닫힐 때 발생하는 이벤트
				dialog.addEventListenerOnce("close", function(e){
					
					var targetCtrl = dialog.initValue ; 
					var returnValue = e.control.returnValue ;
					
					// TODO 팝업에서 선택한 값(returnValue) 저장
					if (returnValue) {
						
						// 콤보박스의 상위컨트롤이 그리드인 경우, 그리드 내 콤보박스 셀에 returnValue 저장
						if(targetCtrl.getParent().type == "grid") {
							
							/** @type cpr.controls.Grid */
							var vcGrid = targetCtrl.getParent();
							var vnSelectedRowIndex = vcGrid.getSelectedRowIndex();
				
							var voDetail = vcGrid.detail;
							for(var idx = 0; idx < voDetail.cellCount; idx++){
								if(voDetail.getControl(idx) ==vcTargetCtrl) {
									vcGrid.setCellValue(vnSelectedRowIndex, idx, returnValue);
								}		
							}
						} else {
							// 콤보박스의 상위컨트롤이 그리드가 아닌경우
							targetCtrl.clearSelection();
		
							for(var idx = 0; idx < returnValue.length; idx++) {
								targetCtrl.selectItemByValue(returnValue[idx]);
							}
						}
					}
					
					mbPop = false;
					cpr.core.Platform.INSTANCE.unregister(dialog.app);
				});
			});
		}
		
		/**
		 * 모바일 버전의 콤보박스 사용 여부
		 * @param {Boolean} pbMobile 모바일 여부(true:모바일/false:데스크탑)
		 * @param {Boolean} pbScrollButton? 모바일버전-스크롤 버튼 사용 여부 (default:false)
		 * @param {Boolean} pbScrollStyle? 모바일버전-스크롤 스타일(box-shadow)사용여부 (default:false)
		 */
		globals.setComboPopMobile = function(pbMobile, pbScrollButton, pbScrollStyle) {
			_setMobile(pbMobile, pbScrollButton, pbScrollStyle);
		}
		
		
		/**
		 * 모바일/데스크탑 기준 size,colcount 설정
		 * @param {Boolean} pbMobile 
		 * @param {Boolean} pbScrollButton?
		 * @param {Boolean} pbScrollStyle?
		 */
		function _setMobile (pbMobile, pbScrollButton, pbScrollStyle) {
			mbMobile = pbMobile;
			
			if(pbMobile) {
				// tablet, mobile 화면일 경우
				mnColCount = mnMblColCount;
				moPopSize = moMblPopSize;
				mnList = mnMblItemList;
				
				if(pbScrollButton != null) {
					mbScrollButton = pbScrollButton;
				}
				
				if(pbScrollStyle != null) {
					mbScrollStyle = pbScrollStyle
				}
			} else {
				// default 화면일 경우
				mnColCount = mnDftColCount;
				moPopSize = moDftPopSize;
				mnList = mnDftItemList;
			}
		}
	});
})();
/// end - module/comboBoxListPopup
/// start - module/common
/*
 * Module URI: module/common
 * SRC: module/common.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/common", function(exports, globals, module){
		/************************************************
		 * 각 화면에 대한 메뉴정보, 사용자정보 및 필수적인 공통 함수들을 제공
		 * 각 사이트별 커스터마이징하여 사용 가능
		 * version 2.0
		 ************************************************/
		function AppKit() {
			var extension = cpr.core.Module.require("module/extension");
			
			this._activeLoadMask = null;
			this._activeSubmission = [];
			
			this.Validator = new Validator(this);
			
			this.Auth = new AppAuthKit(this);
			this.Msg = new extension.MsgKit(this);
			this.Dialog = new extension.DialogKit(this);
			this.Group = new extension.GroupKit(this);
			this.Control = new extension.ControlKit(this);
			this.SelectCtl = new extension.SelectKit(this);
			this.Tree = new extension.TreeKit(this);
			this.Tab = new extension.TabKit(this);
			this.DataSet = new extension.DataSetKit(this);
			this.DataMap = new extension.DataMapKit(this);
			this.Grid = new extension.GridKit(this);
			this.FreeForm = new extension.FreeFormKit(this);
			this.Submit = new extension.SubmissionKit(this);
			this.EmbApp = new extension.EmbeddedAppKit(this);
			this.MDI = new extension.MDIKit(this);
			this.Header = new extension.HeaderKit(this);
			this.ComUdcBtn = new extension.ComUdcBtnKit(this);
			
		};
		
		/**
		 * App 화면의 Layout에 맞게 컨트롤 배치 조건 래핑.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {cpr.controls.layouts.Constraint}constraint 래핑할 배치조건
		 * @param {cpr.core.AppInstance} poApp 앱인스턴스
		 * @returns 래핑된 배치조건
		 */
		AppKit.prototype.wrapConstraints = function(app, constraint, poApp) {
			var isPopup = false;
			if(app.getHost() && app.getHost().modal === true){
				isPopup = true;
			}
			
			var layout;
			var container = null;
			if(poApp == null){
				container = isPopup ? app.getContainer() : app.getRootAppInstance().getContainer();
				poApp = isPopup ? app : app.getRootAppInstance();
			}else{
				container = poApp.getContainer();
			}
			layout = container.getLayout();
			
			if (layout instanceof cpr.controls.layouts.ResponsiveXYLayout) {
				var positionConstraints = [];
				var allMedia = poApp.allSupportedMedias;
				allMedia.forEach(function(media) {
					var newConst = _.clone(constraint);
					newConst["media"] = media;
					positionConstraints[positionConstraints.length] = newConst;
				});
				return {
					"positions" : positionConstraints
				};
			}
			
			return constraint;
		};
		
		
		/**
		 * 화면에 LoadMask 출력
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {String} maskType
		 */
		AppKit.prototype.showLoadMask = function(app, maskType) {
			
			var isPopup = false;
			if(app.getHost() && app.getHost().modal === true){
				isPopup = true;
			}
			
			this.hideLoadMask(app);
			
			var showConstraint = {
					"position" : "absolute",
					"top" : "0",
					"bottom" : "0",
					"left" : "0",
					"right" : "0"
			};
			showConstraint = this.wrapConstraints(app, showConstraint);
			
			var container = isPopup ? app.getContainer() : app.getRootAppInstance().getContainer();
			var layout = container.getLayout();
			var loadmask = null;
			if(maskType == "pro") {
				loadmask = container.getAppInstance().lookup("__loadmask_pro__");
				if(loadmask) {
					container.replaceConstraint(loadmask, showConstraint);
				} else {
					loadmask = new udc.cmn.ProgressLoader("__loadmask_pro__");
					container.addChild(loadmask, showConstraint);
					container.getAppInstance().register(loadmask);
				}
				loadmask.module.start();
			
			}
			else if(maskType == "progress"){
				
				loadmask = container.getAppInstance().lookup("__loadmask__");
				try{
					if(loadmask) {
						if(layout instanceof cpr.controls.layouts.FormLayout){
							app.floatControl(loadmask, showConstraint);
						}else{
							container.replaceConstraint(loadmask, showConstraint);
						}
					}else {
						loadmask = new udc.cmn.TimeLoader("__loadmask__");
		//				loadmask.time = 30;
						if(layout instanceof cpr.controls.layouts.FormLayout){
							app.floatControl(loadmask, showConstraint);
						}else{
							container.addChild(loadmask, showConstraint);
						}
						container.getAppInstance().register(loadmask);
					}
				}catch(ex){showConstraint = null;}
			}
			
			 else {
				loadmask = container.getAppInstance().lookup("__loadmask__");
				try{
					if(loadmask) {
						if(layout instanceof cpr.controls.layouts.FormLayout){
							app.floatControl(loadmask, showConstraint);
						}else{
							container.replaceConstraint(loadmask, showConstraint);
						}
					} else {
						loadmask = new udc.cmn.loader("__loadmask__");
						if(layout instanceof cpr.controls.layouts.FormLayout){
							app.floatControl(loadmask, showConstraint);
						}else{
							container.addChild(loadmask, showConstraint);
						}
						container.getAppInstance().register(loadmask);
					}
				}catch(ex){showConstraint = null;}
			}
			
			this._activeLoadMask = loadmask;
		};
		
		/**
		 * LoadMask를 감춤
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 */
		AppKit.prototype.hideLoadMask = function(app) {
			if(this._activeLoadMask) {
				if(this._activeLoadMask.module && this._activeLoadMask.module.end) {
					this._activeLoadMask.module.end();
				}
				var hideConstraint = {
						"position" : "absolute",
						"top" : "-1px",
						"left" : "-1px",
						"width" : "1px",
						"height" : "1px"
				};
				
				//앱 객체가 사라진 경우... ROOT앱을 기본으로 하여 처리
				if(app == null || app.getRootAppInstance() == null){
					app = this._getRootApp();
				}
				
				var isPopup = false;
				if(app.getHost() && app.getHost().modal === true){
					isPopup = true;
				}
				
				var container = isPopup ? app.getContainer() : app.getRootAppInstance().getContainer();
				
				try{
					var layout = container.getLayout();
					if(layout instanceof cpr.controls.layouts.FormLayout){
						app.removeFloatingControl(this._activeLoadMask);
					}else{
						hideConstraint = this.wrapConstraints(app, hideConstraint);
						container.replaceConstraint(this._activeLoadMask, hideConstraint);
					}
					if(this._activeLoadMask){
						this._activeLoadMask.module.count(0);
						this._activeLoadMask.module.hide();
					}
				}catch(ex){hideConstraint = null;}
				
				this._activeLoadMask = null;
			}
		};
		
		/**
		 * 최상위 루트 AppInstance를 반환한다.
		 * - 사이트별 Customizing 필요
		 * @private
		 */
		AppKit.prototype._getRootApp = function() {
			return cpr.core.Platform.INSTANCE.lookup("app/com/inc/main").getInstances()[0];
		};
		
		/**
		 * 메인 앱에 대한 인스턴스를 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @returns 
		 */
		AppKit.prototype.getMainApp = function(app) {
			if(app.isRootAppInstance()) {
				return app;
			}else{
				if(app.getHostAppInstance().isRootAppInstance()) return app;
				else return this.getMainApp(app.getHostAppInstance());
			}
		};
		
		/**
		 * 모바일 접속여부를 반환한다.
		 */
		AppKit.prototype.isAccessMobile = function() {
			var info = cpr.utils.Util.detectBrowser();
			if(info.mobile || info.os.indexOf("Android") > -1) return true;
			return false;
		};
		
		/**
		 * 메인 화면에 데이터 변경사항이 있는지 여부를 체크한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {String} psAftMsg (Optional) 메시지구분
		 * @returns {Boolean} 데이터 변경여부
		 */
		AppKit.prototype.isAppModified = function(app, psAftMsg) {
			var mainApp = this.getMainApp(app);
			if(mainApp == null) return false;
			
			var vaDataCtrls = new Array();
			var container = mainApp.getContainer();
			function getChildRecursive(poContainer){
			    var vaChildCtrls = poContainer.getAllRecursiveChildren();
			    for (var i=0, len=vaChildCtrls.length; i<len; i++) {
			        if (vaChildCtrls[i].type == "grid") {
			        	vaDataCtrls.push(vaChildCtrls[i]);
			        }else if (vaChildCtrls[i] instanceof cpr.controls.Container && vaChildCtrls[i].style.getClasses().indexOf("form-box") != -1) {
			        	vaDataCtrls.push(vaChildCtrls[i]);
			        }else if(vaChildCtrls[i] instanceof cpr.controls.UDCBase){
			        	var voUdcApp = vaChildCtrls[i].getEmbeddedAppInstance();
			        	if(voUdcApp) getChildRecursive(voUdcApp.getContainer());
			        }else if(vaChildCtrls[i] instanceof cpr.controls.EmbeddedApp){
			        	var voEmbApp = vaChildCtrls[i].getEmbeddedAppInstance();
			        	if(voEmbApp) getChildRecursive(voEmbApp.getContainer());
			        }
			    }
			}
			getChildRecursive(container);
			
			var modify = false;
			var ctrl = null;
			var vsFieldLabel = "";
			for(var i=0, len=vaDataCtrls.length; i<len; i++){
				ctrl = vaDataCtrls[i];
				if(ctrl.type == "grid"){
					if(ctrl.userAttr("ignoreModify") === "Y" || ctrl.dataSet == null) continue;
					if(ctrl.dataSet.isModified()){
						modify = true;
						vsFieldLabel = ctrl.fieldLabel;
						break;
					}
				}else{
					var dataSet = this.Group.getBindDataSet(ctrl.getAppInstance(), ctrl);
					if(dataSet != null && dataSet.isModified()) {
						modify = true;
						vsFieldLabel = ctrl.fieldLabel;
						break;
					}
				}
			}
			if(modify && psAftMsg != null && psAftMsg.toUpperCase() == "CRM"){//변경사항이 반영되지 않았습니다. 계속 하시겠습니까? confirm
				if(!this.Msg.confirm("CRM-M003", [vsFieldLabel])) return true;
				else return false;
			}
			return modify;
		};
		
		/**
		 * 메인 화면에 데이터 변경사항이 있는지 여부를 체크한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @returns {Object Array} 변경된 데이터셋 객체 배열
		 */
		AppKit.prototype.getAllAppModifiedDataSet = function(app) {
			var mainApp = this.getMainApp(app);
			if(mainApp == null) return false;
			
			var vaDataCtrls = new Array();
			var vaDataSets = new Array();
			var container = mainApp.getContainer();
			function getChildRecursive(poContainer){
			    var vaChildCtrls = poContainer.getAllRecursiveChildren();
			    for (var i=0, len=vaChildCtrls.length; i<len; i++) {
			        if (vaChildCtrls[i].type == "grid") {
			        	vaDataCtrls.push(vaChildCtrls[i]);
			        }else if (vaChildCtrls[i] instanceof cpr.controls.Container && vaChildCtrls[i].style.getClasses().indexOf("form-box") != -1) {
			        	vaDataCtrls.push(vaChildCtrls[i]);
			        }else if(vaChildCtrls[i] instanceof cpr.controls.UDCBase){
			        	var voUdcApp = vaChildCtrls[i].getEmbeddedAppInstance();
			        	if(voUdcApp) getChildRecursive(voUdcApp.getContainer());
			        }else if(vaChildCtrls[i] instanceof cpr.controls.EmbeddedApp){
			        	var voEmbApp = vaChildCtrls[i].getEmbeddedAppInstance();
			        	if(voEmbApp) getChildRecursive(voEmbApp.getContainer());
			        }
			    }
			}
			getChildRecursive(container);
			
			var ctrl = null;
			for(var i=0, len=vaDataCtrls.length; i<len; i++){
				ctrl = vaDataCtrls[i];
				if(ctrl.type == "grid"){
					vaDataSets.push(ctrl.dataSet);
				}else{
					var dataSet = this.Group.getBindDataSet(ctrl.getAppInstance(), ctrl);
					if(dataSet == null) continue;
					vaDataSets.push(dataSet);
				}
			}
			
			return vaDataSets;
		};
		
		/**
		 * 메인화면에 막(Cover)를 쒸운다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 */
		AppKit.prototype.coverPage = function(app) {
			var coverCtl = new cpr.controls.Container("comPageCover");
			coverCtl.style.css({"background-color":"#ededed", "opacity":"0.5"});
			coverCtl.setLayout(new cpr.controls.layouts.XYLayout());
			var mainApp = this.getMainApp(app);
			
			var container = mainApp.getContainer();
			var layout = container.getLayout();
			if(layout instanceof cpr.controls.layouts.ResponsiveXYLayout){
				container.addChild(coverCtl, {
						positions: [{
								"media": "all and (min-width: 1320px)",
								"top": "0px",
								"right": "0px",
								"bottom": "0px",
								"left": "0px"
							},
							{
								"media": "all and (min-width: 1024px) and (max-width: 1319px)",
								"top": "0px",
								"right": "0px",
								"bottom": "0px",
								"left": "0px"
							},
							{
								"media": "all and (min-width: 500px) and (max-width: 1023px)",
								"hidden": false,
								"top": "0px",
								"right": "0px",
								"bottom": "0px",
								"left": "0px"
							}, 
							{
								"media": "all and (max-width: 499px)",
								"hidden": false,
								"top": "0px",
								"right": "0px",
								"bottom": "0px",
								"left": "0px"
							}
				]});
			}else if(layout instanceof cpr.controls.layouts.FormLayout){
				app.floatControl(coverCtl, {
					"top": "0px",
					"right": "0px",
					"bottom": "0px",
					"left": "0px"
				});
			}else{
				container.addChild(coverCtl, {
					"top": "0px",
					"right": "0px",
					"bottom": "0px",
					"left": "0px"
				});
			}
		};
		
		/**
		 * 컨트롤(그룹) 또는 Grid의 내의 입력 값에 대한 유효성 체크를 수행한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol | Array} paCtlId 컨트롤 ID
		 * @param {String} dataScope (all:그리드의 전체 데이터, modify:변경된 전체 Row, current:현재  Row)
		 * @returns {Boolean} Valid true, Invalid false.
		 */
		AppKit.prototype.validate = function(app, paCtlId, dataScope) {
			dataScope = dataScope != null ? dataScope : "upd";
			if(!(paCtlId instanceof Array)){
				paCtlId = [paCtlId];
			}
			
			var valid = true;
			for(var i=0, len=paCtlId.length; i<len; i++) {
				var ctrlId = paCtlId[i];
				var ctrl = app.lookup(paCtlId[i]);
				if(ctrl instanceof cpr.controls.Grid){
					valid = this._validateGrid(ctrl, dataScope);
				}else if(ctrl instanceof cpr.controls.Container){
					/** @type cpr.bind.BindContext */
					var voBindContext = this.Group.getBindContext(app, ctrl);
					if(voBindContext){
						/**@type cpr.data.DataSet */
						var voDs = voBindContext.grid ? voBindContext.grid.dataSet : voBindContext.dataSet;
						var rowIndex = voBindContext.grid ? voBindContext.grid.getSelectedRowIndex() : voBindContext.rowIndex;
						//프리폼의 상태가 삭제상태이면... 유효성 체크에서 제외함
						if(voDs.getRowState(rowIndex) == cpr.data.tabledata.RowState.DELETED) continue;
					}
					
					valid = this._validateControl(ctrl);
				}else{
					valid = this._validateControl(ctrl);
				}
				
				if(valid == false) {
					return false;
				}
			}
			
			return true;
		};
		
		/**
		 * @private
		 * 일반 컨트롤에 대한 Validation 체크
		 * @param {cpr.controls.UIControl} ctrl
		 * @param {cpr.controls.UIControl} poParentCtl
		 */
		AppKit.prototype._validateControl = function(ctrl, poParentCtl) {
			if(!ctrl) return true;
			
			var valid = true;
			var _this = this;
			if(ctrl instanceof cpr.controls.Container) { // Group 일 경우 체크
				var children = this._getChildren(ctrl);
				var child;
				for(var i=0, len=children.length; i<len; i++){
					child = children[i];
					// 컨트롤별 Validation Check
					if(this._validateControl(child, ctrl) == false) {
						valid = false;
						break;
					}
				}
				return valid;
			} else if(ctrl instanceof cpr.controls.UDCBase){ //UDC인 경우
				var embApp = ctrl.getEmbeddedAppInstance();
				var children = embApp.getContainer().getAllRecursiveChildren();
				var child;
				for(var i=0, len=children.length; i<len; i++){
					child = children[i];
					// 컨트롤별 Validation Check
					if(this._validateControl(child, ctrl) == false) {
						valid = false;
						break;
					}
				}
				return valid;
			} else {
				valid = this.Validator.validate(ctrl, ctrl.value, poParentCtl);
				if(valid == false) {
					//탭내에 컨트롤이 존재하는 경우... 해당 탭페이지 포커싱
					this._focusToTabItem(ctrl);
					ctrl.focus();
				}
				return valid;
			}
		};
		
		/**
		 * @private
		 * Grid의 변경된 전체 데이터에 대한 Validation 체크
		 * - 사이트별 Customizing 필요
		 * 가능한 한 Validation 체크시 validate 메소드를 사용
		 * @param {cpr.controls.Grid} poGrid 체크할 Grid
		 * @param {String} dataScope (all:그리드의 전체 데이터, modify:변경된 전체 Row, current:현재  Row)
		 * @returns {Boolean}
		 */
		AppKit.prototype._validateGrid = function(poGrid, dataScope) {
			dataScope = dataScope != null ? dataScope : "modify";
			/** @type cpr.controls.Grid */
			var grd = poGrid;
			if(!grd) return false;
			
			var vsDataBindCtxId = grd.userAttr("bindDataFormId");
			
			var _this = this;
			/**
			 * @type cpr.controls.gridpart.GridBand
			 */
			var detailBand = grd.detail;
			var cellCnt = detailBand.cellCount;
			
			/**
			 * @type cpr.data.DataSet
			 */
			var dataSet = grd.dataSet;
			var rowIndexs = null;
			if(dataScope == "all"){
				rowIndexs = dataSet.getRowStatedIndices(cpr.data.tabledata.RowState.INSERTED | cpr.data.tabledata.RowState.UPDATED | cpr.data.tabledata.RowState.DELETED | cpr.data.tabledata.RowState.UNCHANGED);
			}else{
				rowIndexs = dataSet.getRowStatedIndices(cpr.data.tabledata.RowState.INSERTED | cpr.data.tabledata.RowState.UPDATED);
			}
			var _this = this;
			var invalid = rowIndexs.some(function(idx) {
				var row = dataSet.getRow(idx);
				var col = null;
				for(var i = 0; i < cellCnt; i++) {
					/**  @type cpr.controls.gridpart.GridColumn */
					col = detailBand.getColumn(i);
					//컬럼 매핑노드가 없으면... SKIP
					if(col.columnName == null || col.columnName == "") continue;
					if(col.columnType == "checkbox" || col.columnType == "rowindex") continue;
					//컬럼 유형이 output이면... SKIP
					if(col.controlType == null || col.controlType == "output" || col.controlType == "button" || col.controlType == "img") continue;
					//신규행  PK 체크 무시... SKIP
					if(row.getState() == cpr.data.tabledata.RowState.INSERTED && (col.control && col.control.userAttr("ignorePk") == "Y")) continue;
					
					// 컨트롤별 Validation Check
					if(_this.Validator.validate(col.control, row.getValue(col.columnName), grd, idx, i) == false) {
						//유효성 체크로 인해 selection-change 발생여부 셋팅 
						grd.userAttr("selectionChangeByValidation", "true");
						//탭내에 컨트롤이 존재하는 경우... 해당 탭페이지 포커싱
						_this._focusToTabItem(grd);
						if(ValueUtil.isNull(vsDataBindCtxId)){
							grd.setEditRowIndex(idx, true);
							grd.focusCell(idx, i);
							//포커싱할 컬럼이 UDC인 경우에...
							var dctrl = grd.detail.getColumn(i).control;
							if(dctrl instanceof cpr.controls.UDCBase){
								var empApp = dctrl.getEmbeddedAppInstance();
								dctrl = AppUtil.getUDCBindValueControl(dctrl);
								if(dctrl) empApp.focus(dctrl.id);
							}
						}else{
							grd.selectRows(idx);
							var cctrl = _this.Group.getDataBindedControl(dataSet.getAppInstance(), vsDataBindCtxId, col.columnName);
							if(cctrl) _this.Control.setFocus(cctrl.getAppInstance(), cctrl.id);
						}
						
						return true;
					}
				}
				return false;
			});
			if(invalid == true) {
				return false;
			}
			
			return true;
		};
		
		
		/**
		 * @private
		 * Validation 체크시 컨트롤이 속한 탭폴더 선택용
		 * @param {cpr.controls.UIControl} ctrl - 컨트롤 객체
		 */
		AppKit.prototype._focusToTabItem = function(ctrl) {
			/**@type cpr.controls.TabFolder */
			var tab = null;
			ctrl.findParent(function(pctrl){
				if(pctrl instanceof cpr.controls.TabFolder){
					tab = pctrl;
					return true;
				}
				return false;
			});
			if(tab){
				var tabItem = null;
				var tabItems = tab.getTabItems();
				ctrl.findParent(function(pctrl){
					tabItems.some(function(each){
						if( each.content == pctrl){
							tabItem = each;
							return true;
						}
						return false;
					});
					return tabItem != null;
				});
				if(tabItem && tabItem != tab.getSelectedTabItem()){
					tab.setSelectedTabItem(tabItem);
				}
			}
		};
		
		/**
		 * @private
		 * 그룹 컨트롤내의 자식 컨트롤 목록을 반환한다.
		 * @param {cpr.controls.Container} pcGroup - 그룹컨트롤
		 */
		AppKit.prototype._getChildren = function(pcGroup) {
			var children = pcGroup.getAllRecursiveChildren();
			function getNextControls(each,children){
				var order = [each];
				var next = each;
				while(next != null){
					next = next.getNextControl();
					if(next != null && children.indexOf(next) > -1 && order.indexOf(next) == -1) order.push(next);
					else next = null;
				}
				return order;
			} 
			
			var orderCtrls = [];
			children.forEach(function(each){
				if(children.indexOf(each.getPrevControl()) ==-1 && each.getNextControl() != null){
					orderCtrls = getNextControls(each,children);
				}
			});
			
			var etcCtrls = [];
			children.forEach(function(each){
				if(orderCtrls.indexOf(each) == -1){
					etcCtrls.push(each);
				}
			});
			
			return orderCtrls.concat(etcCtrls);
		};
		
		/**
		 * 디폴트 언어키 취득
		 * - 사이트별 Customizing 필요 getDefaultLocale 메소드 필요.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @returns {String} 디폴트 언어키
		 */
		AppKit.prototype.getDefaultLocale = function(app) {
			var rootApp = app.getRootAppInstance();
			if(rootApp.hasAppMethod("getDefaultLocale")){
				return rootApp.callAppMethod("getDefaultLocale");
			}
		};
		
		
		function AppAuthKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 로그인 사용자의 정보를 취득
		 * - 사이트별 Customizing 필요 
		 *   Root App에 getUserInfo 생성 필요.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {String} psUserInfoType (Optional) 사용자정보 TYPE 세션정보 참고
		 * 					   또는 
		 * 					   var mapUserInfo = util.getUserInfo();
		 * 					   mapUserInfo.get("USER_ID");
		 * 	USER_ID 		: 사용자 ID
		 *  USER_NM			: 사용자명
		 * 	USER_DIV_CD		: 사용자구분코드(STAFF:직원/PROF:교원/STUD:학생/GRAD_STUD:대학원생)
		 *  STAFF_NO		: 교직원번호(교원원인에 한함)
		 *  STUD_NO			: 학번(학생/대학원생에 한함)
		 *  UNIV_CD			: 소속대학코드(학생/대학원생에 한함)
			ASGN_DEPT_CD	: 소속부서코드
			ASGN_DEPT_NM	: 소속부서명
			CUR_RCD_NM		: 학점은행제 교육과정명
		 * @returns {String | cpr.data.DataMap} psUserInfoType 미지정시 Map 형태의 사용자 정보 리턴 
		 */
		AppAuthKit.prototype.getUserInfo = function(app, psUserInfoType) {
			var rootApp = app.getRootAppInstance();
			if(rootApp.hasAppMethod("getUserInfo")){
				if(ValueUtil.isNull(psUserInfoType)){
					return rootApp.callAppMethod("getUserInfo");
				}else{
					return rootApp.callAppMethod("getUserInfo", [psUserInfoType]);
				}
			}
		};
		
		/**
		 * 메뉴를 바로 오픈할 경우 부모페이지에서 전달한 파라미터를 꺼내는 함수 (JSON 형태로 리턴됨)
		 * 
		 * [ 메뉴 파람 담는 법 및 메뉴 다이렉트 오픈 예제 ]
		 * var voParam = { SUBJ_NO : util.Grid.getCellValue(app, "grdMain", "SUBJ_NO")};
		 * util.MDI.open(app, "rptCSubjMstMng", voParam);
		 * 
		 * [ 사용법 ]
		 * var voMenuParam = util.Auth.getMenuParam(app);
		 * var vsSubjNo = voMenuParam.SUBJ_NO;
		 * 
		 * - 사이트별 Customizing 필요 
		 *    Root App에 getMenuParam 메소드 생성 필요
		 * @param {cpr.core.AppInstance} app
		 * 
		 */
		AppAuthKit.prototype.getMenuParam = function(app) {
		    var rootApp = app.getRootAppInstance();
		    if(rootApp.hasAppMethod("getMenuParam")){
		        return JSON.parse(rootApp.callAppMethod("getMenuParam"));
		    }
		};
		
		/**
		 * 메뉴 정보 취득
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {String} (Optional) psMenuType  메뉴 정보 TYPE
		 *                 생략시 메뉴 정보 MAP 리턴
		 * @returns psMenuType 생략시 
		 *          {cpr.utils.ObjectMap} 
		 * 			getMenuInfo.get("OPRT_ROLE_ID");		//업무역할ID
					getMenuInfo.get("MENU_ID");				//메뉴ID
					getMenuInfo.get("PGM_ID");				//프로그램ID
					getMenuInfo.get("MENU_NM");				//메뉴명
					getMenuInfo.get("USE_AUTH_RCD"); 	//메뉴권한구분코드[CMN045]
					getMenuInfo.get("DEPT_AUTH_RCD"); 	 	//권한볌위코드[CMN035]
					getMenuInfo.get("UNIT_SYS_RCD");		//단위시스템코드[CMN003]
					getMenuInfo.get("CALL_PAGE");			//호출페이지
					getMenuInfo.get("TOP_MENU_ID");			//최상위 메뉴ID
					getMenuInfo.get("DOWNLD_YN");			//파일다운로드 여부
		 */
		AppAuthKit.prototype.getMenuInfo = function(app, psMenuType){
			var voMap = new cpr.utils.ObjectMap();
			
			var _mainApp = this._appKit.getMainApp(app);
			var vsData = null;
			if(_mainApp.__menuInfo != null){
				vsData = _mainApp.__menuInfo;
			}else{
				var rootApp = app.getRootAppInstance();
				/** @type cpr.controls.MDIFolder */
				var vcMdi = rootApp.lookup("mdiMainContent");
				if(vcMdi){
					var vcTabItem = vcMdi.getSelectedTabItem();
					if(vcTabItem != null){
						vsData = vcTabItem.userAttr("__menuInfo");
						_mainApp.__menuInfo = vsData;
					}
				}
			}
			if(!ValueUtil.isNull(vsData)){
				var voData = JSON.parse(vsData);
				if(psMenuType != null){
					return ValueUtil.fixNull(voData[psMenuType]);
				}else{
					for(var key in voData){
						voMap.put(key, ValueUtil.fixNull(voData[key]));
					}
					return voMap;
				}
			}else{
				return voMap;
			}
		};
		
		/**
		 * 해당 화면이 소속권한 화면인지 여부(true/false) 반환한다.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 */
		AppAuthKit.prototype.isAsgnDeptAuth = function(app){
			var vsDeptAuthRcd = this._appKit.Auth.getMenuInfo(app, "DEPT_AUTH_RCD");
			// 소속부서 or 소속관리부서
			return vsDeptAuthRcd == "CMN035.0003" || vsDeptAuthRcd == "CMN035.0007" ? true : false;
		};
		
		/**
		 * 해당 화면이 개인권한 화면인지 여부(true/false) 반환한다.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 */
		AppAuthKit.prototype.isPrivateAuth = function(app){
			var vsDeptAuthRcd = this._appKit.Auth.getMenuInfo(app, "DEPT_AUTH_RCD");
			return vsDeptAuthRcd == "CMN035.0009" ? true : false;
		};
		
		/**
		 * 해당 화면이 학과장 권한으로 할당되었는지 여부(true/false) 반환한다.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 */
		AppAuthKit.prototype.isDepartMentDeanAuth = function(app){
			var vsOprtRoleId = this._appKit.Auth.getMenuInfo(app, "OPRT_ROLE_ID");
			return vsOprtRoleId == "USER_CSR_POS" ? true : false;
		};
		
		/**
		 * 해당 화면이 관리권한 화면인지 여부(true/false) 반환한다.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 */
		AppAuthKit.prototype.isMenuMngAuth = function(app){
			/**@type cpr.core.AppInstance */
			var vsMenuAuthRcd = this._appKit.Auth.getMenuInfo(app, "USE_AUTH_RCD");
			return vsMenuAuthRcd == "CMN045.0003" ? true : false;
		};
		
		/**
		 * 해당 화면이 조회전용 화면인지 여부(true/false) 반환한다.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 */
		AppAuthKit.prototype.isReadUseAuth = function(app){
			/**@type cpr.core.AppInstance */
			var vsUseAuthRcd = this._appKit.Auth.getMenuInfo(app, "USE_AUTH_RCD");
			return vsUseAuthRcd == "CMN045.0002" ? true : false;
		};
		
		/**
		 * 사용자 권한에 따라 핸들링되어야 하는 UI 컨트롤 목록을 지정한다.
		 * 기본적으로 공통처리되며, 추가 예외적으로 적용되어야 하는 컨트롤들만을 지정하면 된다.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol | Array} paCtrls - 대상 컨트롤 ID 또는 ID 배열
		 */
		AppAuthKit.prototype.setAuthCtrls = function(app, paCtrls){
			/**@type cpr.core.AppInstance */
			var _app = this._appKit.getMainApp(app);
			
			if(!(paCtrls instanceof Array)){
				paCtrls = [paCtrls];
			}
			if(_app.__AUTH_TARGET_CTRLS == null || _app.__AUTH_TARGET_CTRLS == undefined){
				_app.__AUTH_TARGET_CTRLS = [];
			}
			_app.__AUTH_TARGET_CTRLS.concat(paCtrls);
		};
		
		/**
		 * 화면 권한에 따른 컨트롤 제어를 수행한다.
		 * - 사이트별 Customizing 필요
		 * ex) 조회권한인 경우 권한 컨트롤 비활성화처리
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {String} psMenuAuthDivRcd - 메뉴권한코드[CMN045]
		 * @param {String} psSearchBoxId - (Optional) 검색조건 그룹ID
		 */
		AppAuthKit.prototype.applyAuthForCtrls = function(app, psMenuAuthDivRcd, psSearchBoxId){
			if(app.isRootAppInstance()) return;
			
			var getParameterByName = function(name, url) {
			    name = name.replace(/[\[\]]/g, "\\$&");
			    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)");
			    var results = regex.exec(url);
			    return results == null ? "" : results[2];
			}
			
			//새창으로 띄웠는지 여부 Flag, 새창으로 띄운 경우... 무조건 조회용임
			var vsFlag = getParameterByName("flag", top.location.href); 
			
			if(vsFlag !== "R" && psMenuAuthDivRcd != "CMN045.0002") return;
			
			var vaSearchBoxIds = ValueUtil.split((!ValueUtil.isNull(psSearchBoxId) ? psSearchBoxId : ""), ",");
			
			var vaTargetCtrls = new Array();
			var container = app.getContainer();
			function getChildRecursive(poContainer){
			    var vaChildCtrls = poContainer ? poContainer.getAllRecursiveChildren() : container.getAllRecursiveChildren();
			    for (var i=0, len=vaChildCtrls.length; i<len; i++) {
			        if (vaChildCtrls[i].type == "udc.com.comButton"
			        	|| vaChildCtrls[i].type == "udc.com.comButtonAddDel"
			        	|| vaChildCtrls[i].type == "grid"
			        	|| vaChildCtrls[i].type == "button"
			        	|| vaChildCtrls[i].type == "container" && vaSearchBoxIds.indexOf(vaChildCtrls[i].id) == -1 && (vaChildCtrls[i].getLayout() instanceof cpr.controls.layouts.FormLayout)) {
			        	vaTargetCtrls.push(vaChildCtrls[i]);
			        }else if (vaChildCtrls[i] instanceof cpr.controls.Container ) {
			        	getChildRecursive(vaChildCtrls[i]);
			        }
			    }
			    vaChildCtrls = null;
			}
			
			//하위의 대상 컨트롤들을 모두 취합
			getChildRecursive(container);
			
			//추가적으로 화면단에 대한 넘겨준 대상 컨트롤이 있는 경우 
			if(!ValueUtil.isNull(app.__AUTH_TARGET_CTRLS)){
				vaTargetCtrls.concat(app.__AUTH_TARGET_CTRLS);
			}
			
			var header = this._appKit.Group.getAllChildrenByType(app, "udc.com.appHeader");
			if(header != null && header.length > 0){
				var vcCtrl = header[0].getEmbeddedAppInstance().lookup("grpButtons");
				if(vcCtrl){
					vcCtrl.visible = false;
				}
			}
			
			vaTargetCtrls.forEach(function(ctrl){
				//공통 작업버튼 UDC인 경우
				if(ctrl.type == "udc.com.comButton" || ctrl.type == "udc.com.comButtonAddDel"){
					ctrl.visible = false;
				//그리드인 경우
				}else if(ctrl.type == "grid"){
					if(ctrl.readOnly !== true) ctrl.readOnly = true;
				//프리폼인 경우
				}else if(ctrl.type == "container"){
					if(ctrl.style && ctrl.style.getClasses().join(";").indexOf("form-box") != -1 && ctrl.getBindContext() != null) ctrl.enabled = false;
				//버튼인 경우
				}else if(ctrl.type == "button"){
					var vsStyle = ctrl.style ? ctrl.style.getClasses().join(";") : "";
					//커밋 버튼, 신규 버튼, 삭제 버튼, 프리폼 삭제 버튼, 저장 버튼
					if(vsStyle.indexOf("btn-commit") != -1 || vsStyle.indexOf("btn-new") != -1 || vsStyle.indexOf("btn-delete") != -1 || vsStyle.indexOf("btn-delete-save") != -1 || vsStyle.indexOf("btn-save") != -1){
						ctrl.visible = false;
					}
				}
			});
		};
		
		// 모든 selection-change 이벤트에시 그리드에 대한  필터만 추가.
		//- 사이트별 Customizing 필요
		cpr.events.EventBus.INSTANCE.addFilter("selection-change", function(e) {
		    // 이벤트를 발생 시킨 컨트롤
		    var control = e.control;
		    /** @type cpr.core.AppInstance */
		    var _app = control.getAppInstance();
		    
		    // 이벤트 발송자가 그리드 이고.
		    if (control instanceof cpr.controls.Grid) {
		    	/** @type cpr.controls.Grid */
		    	var grid = control;
		    	if(grid.selectionUnit == "cell" && grid.getSelectedIndices()[0] == null){
		    		 e.stopPropagation();
		    	}else{
		    		var rowIndex = grid.selectionUnit != "cell" ? grid.getSelectedRowIndex() : grid.getSelectedIndices()[0]["rowIndex"];
			        // 그리드 선택 ROW가 -1이라면...
			        if (rowIndex < 0) {
			            // 이벤트 전파를 차단시킵니다.
			            e.stopPropagation();
			        }
		    	}
		    }
		});
		
		
		
		// 모든 before-selection-change 이벤트에시 그리드에 대한  필터만 추가.
		//- 사이트별 Customizing 필요
		cpr.events.EventBus.INSTANCE.addFilter("before-selection-change", function(e) {
		    // 이벤트를 발생 시킨 컨트롤
		    var control = e.control;
		    /** @type cpr.core.AppInstance */
		    var _app = control.getAppInstance();
		    
		    // 이벤트 발송자가 그리드 이고.
		    if (control instanceof cpr.controls.Grid) {
		    	if(e.newSelection[0] == null || e.newSelection[0] == undefined){
		    		// 이벤트 전파를 차단시킵니다.
		            e.stopPropagation();
				}
		    }
		});
		
		//모든 before-value-change 이벤트에시 인풋박스에 대한 대소문자 자동변환.
		//- 사이트별 Customizing 필요
		cpr.events.EventBus.INSTANCE.addFilter("before-value-change", function(e) {
		    // 이벤트를 발생 시킨 컨트롤
		    var control = e.control;
		    /** @type cpr.core.AppInstance */
		    
		    // 이벤트 발송자가 인풋박스이면.
		    if (control.type === "inputbox") {
		    	var inputLetter = control.userAttr("inputLetter");
				if (inputLetter == "uppercase") {
					if (/[a-z]/g.test(e.newValue)) {
						var newValue = e.newValue.toUpperCase();
						control.value = newValue;
						e.preventDefault();
						e.stopPropagation();
					}
				} else if (inputLetter == "lowercase") {
					if (/[A-Z]/g.test(e.newValue)) {
						var newValue = e.newValue.toLowerCase();
						control.value = newValue;
						e.preventDefault();
						e.stopPropagation();
					}
				}
		    }
		});
		
		//cpr.core.Platform.INSTANCE.onerror = function(report){
		//	console.log(JSON.stringify(report.stack, null, "  "));
		//};
		
		exports.AppKit = AppKit;
		
		
		globals.createModel = function(){
			return new AppKit();
		}
		
		globals.createCommonUtil = function(){
			var vsMainAppId = "app/com/inc/main"; //메인 APP-ID를 지정
		//	try {
		//		/**
		//		 * @type cpr.core.AppInstance
		//		 */
		//		var rootApp = cpr.core.Platform.INSTANCE.lookup(vsMainAppId).getInstances()[0];
		//		return rootApp.callAppMethod("getCommonUtil");
		//	} catch (ex){
				return new AppKit();
		//	}
		};
		
		
		//round 함수
		cpr.expression.ExpressionEngine.INSTANCE.registerFunction("getRound", function(value, position) {
			if(isNaN(value)) return 0;
			else if(value == Infinity || value == -Infinity) return 0;
			if(position == undefined || position == null) return Math.round(value);
			else return Math.round(value * (10 * position))/(10 * position);
		});
		//floor 함수
		cpr.expression.ExpressionEngine.INSTANCE.registerFunction("getFloor", function(value, position) {
			if(isNaN(value)) return 0;
			else if(value == Infinity || value == -Infinity) return 0;
			if(position == undefined || position == null) return Math.floor(value);
			else return Math.floor(value * (10 * position))/(10 * position);
		});
		//숫자 천단위 콤마 포맷
		cpr.expression.ExpressionEngine.INSTANCE.registerFunction("formatToNumber", function(value) {
			if(isNaN(value)) return value;
			return new String(value).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
		});
	});
})();
/// end - module/common
/// start - module/DynamicGrid
/*
 * Module URI: module/DynamicGrid
 * SRC: module/DynamicGrid.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/DynamicGrid", function(exports, globals, module){
		/************************************************
		 * DynamicGrid.module.js
		 * Created at 2021. 1. 12. 오후 2:15:23.
		 *
		 * @author ryu54
		 ************************************************/
		
		/************************************************
		 * 그리드 동적 생성 설정 정보
		 ************************************************/
		
		/**
		 * 그리드 표준 크기 (헤더, 디테일, 컬럼)
		 * 필요 시 그룹 또는 푸터에 대한 표준 크기를 지정하십시오.
		 * @type {
		 *   column : {
		 *     width: String
		 *   },
		 *   header : {
		 *     height: String
		 *   },
		 *   detail : {
		 *     height : String
		 *   }
		 * }
		 */
		var moGrdSizeConfig = {
			"column" : {
				"width" : "100px"
			},
			"header" : {
				"height" : "35px"
			},
			"detail" : {
				"height" : "32px"
			}
		}
		
		
		/**
		 * 셀 생성 시 필요한 설정 정보
		 * @type {
		 *   HD_TXT : String <!-- 헤더 텍스트 컬럼명 -->,
		 *   RW_IDX : String <!-- 셀의 로우 인덱스 -->,
		 *   COL_IDX : String <!-- 셀의 컬럼 인덱스 -->,
		 *   COL_NM : String <!-- 셀의 바인딩 컬럼명 -->
		 * }
		 */
		var moBindConfig = {
			"HD_TXT" : "headerText",
			"RW_IDX" : "rowIndex",
			"COL_IDX" : "colIndex",
			"COL_NM" : "columnName"
		}
		
		
		/**
		 * 
		 * @param {cpr.controls.Grid} grid
		 * @param {
		 *   header : cpr.data.DataSet <!-- 그리드 헤더를 구성하는 데이터 셋 ID -->,
		 *   detail : cpr.data.DataSet <!-- 그리드에 연결될 데이터 셋 ID -->
		 * } config
		 */
		function DynamicGrid(grid, config) {
			if (grid instanceof cpr.controls.Grid == false){
				throw new cpr.exceptions.IllegalStateException("타겟이 그리드 컨트롤이 아닙니다. 다시 확인하여 주십시오.");
			}
			
			this._grid = grid;
			this._appInstance = grid.getAppInstance();
			this._headerDataset = config.header;
			this._detailDataset = config.detail;
			
			this.init();
		}
		
		/**
		 * 
		 * @type {{width:String}[]}
		 */
		DynamicGrid.prototype._columnSettings = [];
		
		/**
		* 
		* @type 
		* {
		*   rows: {height:String}[],
		*   cells: {
		*     constraint: {rowIndex:Number,rowSpan:Number,colIndex:Number,colSpan:Number},
		*     configurator: Function
		*   }[]
		* }
		*/
		DynamicGrid.prototype._headerSettings = {};
		
		/**
		* 
		* @type 
		* {
		*   rows: {height:String}[],
		*   cells: {
		*     constraint: {rowIndex:Number,rowSpan:Number,colIndex:Number,colSpan:Number},
		*     configurator: Function
		*   }[]
		* }
		*/
		DynamicGrid.prototype._detailSettings = {};
		
		
		/**
		 * 헤더 개수를 반환합니다.
		 * @return {Number}
		 */
		DynamicGrid.prototype._getHeaderCount = function() {
			var dataset = this._headerDataset;
			var headerCount = dataset.getUnfilteredDistinctValues(moBindConfig.RW_IDX).length;
			return headerCount;
		}
		
		/**
		 * 컬럼 개수를 반환합니다.
		 * @return {Number}
		 */
		DynamicGrid.prototype._getColumnCount = function() {
			var dataset = this._headerDataset;
			var columnCount = dataset.getUnfilteredDistinctValues(moBindConfig.COL_IDX).length;
			return columnCount;
		}
		
		/**
		 * 그리드 컬럼 레이아웃 정보를 동적으로 생성합니다.
		 */
		DynamicGrid.prototype._handleColumn = function() {
			var dataset = this._headerDataset;
			
			var originalLayout = moGrdSizeConfig.column.width;
			
			var colCount = this._getColumnCount();
			for(var idx = 0; idx < colCount; idx++){
				this._columnSettings.push({"width" : originalLayout});
			}
		}
		
		
		/**
		 * 그리드 헤더 레이아웃 및 셀에 대한 정보를 동적으로 생성합니다.
		 */
		DynamicGrid.prototype._handleHeader = function() {
			var dataset = this._headerDataset;
			
			var originalLayout = moGrdSizeConfig.header.height;
			
			/* Rows */
			this._headerSettings.rows = [];
			var headerCount = this._getHeaderCount();
			for(var idx = 0; idx < headerCount; idx++){
				this._headerSettings.rows.push({"height" : originalLayout});
			}
			
			/** 세로 병합에 의해 스킵되는 셀에 해당하는 행 인덱스 */
			var skipCellIdcs = [];
			
			/* Cells */
			this._headerSettings.cells = [];
			var colCount = this._getColumnCount();
			var rowCount = dataset.getRowCount();
			for(var idx = 0; idx < rowCount; idx++){
				var headerText = dataset.getValue(idx, moBindConfig.HD_TXT);
				var rowIdx = dataset.getValue(idx, moBindConfig.RW_IDX);
				var colIdx = dataset.getValue(idx, moBindConfig.COL_IDX);
				var colNm = dataset.getValue(idx, moBindConfig.COL_NM);
				
				/* 세로 병합된 셀 제외 */
				if (skipCellIdcs.indexOf(idx) != -1){
					continue;
				}
		
				var rowSpan = 1;
				var colSpan = 1;
				
				/* 상위 헤더 셀이 병합되었는지 확인 */
				var alreadySpanned = false; // 상위 병합 여부
				var upperHeaderCell = dataset.findFirstRow(moBindConfig.RW_IDX + "==" + (rowIdx - 1) + "&&" + moBindConfig.COL_IDX + "==" + colIdx);
				if (upperHeaderCell != null){
					var upperHeaderCellIdx = upperHeaderCell.getIndex();
					alreadySpanned = skipCellIdcs.indexOf(upperHeaderCellIdx) != -1;
				}
				
				/* 상위 헤더 셀이 병합되지 않았을 때만 가로 병합 실행 */
				if (alreadySpanned == false){
					/* 가로 병합되는 셀 개수 구함 */
					var sameHeaders = dataset.findAllRow(moBindConfig.RW_IDX + "==" + rowIdx + "&&" + moBindConfig.COL_IDX + ">" + colIdx);
					for(var spIdx = 0; spIdx < sameHeaders.length; spIdx++){
						var nextHeader = sameHeaders[spIdx];
						var nextHeaderText = nextHeader.getValue(moBindConfig.HD_TXT);
						if (nextHeaderText == headerText){
							colSpan++;
							skipCellIdcs.push(nextHeader.getIndex());
						} else {
							break;
						}
					}
				}
				
				/* 가로 병합을 우선 시 하므로 이미 가로로 병합되었을 경우 세로 병합 하지 않음 */
				if (colSpan == 1){
					/* 현재 셀 기준으로 세로 병합될 셀 개수 구함 */
					for(var spIdx = rowIdx + 1; spIdx < headerCount; spIdx++){
						var nextRowHeader = dataset.findFirstRow(moBindConfig.RW_IDX + "==" + spIdx + "&&" + moBindConfig.COL_IDX + "==" + colIdx);
						var nextRowHeaderText = nextRowHeader.getValue(moBindConfig.HD_TXT);
						if (nextRowHeaderText == headerText) {
							rowSpan++;
							skipCellIdcs.push(nextRowHeader.getIndex());
						} else {
							break;
						}
					}
				}
				
				var config = (function(rowIndex, colIndex, rowSpan, colSpan, text, columnName) {
					return {
						constraint: {
							"rowIndex": rowIndex,
							"rowSpan": rowSpan,
							"colIndex": colIndex,
							"colSpan": colSpan
						},
						configurator: function(cell) {
							cell.targetColumnName = columnName;
							cell.text = text;
							//TODO 헤더 셀에 컨트롤을 동적으로 배치하는 경우 다음의 소스를 참고하십시오.
							/*
							 * cell.control = (function() {
							 * 	var output = new cpr.controls.Output();
							 * 	output.value = "";
							 * 	return output;
							 * })();
							 */
						}
					}
				})(rowIdx, colIdx, rowSpan, colSpan, headerText, colNm);
					
				this._headerSettings.cells.push(config);
			}
		}
		
		
		/**
		 * 그리드 디테일 레이아웃 및 셀에 대한 정보를 동적으로 생성합니다.
		 */
		DynamicGrid.prototype._handleDetail = function() {
			var dataset = this._headerDataset;
			
			var originalLayout = moGrdSizeConfig.detail.height;
			
			this._detailSettings.rows = [];
			this._detailSettings.rows.push({"height" : originalLayout});
			
			this._detailSettings.cells = [];
			var headerRowCnt = this._getHeaderCount();
			var lastHds = dataset.findAllRow(moBindConfig.RW_IDX + " == " + (headerRowCnt - 1));
			for(var idx = 0; idx < lastHds.length; idx++){
				var header = lastHds[idx];
				
				var rowIdx = header.getValue(moBindConfig.RW_IDX);
				var colIdx = header.getValue(moBindConfig.COL_IDX);
				var colNm = header.getValue(moBindConfig.COL_NM);
				
				var config = (function(colIndex, columnName) {
					return {
						constraint: {
							"rowIndex": 0,
							"rowSpan": 1,
							"colIndex": colIndex,
							"colSpan": 1
						},
						configurator: function(cell) {
							cell.columnName = columnName;
							//TODO 디테일 셀에 컨트롤을 동적으로 배치하는 경우 다음의 소스를 참고하십시오.
							/*
							 * cell.control = (function() {
							 * 	var output = new cpr.controls.Output();
							 * 	output.value = "";
							 * 	return output;
							 * })();
							 */
						}
					}
				})(colIdx, colNm);
				
				this._detailSettings.cells.push(config);
			}
		}
		
		DynamicGrid.prototype.init = function() {
			var grid = this._grid;
			
			/* 변수 초기화 */
			this._columnSettings = [];
			this._headerSettings = {};
			this._detailSettings = {};
		
			this._handleColumn();
			this._handleHeader();
			this._handleDetail();
			
			grid.init({
				dataSet : this._detailDataset,
				resizableColumns: "all",
				columns : this._columnSettings,
				header : this._headerSettings,
				detail : this._detailSettings
			});
		}
		
		/**
		 * 
		 * @param {cpr.controls.Grid} grid
		 * @param {
		 *   header : cpr.data.DataSet <!-- 그리드 헤더를 구성하는 데이터 셋 ID -->,
		 *   detail : cpr.data.DataSet <!-- 그리드에 연결될 데이터 셋 ID -->
		 * } config
		 */
		globals.createGrid = function(grid, config) {
			return new DynamicGrid(grid, config);
		}
	});
})();
/// end - module/DynamicGrid
/// start - module/extension
/*
 * Module URI: module/extension
 * SRC: module/extension.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/extension", function(exports, globals, module){
		/************************************************
		 * Control Wrapping Utils
		 * 각 사이트별 커스터마이징하여 사용 가능
		 * version 2.0
		 ************************************************/
		
		// 의존 모듈 선언.
		module.depends("module/common");
		
		/**
		 * Msg(메시지) 유틸
		 * @constructor
		 * @param {common.module} appKit
		 */
		function MsgKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 메시지 ID에 해당되는 메시지를 반환한다.
		 * @param {String} psMsgId  메시지 ID
		 * @param {String | Array} paArgs 메시지 내용 중 @로 표시된 부분 넣어줄 데이터 배열
		 * @return {String} 메시지 문자열
		 */
		MsgKit.prototype.getMsg = function(psMsgId, paArgs) {
		    if (psMsgId == null || psMsgId == "") return "";
		    var psMsg = cpr.I18N.INSTANCE.message("NLS-"+psMsgId);
		    if (psMsg == null || psMsg.indexOf("NLS-") >= 0) { return psMsgId.replace(/\\n/gi, "\n"); }
		    
		    if(!ValueUtil.isNull(paArgs)){
		    	if(!(paArgs instanceof Array)){
		    		paArgs = [paArgs];
		    	}
		    	//정규 표현식 사용하여 동적 메시지 치환
		    	var regExp = psMsg.match(/\{[0-9]+\}/ig);
				regExp.forEach(function(/* String */ exp){
					var idx = ValueUtil.fixNumber(exp.replace("{", "").replace("}", "").trim());
					psMsg = psMsg.replace(exp, new String(paArgs[idx]).replace(/\r\n/ig, ""));
				});
		    }
		    
		    return psMsg.replace(/\\n/ig, "\n");
		};
		
		/**
		 * 확인 선택용 Confirm 메시지 박스를 띄운다.
		 * <pre><code>
		 * Msg.confirm("CRM-M001");
		 * </code></pre>
		 * @param {String} psMsgId 메시지 ID
		 * @param {String | Array} paArgs (Optional)메시지 내용 중 @로 표시된 부분 넣어줄 데이터 배열
		 * @return {Boolean} Confirm 창의 확인 결과
		 */
		MsgKit.prototype.confirm = function(psMsgId, paArgs) {
			return confirm(this.getMsg(psMsgId, paArgs));
		};
		
		/**
		 * 메시지를 어플리케이션 화면 헤더 영역에 메시지를 보여준다.
		 * <pre><code>
		 * Msg.notify(app, "CMN-M001");
		 * </code></pre>
		 * @param {cpr.core.AppInstance} app - 앱인스턴스 객체
		 * @param {#lang} psMsgId 메시지ID
		 * @param {String | Array} paArgs (Optional)메시지 내용 중 @로 표시된 부분 넣어줄 데이터 배열
		 * @param {Boolean} pbKeep (Optional) 이전 메시지를 유지시킬지 여부
		 * @param {String} psMsgType (Optional) 출력타입 (생략가능) default : INFO
		 *                 INFO | WARNING | DENGER
		 * @return void
		 */
		MsgKit.prototype.notify = function(app, psMsgId, paArgs, psMsgType) {
		
			var voMsgInfo = {};
			voMsgInfo.TYPE = psMsgType;
			voMsgInfo.MSG = this.getMsg(psMsgId, paArgs);
			cpr.core.NotificationCenter.INSTANCE.post("app-msg", voMsgInfo);
			
			/* 헤더에 메시지 표현.
			var _app = this._appKit.getMainApp(app);
			_app = _app != null ? _app : app;
			
			var vaChildCtrls = _app.getContainer().getChildren();
			var vaSubChildCtrls = null;
			var appHeader = null;
			for (var i=0, len=vaChildCtrls.length; i<len; i++) {
		        if (vaChildCtrls[i] instanceof udc.com.appHeader ) {
		        	appHeader = vaChildCtrls[i];
		        	break;
		        }else if(vaChildCtrls[i].type == "container" && vaChildCtrls[i].style.getClasses().indexOf("header-box") != -1){
		        	vaSubChildCtrls = vaChildCtrls[i].getChildren();
		        	for (var j=0, jlen=vaSubChildCtrls.length; j<jlen; j++) {
		        		if (vaSubChildCtrls[j] instanceof udc.com.appHeader ) {
				        	appHeader = vaSubChildCtrls[j];
				        	break;
				        }
		        	}
		        	if(appHeader != null) break;
		        }
		    }
		    //갱신된 데이터가 조회되었습니다. 메시지 유지 여부 설정
		    if(!ValueUtil.isNull(_app.__keep_msg)){
		    	psMsgId = _app.__keep_msg;
		    	_app.__keep_msg = "";
		    }else{
		    	if(ValueUtil.fixBoolean(pbKeep)) app.__keep_msg = psMsgId;
				else _app.__keep_msg = "";
		    }
		    
		    if(appHeader){
		    	var embApp = appHeader.getEmbeddedAppInstance();
				var vcOptMsg = embApp.lookup("optAppMsg");
				var vcNotifier = embApp.lookup("notiInfo");
				var vsNotiMsg = this.getMsg(psMsgId, paArgs);
				if(vcNotifier.visible){
					vcNotifier.info(vsNotiMsg);
				}
				vcOptMsg.value = vsNotiMsg;
				vcOptMsg.style.animateFrom({
					"transform": "translateY(-30px) ",
					"opacity": "0"
				});
		    }*/
		};
		
		/**
		 * 메시지를 웹브라우저의 alert 메시지로 띄운다.
		 * <pre><code>
		 * Msg.alert("CMN-M001");
		 * </code></pre>
		 * @param {String} psMsgId 메시지ID
		 * @param {String | Array} paArgs (Optional)메시지 내용 중 @로 표시된 부분 넣어줄 데이터 배열
		 * @return void
		 */
		MsgKit.prototype.alert = function(psMsgId, paArgs) {
		    alert(this.getMsg(psMsgId, paArgs));
		};
		
		/**
		 * Dialog 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function DialogKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 모달(Modal) 팝업을 호출한다.
		 * <pre><code>
		 * Dialog.open(app, "app/cmn/CMN001", 700, 500, function(dialog){...}, {key1:"value1", key2:"value2"});
		 * </code></pre>
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#app} appid 팝업 화면 주소.
		 * @param {Number} width 팝업 창의 가로 사이즈.
		 * @param {Number} height 팝업 창의 세로 사이즈.
		 * @param {Function} handler 팝업이 닫힐 때 콜백함수(callback function).
		 * @param {Object} initValue (Optional) 초기 파라메터 key/value쌍으로 팝업창에 넘길 파라메터 JSON 데이터[ 예시)-{key1:"value1", key2:"value2"}]
		 * @param {object} prop (Optional) 팝업 설정 속성
		 * 		left			{number}  다이얼로그의 x좌표 default : 가운데 위치
		 * 		top				{number}  다이얼로그의 y좌표 default : 가운데 위치
		 * 		headerVisible	{boolean} 다이얼로그 헤더를 보이기 여부 default : true
		 * 		headerMovable	{boolean} 다이얼로그 헤더를 통해 이동 가능 여부 default : true
		 * 		headerClose		{boolean} 다이얼로그 헤더 close 버튼 보이기 여부 default : true
		 * 		resizable		{boolean} 다이얼로그 Rect 부분에 크기 조정 가능 여부 default : true
		 */
		DialogKit.prototype.open = function(app, appid, width, height, handler, initValue, prop) {
			if (initValue == null) {
				initValue = {};
			}
			
			//윈도우 최소 창크기보다 작은 경우... 윈도우 사이즈에 맞게 사이즈 조정
			var windowWidth = (window.innerWidth | document.body.clientWidth)-10;
			var windowHeight = (window.innerHeight | document.body.clientHeight)-45;
			if(windowWidth < width) width = windowWidth;
			if(windowHeight < height) height = windowHeight;
		
			var dialogProp = {
				width : Number(width) + 10,
				height : Number(height) + 45,
				headerVisible : (prop && prop.headerVisible != undefined) ? prop.headerVisible : true,
				headerMovable : (prop && prop.headerMovable != undefined) ? prop.headerMovable : true,
				headerClose : (prop && prop.headerClose != undefined) ? prop.headerClose : true,
				resizable : (prop && prop.resizable != undefined) ? prop.resizable : false
			};
			
			if(prop != null && prop.left) { dialogProp.left = prop.left; }
			if(prop != null && prop.top) { dialogProp.top = prop.top; }
		
			// App에서 Dialog
			app.getRootAppInstance().openDialog(appid, dialogProp, function(/* cpr.controls.Dialog */dialog) {
				dialog.app.isPopup = true;
				dialog.app.modal = true;
				dialog._originWidth = dialogProp["width"];
				dialog._originHeight = dialogProp["height"];
				
				initValue._dialogRef = dialog;
				
				if (dialog.app.title) { 
					dialog.headerTitle = dialog.app.title;
				}
				if (handler) {
					dialog.addEventListenerOnce("close", handler);
				}
				if (initValue) {
					dialog.initValue = initValue;
				}
			});
		};
		
		/**
		 * 모달리스(Modaless) 팝업을 호출한다.
		 * <pre><code>
		 * Dialog.open(app, "app/cmn/CMN001", 700, 500, function(dialog){...}, {key1:"value1", key2:"value2"});
		 * </code></pre>
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#app} appid 팝업 화면 주소.
		 * @param {Number} width 팝업 창의 가로 사이즈.
		 * @param {Number} height 팝업 창의 세로 사이즈.
		 * @param {Function} handler 팝업이 닫힐 때 콜백함수(callback function).
		 * @param {Object} initValue (Optional) 초기 파라메터 key/value쌍으로 팝업창에 넘길 파라메터 JSON 데이터[ 예시)-{key1:"value1", key2:"value2"}]
		 * @param {Object} prop (Optional) 팝업 설정 속성
		 * 		left			{number}  다이얼로그의 x좌표 default : 가운데 위치
		 * 		top				{number}  다이얼로그의 y좌표 default : 가운데 위치
		 * 		headerVisible	{boolean} 다이얼로그 헤더를 보이기 여부 default : true
		 * 		headerMovable	{boolean} 다이얼로그 헤더를 통해 이동 가능 여부 default : true
		 * 		headerClose		{boolean} 다이얼로그 헤더 close 버튼 보이기 여부 default : true
		 * 		resizable		{boolean} 다이얼로그 Rect 부분에 크기 조정 가능 여부 default : true
		 */
		DialogKit.prototype.openModaless = function(app, appid, width, height, handler, initValue, prop) {
			if (initValue == null) {
				initValue = {};
			}
			
			var dialogProp = {
				width : width,
				height : height,
				modal: false,
				headerVisible : (prop && prop.headerVisible) ? prop.headerVisible : true,
				headerMovable : (prop && prop.headerMovable) ? prop.headerMovable : true,
				headerMax : (prop && prop.headerMax) ? prop.headerMax : true,
				headerClose : (prop && prop.headerClose) ? prop.headerClose : true,
				resizable : (prop && prop.resizable) ? prop.resizable : true
			};
			
			if(prop != null && prop.left) { dialogProp.left = prop.left; }
			if(prop != null && prop.top) { dialogProp.top = prop.top; }
		
			app.getRootAppInstance().openDialog(appid, dialogProp, function(/* cpr.controls.Dialog */dialog) {
				dialog.app.isPopup = true;
				dialog.app.modal = false;
				if (dialog.app.title) { 
					dialog.headerTitle = dialog.app.title;
				}
				if (handler) {
					dialog.addEventListenerOnce("close", handler);
				}
				if (initValue) {
					dialog.initValue = initValue;
				}
			});
		};
		
		/**
		 * 현재 앱이 팝업인지 여부를 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @return {Boolean} true/false
		 */
		DialogKit.prototype.isPopup = function(app){
			return (!ValueUtil.isNull(app.getHost()) && app.app.isPopup === true) ? true : false;
		};
		
		
		/**
		 * window open
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {String} psUrl 팝업 URL
		 * @param {String} psPopId 팝업 ID
		 * @param {Number} width
		 * @param {Number} height
		 * @param {Number} top
		 * @param {Number} left
		 * @param {Boolean} isModal
		 * @return {Boolean} true/false
		 */
		DialogKit.prototype.windowOpen = function(app, psUrl,psPopId, width, height, top, left, isModal){
		
		   var vnWidth     = width == null ? window.screen.availWidth : width;
		   var vnHeight     = height == null ? window.screen.availHeight : height;
		   var vnTop       = top == null ? (window.screen.availHeight - height) / 2 : top;
		   var vnLeft      = left == null ? (window.screen.availWidth - width) / 2 : left;
		   var initValue   = {}
		    if (vnTop < 0)  vnTop  = 0;
		    if (vnLeft < 0) vnLeft = 0;
		   var vbIsModal = isModal == null ? false : isModal;
		   var vsProp = "menubar=0,resizable=yes,scrollbars=yes,status=0,top="+vnTop+",left="+vnLeft+",width="+vnWidth+",height="+vnHeight;
		
		   if(vbIsModal){
		   		var modalCtrl = new cpr.controls.Container("windowPopModal");
		   		modalCtrl.style.css({
		   			width: app.getRootAppInstance().getActualRect().width + "px",
		   			height: app.getRootAppInstance().getActualRect().height + "px",
		   			left: "0px",
		   			top: "0px",
		   			"background-color": "rgba(0,0,0,0.5)"
		   		});
		   		modalCtrl.addEventListener("click", function(e){
		   			e.preventDefault();
		   		});
		   		modalCtrl.addEventListener("contextmenu", function(e){
		   			e.preventDefault();
		   		});
		   		app.getRootAppInstance().floatControl(modalCtrl);
		   }
		
		   var openWindow = window.open("indexPopup.html?app=" + psUrl , psPopId, vsProp);
		   openWindow.onbeforeunload = function(e){
		   	 if(vbIsModal){
		   	 	if(app.getRootAppInstance().lookup("windowPopModal")){
		   	 		app.getRootAppInstance().lookup("windowPopModal").dispose();
		   	 	}
		   	 }
		   }
		   window._app = app;
		   return openWindow;
		
		//	if(openWindow){
		//		openWindow.parentApp = app;
		//	}
		////   openWindow.addEventListener("load", function(e){
		//		openWindow.parentApp = app;
		//	});
		};
		
		
		/**
		 * Group컨트롤 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function GroupKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 조회조건 및 작업영역 그룹 컨트롤 초기화 
		 * context-properties의 use.searchbox.clear 여부에 따라
		 *  - 조회영역내 조회조건 컨트롤의 selection-change, value-change시 작업영역(paDisableCtl) disable 및 그리드, 프리폼 초기화
		 *  - appHeader에서 공통 적용됨
		 *  - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container} psSearchBoxId  		 조회조건 영역 그룹컨트롤ID
		 * @param {#Container | Array} paDisableCtl	 조회조건 변경시 비활성화 처리되는 영역의 그룹 컨트롤ID
		 * @param {#uicontrol | Array} paExceptCtl  (Optional) 적용 제외 컨트롤 ID
		 * @return void
		 */
		GroupKit.prototype.initSearchBox = function(app, psSearchBoxId, paDisableCtl, paExceptCtl){
			//비활성화 영역 컨트롤
			paDisableCtl = paDisableCtl != null ? paDisableCtl : new Array();
			if(!(paDisableCtl instanceof Array)){
				paDisableCtl = [paDisableCtl];
			}
			//적용 제외 컨트롤 목록
			paExceptCtl = paExceptCtl != null ? paExceptCtl : new Array();
			if(!(paExceptCtl instanceof Array)){
				paExceptCtl = [paExceptCtl];
			}
			
			var _app = app;
			var _appKit = this._appKit;
			var vsSchBtnId = "btnSearch";
			
			paDisableCtl.forEach(function(item){
				var ctrl = _app.lookup(item);
				if(ctrl) ctrl.style.addClass("data-box");
			});
			
			function doAddSearchBoxEvent(ctrl){
				//조회버튼인 경우
				if ( ctrl.type == "button" && (ctrl.id && ctrl.id.match("btnSearch") || ctrl.value == "조회")){
					
					paExceptCtl.push(ctrl.id);
					vsSchBtnId = ctrl.id;
					ctrl.addEventListener("click", function(/* cpr.events.CEvent */ e){
						if(e.defaultPrevented === false){
							doShadowView(_app, true);					
						}
					});
				}else{
					if(ctrl.type == "button" || ctrl.type == "output" || ctrl.type == "img" || ctrl.visible === false || ctrl.readOnly === true) return;
					//년도는 중앙정렬
					if(ctrl.type == "numbereditor"){
						if(ctrl.spinButton != false && ctrl.style.css("text-align") == ""){
							ctrl.style.css({"text-align":"center"});
						}
						if((ctrl.format === "0000" || ctrl.format === "9999") && ctrl.max == 0){
							ctrl.max = 1.7976931348623157E308;
						}
					}
		
					/**
					 * 변경사항이 있는 경우
					 * 계속진행을 하시겠습니까? 에서 취소 선택시 업무단 value-change 이벤트가 호출되지 않게 하기 위해
					 * before 이벤드를 추가함.
					 */			
					var bfEventType = (ctrl.type == "combobox" || ctrl.type == "radiobutton") ? "before-selection-change" : "before-value-change";
					ctrl.addEventListener(bfEventType, function(e){
						if(_appKit.isAppModified(_app, "CRM")){
							return false;
						}else{
							return true;
						}
						return true;
					});
					var dmAppConfig = app.getRootAppInstance().callAppMethod("getAppConfig");
				    var vbUseSearchBoxClear = dmAppConfig.getValue("useSearchBoxClear") === "N" ? false : true;
				
					if(vbUseSearchBoxClear){
						var eventType = (ctrl.type == "combobox" || ctrl.type == "radiobutton") ? "selection-change" : "value-change";
						ctrl.addEventListener(eventType, function(e){
							
							//화면내의 모든 데이터 Clear
							var dataSets = _appKit.getAllAppModifiedDataSet(_app);
							if(dataSets != null && dataSets.length > 0){
								dataSets.forEach(function(ds){
									ds.clear();
								});
							}
							
							//헤더 내의 버튼 비활성화
							var header = _appKit.Group.getAllChildrenByType(_app, "udc.com.appHeader");
							if(header != null && header.length > 0){
								var vcCtrl = header[0].getEmbeddedAppInstance().lookup("grpButtons");
								if(vcCtrl) vcCtrl.enabled = false;
							}
							
							doShadowView(_app, false);
						});
					}
					
					//인풋박스 컨트롤 Keydown 이벤트 추가
					if(ctrl.type == "inputbox" && ctrl.userAttr("autoKeydownSearch") == "Y"){
						ctrl.addEventListener("keydown", function(/* cpr.events.CKeyboardEvent */ e){
							if(e.keyCode == cpr.events.KeyCode.ENTER){
								//Enter키 입력시, 조회 버튼 클릭 이벤트 발생
								_appKit.Control.dispatchEvent(app, vsSchBtnId, "click");
								//_appKit.Header.dispatchEvent(app, "btnSearch", "click");
								var comBtnSch = _appKit.Group.getAllChildrenByType(app, "udc.com.comBtnSearch");
								if(comBtnSch != null && comBtnSch.length > 0){
									var vcCtrl = comBtnSch[0].getEmbeddedAppInstance().lookup(vsSchBtnId);
									if(vcCtrl){
										vcCtrl.dispatchEvent(new cpr.events.CEvent("click"));
									}
								}
							}
						});
					}
				}
			}
			
			function doShadowView(app, pbEnable){
				if(paDisableCtl.length > 0){
		//			setTimeout(function(){
						_appKit.Control.setEnable(app, pbEnable, paDisableCtl);
		//			}, 50);
				}else{
					if(pbEnable === false){
						if(_app.lookup("grpSchShell") == null){
							var disableCtl = new cpr.controls.Container("grpSchShell");
							disableCtl.style.css({"background-color":"#ededed", "opacity":"0.2"});
							disableCtl.setLayout(new cpr.controls.layouts.XYLayout());
							/** @type cpr.controls.Container */
							var vcSearchBox = _app.lookup(psSearchBoxId);
							var heightPosix = vcSearchBox.getActualRect()["height"];
							_app.getContainer().addChild(disableCtl, {
										"top": (Number(heightPosix)+35)+"px",
										"right": "5px",
										"bottom": "5px",
										"left": "5px"
									});
						}
					}else{
						_app.getContainer().removeChild(_app.lookup("grpSchShell"), true);
					}
				}
			}
			
			var initFocus = false;
			function doFocusCtrl(poCtrl){
				if(poCtrl.type == "button" || poCtrl.type == "output" || poCtrl.type == "img") return;
				
				if(!initFocus){
					poCtrl.focus();
					initFocus = true;
				}
			}
			var vaSearchBoxIds = ValueUtil.split(psSearchBoxId, ",");
			for(var z=0, zlen=vaSearchBoxIds.length; z<zlen; z++){
				/** @type cpr.controls.Container */
				var vcSearchBox = app.lookup(vaSearchBoxIds[z]);
				if(vcSearchBox){
					var childCtrls = _appKit._getChildren(vcSearchBox);
					for (var i=0, len=childCtrls.length; i<len; i++) {
						//udc컨트롤일 경우.
						if(childCtrls[i] instanceof cpr.controls.UDCBase){
							var embApp = childCtrls[i].getEmbeddedAppInstance();
							embApp.getContainer().getChildren().some(function(ctrl){
								if(ctrl instanceof cpr.controls.Container){
									ctrl.getChildren().some(function(subCtrl){
										doAddSearchBoxEvent(subCtrl);
										doFocusCtrl(subCtrl);
									});
								}else{
									doAddSearchBoxEvent(ctrl);
									doFocusCtrl(ctrl);
								}
							});
						}else{
							//이벤트 추가
							doAddSearchBoxEvent(childCtrls[i]);
							//포커싱
							doFocusCtrl(childCtrls[i]);
						}
					}
					
					doShadowView(_app, false);
				}
			}
		};
		
		/**
		 * 해당 그룹 컴포넌트 내의 DataColumn에 바인딩된 컨트롤 객체를 반환한다.
		 * 이는 프리폼 내의 DataColumn의 값을 갖는(바인딩) 컨트롤을 찾기 위해 사용된다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container} psGrpId 그룹ID
		 * @param {String} psDataColumnNm datacolumn 명
		 * @return {Object} 컨트롤 객체
		 */
		GroupKit.prototype.getDataBindedControl = function(app, psGrpId, psDataColumnNm){
			/** @type cpr.controls.Container */
			var _grpKit = this._appKit.Group;
			var vcFrf = app.lookup(psGrpId);
			var vaChild = vcFrf.getChildren();
			var vcBindCtrl = null;
			vaChild.some(function(ctrl, idx){
				if(vcBindCtrl) return true;
				
				if(ctrl.type == "container") vcBindCtrl = _grpKit.getDataBindedControl(app, ctrl.id, psDataColumnNm);
				if(ctrl.type == "output") return false;
				var bind = ctrl.getBindInfo("value");
				if(bind && bind.type == "datacolumn" && psDataColumnNm === bind.columnName){
					if(ctrl instanceof cpr.controls.UDCBase){
						vcBindCtrl = AppUtil.getUDCBindValueControl(ctrl);
					}else{
						vcBindCtrl = ctrl;
					}
					
					return true;
				}
			});
			
			return vcBindCtrl;
		};
		
		/**
		 * 그룹 또는 컨테이너 내의 특정 타입에 해당하는 자식 컨트롤을 취득한다.
		 * (사용처) 해당 화면내의 특정 유형의 컨트롤 목록을 얻고자 하는 경우에 사용
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {String} psCtlType		 컨트롤 타입(ex: grid)
		 * @param {cpr.controls.Container} poContainer 		자식 컨트롤을 취득하고자 하는 부모 컨테이너 객체  	
		 * @param {Boolean} pbRecursive		(Optional) 자식 컨테이너를 Recusive하게 찾을건지 여부
		 * @return {Array} 자식 컨트롤 객체 배열
		 */
		GroupKit.prototype.getAllChildrenByType = function(app, psCtlType, poContainer, pbRecursive) {
			var vaTypesChild = new Array();
			
			var container = app.getContainer();
			function getChildRecursive(psCtlType, poContainer){
			    var vaChildCtrls = poContainer ? (pbRecursive === true ? poContainer.getAllRecursiveChildren() : poContainer.getChildren()) : (pbRecursive === true ? container.getAllRecursiveChildren() : container.getChildren());
			    for (var i=0, len=vaChildCtrls.length; i<len; i++) {
			        if (vaChildCtrls[i].type == psCtlType) {
			        	vaTypesChild.push(vaChildCtrls[i]);
			        }else if (vaChildCtrls[i] instanceof cpr.controls.Container ) {
			        	getChildRecursive(psCtlType, vaChildCtrls[i]);
			        }else if(vaChildCtrls[i] instanceof cpr.controls.UDCBase){
			        	var voUdcApp = vaChildCtrls[i].getEmbeddedAppInstance();
			        	if(voUdcApp) getChildRecursive(psCtlType, voUdcApp.getContainer());
			        }else if(vaChildCtrls[i] instanceof cpr.controls.EmbeddedApp){
			        	var voEmbApp = vaChildCtrls[i].getEmbeddedAppInstance();
			        	if(voEmbApp) getChildRecursive(psCtlType, voEmbApp.getContainer());
			        }
			    }
			    vaChildCtrls = null;
			}
			
			getChildRecursive(psCtlType, poContainer);
			
			return vaTypesChild;
		};
		
		/**
		 * 그룹 또는 컨테이너 내의 특정 ID를 갖는 자식 컨트롤을 취득한다.
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {Array} paCtrlIds		 컨트롤 ID 배열
		 * @param {cpr.controls.Container} poContainer 	(Optional) 자식 컨트롤을 취득하고자 하는 부모 컨테이너 객체  	
		 * @return {Array} 자식 컨트롤 객체 배열
		 */
		GroupKit.prototype.getControlByID = function(app, paCtrlIds, poContainer) {
			if(!(paCtrlIds instanceof Array)){
				paCtrlIds = [paCtrlIds];
			}
			var vaChildCtrls = new Array();
			var container = poContainer ? poContainer : this._appKit.getMainApp(app).getContainer();
			function getChildRecursive(paCtrlIds, poContainer){
			    var childCtrls = poContainer.getAllRecursiveChildren();
			    for (var i=0, len=childCtrls.length; i<len; i++) {
			        if (paCtrlIds.indexOf(childCtrls[i].id) != -1) {
			        	vaChildCtrls.push(childCtrls[i]);
			        }else if(childCtrls[i] instanceof cpr.controls.UDCBase){
			        	var voUdcApp = childCtrls[i].getEmbeddedAppInstance();
			        	if(voUdcApp) getChildRecursive(paCtrlIds, voUdcApp.getContainer());
			        }else if(childCtrls[i] instanceof cpr.controls.EmbeddedApp){
			        	var voEmbApp = childCtrls[i].getEmbeddedAppInstance();
			        	if(voEmbApp) getChildRecursive(paCtrlIds, voEmbApp.getContainer());
			        }
			    }
			}
			
			getChildRecursive(paCtrlIds, container);
			
			return vaChildCtrls;
		};
		
		/**
		 * 그룹 컨트롤에 바인딩된 데이터셋을 반환한다.
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {cpr.controls.Container} poContainer 		자식 컨트롤을 취득하고자 하는 부모 컨테이너 객체 
		 * @return {cpr.data.DataSet} 바인딩된 데이터셋 객체
		 */
		GroupKit.prototype.getBindDataSet = function(app, poContainer){
			/**@type cpr.data.DataSet */
			var voDataSet = null;
			/** @type cpr.bind.BindContext */
			var voBindContext = this.getBindContext(app, poContainer);
			if(voBindContext instanceof cpr.bind.GridSelectionContext){
				voDataSet = voBindContext.grid.dataSet;
			}else if(voBindContext instanceof cpr.bind.DataRowContext){
				voDataSet = voBindContext.dataSet;
			}
			
			return voDataSet;
		};
		
		/**
		 * 그룹 컨트롤의 바인딩 문맥(Context) 객체를 반환한다.
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {cpr.controls.Container} poContainer 		자식 컨트롤을 취득하고자 하는 부모 컨테이너 객체 
		 * @return {cpr.bind.BindContext} 바인딩 Context 객체
		 */
		GroupKit.prototype.getBindContext = function(app, poContainer){
			/** @type cpr.bind.BindContext */
			var voBindContext = poContainer.getBindContext();
			if(voBindContext == null || voBindContext == undefined){
				var vaChildCtrls = this.getAllChildrenByType(app, "container", poContainer);
				vaChildCtrls.forEach(function(/* Object */ ctrl){
					if(ctrl.getBindContext()){
						voBindContext = ctrl.getBindContext();
						return true;
					}
				});
			}
			
			return voBindContext;
		};
		
		/**
		 * FreeForm컨트롤 유틸
		 * - 일반적으로 그리드가 바인딩되었거나 데이터셋을 사용하는 폼레이아웃 컨트롤에 적용.
		 * - 그리드 + 상세(폼레이아웃) 화면에서 주로 사용 
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function FreeFormKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 프리폼 컨트롤들에 대해 초기화 로직을 수행한다.
		 *  - appHeader에서 공통 적용됨
		 *  - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container | Array} paFreeFormId 프리폼 ID 또는 ID배열
		 */
		FreeFormKit.prototype.init = function(app, paFreeFormId) {
			if(!(paFreeFormId instanceof Array)){
				paFreeFormId = [paFreeFormId];
			}
			var vcForm = null, voBindContext = null, voDs = null;
			var voMap = new cpr.utils.ObjectMap();
			var voBindMap = new cpr.utils.ObjectMap();
			for(var i=0, len=paFreeFormId.length; i<len; i++){
				/**@type cpr.controls.Container */
				vcForm = app.lookup(paFreeFormId[i]);
				if(vcForm == null) continue;
				
				voBindContext = this._appKit.Group.getBindContext(app, vcForm);
				voDs = voBindContext.grid ? voBindContext.grid.dataSet : voBindContext.dataSet;
				vcForm._originEnabled = vcForm.enabled;
				if(vcForm.getBindInfo("enabled") != null){
					vcForm._expressEnabled = vcForm.getBindInfo("enabled").expression;
				}
				if(voDs._freeforms){
					voDs._freeforms.push(vcForm.id);
				}else{
					voDs._freeforms = [vcForm.id];
				}
				var childCtrls = vcForm.getAllRecursiveChildren();
				childCtrls.forEach(function(ctrl){
					if(ctrl.type == "numbereditor"){
						if(ctrl.spinButton != false && ctrl.style.css("text-align") == ""){
							ctrl.style.css({"text-align":"center"});
						}
						if((ctrl.format === "0000" || ctrl.format === "9999") && ctrl.max == 0){
							ctrl.max = 1.7976931348623157E308;
						}
					}
				});
				
				if(voMap.get(voDs.id) == null){
					voMap.put(voDs.id, voDs);
				}
				
				if(voBindContext.grid == null && voBindMap.get(voDs.id) == null){
					voBindMap.put(voDs.id, voDs);
					voDs.stateRestore = true; //현재값과 Origin이 같으면... 변경없도록 처리
				}
			}
			
			var _app = app, _appKit = this._appKit;
			voMap.keys().forEach(function(key){
				voMap.get(key).addEventListener("load", function(/* cpr.events.CDataEvent */e){
					var dataset = e.control;
					var freeforms = dataset._freeforms;
					freeforms.forEach(function(/* eachType */ formId){
						/**@type cpr.controls.Container */
						var form = _app.lookup(formId);
						//데이터가 없으면... 프리폼 비활성화
						if(dataset.getRowCount() < 1) {
							if(form._expressEnabled){
								form.unbind("enabled");
							}
							form.enabled = false;
						}else{
							//데이터가 있으면 있고, 조회권한이 아니고... 프리폼 활성화
							if(!_appKit.Auth.isReadUseAuth(_app) && form._originEnabled !== false){
								if(form._expressEnabled){
									form.bind("enabled").toExpression(form._expressEnabled);
								}else{
									form.enabled = true;
								}
							}
						}
					});
				});
				
				voMap.get(key).addEventListener("filter", function(/* cpr.events.CDataEvent */e){
					var dataset = e.control;
					var freeforms = dataset._freeforms;
					freeforms.forEach(function(/* eachType */ formId){
						/**@type cpr.controls.Container */
						var form = _app.lookup(formId);
						//데이터가 없으면... 프리폼 비활성화
						if(dataset.getRowCount() < 1) {
							if(form._expressEnabled){
								form.unbind("enabled");
							}
							form.enabled = false;
						}else{
							//데이터가 있으면 있고, 조회권한이 아니고... 프리폼 활성화
							if(!_appKit.Auth.isReadUseAuth(_app) && form._originEnabled !== false){
								if(form._expressEnabled){
									form.bind("enabled").toExpression(form._expressEnabled);
								}else{
									form.enabled = true;
								}
							}
						}
					});
				});
			});
		};
		
		
		/**
		 * 프리폼에 신규 행(Row)을 추가한다.
		 *  - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container} psFreeFormId 프리폼 ID
		 * @param {String} psEditCol 신규 이후 포커스 COLUMN명
		 * @param {Number} pnRowIdx (Optional) 추가하고자 하는 Row index
		 *                 defalut : 현재 선택된 로우 이후
		 * @param {Object} poRowData (Optional) 추가할 row data. (key: header명, value: value 를 갖는 json data)
		 * @return {cpr.controls.provider.GridRow} 추가한 Row의 GridRow 객체.
		 */
		FreeFormKit.prototype.insertRow = function(app, psFreeFormId, psEditCol, pnRowIdx, poRowData) {
			/**@type cpr.controls.Container */
			var vcForm = app.lookup(psFreeFormId);
			var voBindContext = this._appKit.Group.getBindContext(app, vcForm);
			
			var vcGrid = voBindContext.grid;
			var voDs = voBindContext.grid ? voBindContext.grid.dataSet : voBindContext.dataSet;
			/**@type cpr.controls.Tree */
			var vcTree = app.lookup(voDs._treeId);
			var rowIndex = -1;
			if(!ValueUtil.isNull(pnRowIdx)){
				rowIndex = pnRowIdx;
			}else{
				if(vcTree){
					rowIndex = vcTree.getIndex(vcTree.getSelectionFirst());
				}else{
					rowIndex = voBindContext.grid ? this._appKit.Grid.getIndex(app, voBindContext.grid.id) : voBindContext.rowIndex;
				}
			}
			
			// InsertRow
			var insertedRow = null;
			if(poRowData != null){
				insertedRow = voDs.insertRowData(rowIndex, true, poRowData);
			}else{
				if(vcTree){
					// 트리
					var vsSelVal = ValueUtil.fixNull(vcTree.value);
					
					var voRow = {};
					voRow[vcTree.itemSetConfig.label] = "";
					voRow[vcTree.itemSetConfig.value] = "";
					voRow[vcTree.itemSetConfig.parentValue] = vsSelVal;
					
					insertedRow = voDs.insertRowData(rowIndex, true, voRow);
					if(vsSelVal != ""){
						var voItem = vcTree.getItemByValue(vsSelVal);
						vcTree.expandItem(voItem);
					}
				}else{
					insertedRow = voDs.insertRow(rowIndex, true);
				}
			}
			
			// SelectRow
			if(vcTree){
				// 트리
				vcTree.selectItemByValue("DEFAULT", true);
				vcTree.focusItem(vcTree.getItem(insertedRow.getIndex()));
			}else if(vcGrid){
				// 그리드
		//		vcGrid.selectRows(-1, false);
				vcGrid.clearSelection();
				vcGrid.selectRows(insertedRow.getIndex(), true);
			}else{
				// 프리폼
				vcForm.redraw();
			}
			if(vcForm._expressEnabled){
				vcForm.bind("enabled").toExpression(vcForm._expressEnabled);
			}else{
				vcForm.enabled = true;
			}
			
			// Focus
			if(psEditCol){
				var vcCtrl = this._appKit.Group.getDataBindedControl(app, vcForm.id, psEditCol);
				if(vcCtrl) vcCtrl.focus();
			}
			
			return insertedRow;
		};
		
		/**
		 * 프리폼에 행(Row)을 삭제한다.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container} psFreeFormId 프리폼 ID
		 * @param {String} psAftMsg (Optional) 메시지 유형(CRM)
		 * @return void
		 */
		FreeFormKit.prototype.deleteRow = function(app, psFreeFormId, psAftMsg) {
			var _this = this;
			/** @type cpr.controls.Container */
			var vcForm = app.lookup(psFreeFormId);
			/** @type cpr.bind.BindContext */
			var voBindContext = this._appKit.Group.getBindContext(app, vcForm);
			
			var voDs = voBindContext.grid ? voBindContext.grid.dataSet : voBindContext.dataSet;
			var vcGrid = voBindContext.grid;
			/** @type cpr.controls.Tree */
			var vcTree = app.lookup(voDs._treeId);
			var rowIndex = voBindContext.grid ? this._appKit.Grid.getIndex(app, voBindContext.grid.id) : voBindContext.rowIndex;
			if(voDs == null || voDs.getRowCount() < 1){
				//삭제할 데이터가 없습니다.
				this._appKit.Msg.alert("INF-M007");
			}else{
				if(!ValueUtil.isNull(psAftMsg)){
					//삭제하시겠습니까?
					if(this._appKit.Msg.confirm("CRM-M002")){
						if(voDs.getRowState(rowIndex) == cpr.data.tabledata.RowState.INSERTED){
							
							voDs.revertRow(rowIndex);
							vcForm.redraw();
							if(vcGrid){
								vcGrid.redraw();
								//가장 마지막 행에서 신규 행 추가 후, 삭제할 경우에 가장 마지막 행을 선택해줌
								if(voDs.getRowCount() -1 < rowIndex){
									vcGrid.selectRows([rowIndex-1]);
								}
							} 
							if(vcTree) vcTree.redraw();
							//데이터 건수가 없으면... 프리폼 비활성화
							if(voDs.getRowCount() < 1) {
								vcForm.enabled = false;
							}
							return false;
						}else{
							voDs.setRowState(rowIndex, cpr.data.tabledata.RowState.DELETED);
							return true;
						}
					}
				}else{
					if(voDs.getRowState(rowIndex) == cpr.data.tabledata.RowState.INSERTED){
						voDs.revertRow(rowIndex);
					}else{
						voDs.setRowState(rowIndex, cpr.data.tabledata.RowState.DELETED);
					}
				}
			}
			
			return false;
		};
		
		/**
		 * 프리폼에 바인딩된 값을 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container} psFreeFormId 프리폼 ID
		 * @param {String} psColumnName 컬럼명
		 * @return {String} 프리폼의 컬럼값
		 */
		FreeFormKit.prototype.getValue = function(app, psFreeFormId, psColumnName){
			/** @type cpr.controls.Container */
			var vcForm = app.lookup(psFreeFormId);
			var voBindContext = this._appKit.Group.getBindContext(app, vcForm);
			/** @type cpr.data.DataSet */
			var voDs = voBindContext.grid ? voBindContext.grid.dataSet : voBindContext.dataSet;
			var rowIndex = voBindContext.grid ? this._appKit.Grid.getIndex(app, voBindContext.grid.id) : voBindContext.rowIndex;
			
			return voDs.getValue(rowIndex, psColumnName);
		};
		
		/**
		 * 프리폼에 바인딩된 값을 변경한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container} psFreeFormId 프리폼 ID
		 * @param {String} psColumnName 컬럼명
		 * @param {String} psValue 변경하고자 하는 값.
		 * @return void
		 */
		FreeFormKit.prototype.setValue = function(app, psFreeFormId, psColumnName, psValue){
			/** @type cpr.controls.Container */
			var vcForm = app.lookup(psFreeFormId);
			var voBindContext = this._appKit.Group.getBindContext(app, vcForm);
			/** @type cpr.data.DataSet */
			var voDs = voBindContext.grid ? voBindContext.grid.dataSet : voBindContext.dataSet;
			var rowIndex = voBindContext.grid ? this._appKit.Grid.getIndex(app, voBindContext.grid.id) : voBindContext.rowIndex;
			
			voDs.setValue(rowIndex, psColumnName, psValue);
			vcForm.redraw();
		};
		
		/**
		 * 프리폼 내의 특정 컬럼을 포커싱한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container} psFreeFormId 프리폼 ID
		 * @param {String} psColumnName 포커싱할 컬럼명
		 */
		FreeFormKit.prototype.setFocus = function(app, psFreeFormId, psColumnName){
			/** @type cpr.controls.Container */
			var vcForm = app.lookup(psFreeFormId);
			
			var vcCtrl = this._appKit.Group.getDataBindedControl(app, vcForm.id, psColumnName);
			if(vcCtrl) this._appKit.Control.setFocus(app, vcCtrl.id);
		};
		
		/**
		 * 프리폼의 변경사항을 되돌린다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container} psFreeFormId  해당 그룹 아이디
		 * @param {Number} pnRowIndex (Optional) 되돌릴 행의 index
		 * @param {String} psEditCol (Optional) 포커싱할 컬럼명
		 * @return void
		 */
		FreeFormKit.prototype.revertRow = function(app, psFreeFormId, pnRowIndex, psEditCol){
			/**@type cpr.controls.Container */
			var vcForm = app.lookup(psFreeFormId);
			var voBindContext = this._appKit.Group.getBindContext(app, vcForm);
			/**@type cpr.controls.Grid */
			var vcGrid = voBindContext.grid;
			/**@type cpr.data.DataSet */
			var voDs = voBindContext.grid ? voBindContext.grid.dataSet : voBindContext.dataSet;
			debugger;
			var vnRowIndex = 0;
			if(!ValueUtil.isNull(pnRowIndex)){
				vnRowIndex = pnRowIndex;
			}else{
				if(vcGrid) vnRowIndex = this._appKit.Grid.getIndex(vcGrid.getAppInstance(), vcGrid.id);
				else vnRowIndex = voBindContext.rowIndex;
			}
			//데이터 Revert
			var rowData = voDs.getRow(vnRowIndex).getRowData();
			var vsGridRowState = vcGrid.getRowState(vnRowIndex);
			for(var column in rowData){
				voDs.setValue(vnRowIndex, column, voDs.getOriginalValue(vnRowIndex, column));
			}
			//2019.11.21 추가
			if(vsGridRowState == cpr.data.tabledata.RowState.INSERTED){
				vcGrid.setRowState(vnRowIndex, vsGridRowState);
			}
			var vcTree = app.lookup(voDs._treeId); 
				
			if(vcGrid) vcGrid.redraw();
			if(vcTree) vcTree.redraw();
			vcForm.redraw();
			
			if(!ValueUtil.isNull(psEditCol)){
				var vcCtrl = this._appKit.Group.getDataBindedControl(app, vcForm.id, psEditCol);
				if(vcCtrl) vcCtrl.focus();
			}
		};
		
		/**
		 * 프리폼의 변경사항을 되돌린다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container} psFreeFormId  해당 그룹 아이디
		 * @return void
		 */
		FreeFormKit.prototype.revertAllData = function(app, psFreeFormId){
			/**@type cpr.controls.Container */
			var vcForm = app.lookup(psFreeFormId);
			var voBindContext = this._appKit.Group.getBindContext(app, vcForm);
			
			var vcGrid = voBindContext.grid;
			var voDs = voBindContext.grid ? voBindContext.grid.dataSet : voBindContext.dataSet;
			var vcTree = app.lookup(voDs._treeId); 
			
			//데이터 Revert
			voDs.revert();
				
			if(vcGrid) vcGrid.redraw();
			if(vcTree) vcTree.redraw();
			vcForm.redraw();
		};
		
		/**
		 * 그룹의 변경사항 유/무를 반환를 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Container | Array} paFreeFormId 프리폼 ID
		 * @param {String} psAftMsg  (Optional) MSG or CRM
		 *						MSG : 변경사항 내역이 없을 경우 '변경된 내역이 없습니다.' 메세지 출력
		 *  					CRM : 변경내역이 존재할경우 '변경사항이 반영되지 않았습니다. 계속 하시겠습니까?' confirm 메시지출력 
		 * @return {Boolean} 데이터 변경 여부
		 */
		FreeFormKit.prototype.isModified = function(app, paFreeFormId, psAftMsg){
			if(!(paFreeFormId instanceof Array)){
				paFreeFormId = [paFreeFormId];
			}
			
			psAftMsg = psAftMsg == null ? "" : psAftMsg;
			
			var modify = false;
			var vcGroup = null;
			for (var i=0, len=paFreeFormId.length; i<len; i++) {
				if(paFreeFormId[i] instanceof cpr.controls.Container) {
					vcGroup = paFreeFormId[i];
				}else{
					vcGroup = app.lookup(paFreeFormId[i]);
				}
				
				var voDataSet = this._appKit.Group.getBindDataSet(app, vcGroup);
				if(voDataSet != null && voDataSet.isModified()) {
					modify = true;
					break;
				}
			}
			
			if(modify){
				if(psAftMsg.toUpperCase() == "CRM"){//변경사항이 반영되지 않았습니다. 계속 하시겠습니까? confirm
					if(!this._appKit.Msg.confirm("CRM-M003", [vcGroup.fieldLabel])) return true;
					else return false;
				}
			}else{
				if(psAftMsg.toUpperCase() == "MSG"){//변경된 내역이 없습니다.
					this._appKit.Msg.notify(app, "INF-M006");
				}
			}
			
			return modify;
		};
		
		
		/**
		 * 리스트 형태 컨트롤 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function SelectKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 입력한 index의 위치에 새로운 item을 추가한다.
		 * <pre><code>
		 * SelectCtl.addItem(app, "cmb1", "라벨1", "값1");
		 * </code></pre>
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {#uicontrol} psCtlId		 select ID (only Combo, List, Radio, CheckBox Group)
		 * @param {String} psLabel		 추가할 item의 label
		 * @param {String} psValue		 추가할 item의 value
		 * @param {Number} pnIndex (Optional) 추가할 item의 index (default는 마지막 행 뒤에 추가됨)
		 * @return void 
		 */
		SelectKit.prototype.addItem = function(app, psCtlId, psLabel, psValue, pnIndex){
			/** @type cpr.controls.ComboBox */
			var vcCtl = app.lookup(psCtlId);
			var item;
			
			if(ValueUtil.isNull(pnIndex)){
				vcCtl.addItem(new cpr.controls.Item(psLabel, psValue));
			}else{
				if(pnIndex >= 0 && pnIndex <= vcCtl.getItemCount()){
					if(pnIndex == 0){
						item = vcCtl.getItem(pnIndex);
						vcCtl.insertItemBefore(new cpr.controls.Item(psLabel, psValue), item);
					} else {
						item = vcCtl.getItem(pnIndex - 1);
						vcCtl.insertItemAfter(new cpr.controls.Item(psLabel, psValue), item);
					}
				}
			}
		};
		
		/**
		 * 지정한 인덱스(Index)의 아이템 라벨(label)을 반환한다.
		 * multiple "true"의 경우 index에 해당하는 여러 라벨값을 알고자 할 때, pnIndex는 구분자를 기준으로 조인된 String 형태를 가진다.
		 * <pre><code>
		 * SelectCtl.getItemLabel(app, "cmb1", "1,2,3");
		 * </code></pre>
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {#uicontrol} psCtlId		컨트롤ID
		 * @param {Number} pnIndex		(Optional) 인덱스 번호
		 * @return {String | Array}	multiple : true 일 경우 Array(String)
		 * 										   false 일 경우 String
		 */
		SelectKit.prototype.getItemLabel = function(app, psCtlId, pnIndex){
			var vcCtl = app.lookup(psCtlId);
			if(ValueUtil.isNull(pnIndex)){
				var item = vcCtl.getSelectionFirst();
				return item ? item.label : "";
			}else{
				if(vcCtl.multiple){//다중 선택 가능한 경우 라벨 배열 반환
					var vaIdx = ValueUtil.split(pnIndex, ",");
					for(var i=0, len=vaIdx.length; i<len; i++){
						vaIdx[i] = vcCtl.getItem(vaIdx[i]).label;
					}
					return vaIdx;
				}else{
					return vcCtl.getItem(pnIndex).label;
				}
			}
		};
		
		/**
		 * 지정한 인덱스(Index)의 아이템 값(value)을 반환한다.
		 * multiple "true"의 경우 index에 해당하는 여러 value 값을 알고자 할 때, pnIndex는 구분자를 기준으로 조인된 String 형태를 가진다.
		 * <pre><code>
		 * SelectCtl.getItemValue(app, "cmb1", "1,2,3");
		 * </code></pre>
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {#uicontrol} psCtlId		컨트롤ID
		 * @param {Number} pnIndex		(Optional) 인덱스 번호
		 * @return {String | Array}	multiple : true 일 경우 Array(String)
		 * 										   false 일 경우 String
		 */
		SelectKit.prototype.getItemValue = function(app, psCtlId, pnIndex){
			/**@type cpr.controls.ComboBox */
			var vcCtl = app.lookup(psCtlId);
			if(ValueUtil.isNull(pnIndex)){
				var item = vcCtl.getSelectionFirst();
				return item ? item.value : "";
			}else{
				if(vcCtl.multiple){//다중 선택 가능한 경우 값 배열 반환
					var vaIdx = ValueUtil.split(pnIndex, ",");
					for(var i=0, len=vaIdx.length; i<len; i++){
						vaIdx[i] = vcCtl.getItem(vaIdx[i]).value;
					}
					return vaIdx;
				}else{
					return vcCtl.getItem(pnIndex).value;
				}
			}
		};
		
		/**
		 * 현재 선택 중인 아이템의 index를 반환한다.
		 * multiple "true"의 경우, index는 배열의 형태로 반환된다.
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {#uicontrol} psCtlId		select ID
		 * @return {Number | Array}	multiple : true 일 경우 Array(Number)
		 * 										   false 일 경우 Number 		
		 */
		SelectKit.prototype.getSelectedIndex = function(app, psCtlId){
			/** @type cpr.controls.ComboBox */
			var vcCtl = app.lookup(psCtlId);
			var vaItems = vcCtl.getSelection();
			if(vcCtl.multiple){
				var vaIndices = new Array();
				for(var i=0, len=vaItems.length; i<len; i++){
					vaIndices.push(vcCtl.getIndex(vaItems[i]));
				}
				return vaIndices;
			}else{
				return vcCtl.getIndex(vaItems[0]);
			}
		};
		
		/**
		 * 인덱스(Index) 또는 value에 해당하는 아이템(Item)을 선택한다.
		 * multiple "true"의 경우 여러 개의 아이템을 선택하고자 할 때, puRowIdx는 구분자를 기준으로 조인된 String 형태를 가진다.
		 * <pre><code>
		 * SelectCtl.selectItem(app, "cmb1", "0");
		 * 또는
		 * SelectCtl.selectItem(app, "cmb1", "값1,값2,값3");
		 * </code></pre>
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {#uicontrol} psCtlId		컨트롤ID
		 * @param {String | Array} puRowIdx 인덱스 또는 value 값
		 * @param {Boolean} emitEvent (Optional) 이벤트(before-selection-change, selection-change)를 발생시킬지 여부
		 * @return {Boolean} 성공여부
		 */
		SelectKit.prototype.selectItem = function(app, psCtlId, puRowIdx, emitEvent){
			/**@type cpr.controls.CheckBoxGroup */
			var vcCtl = app.lookup(psCtlId);
			
			if(vcCtl == null || vcCtl == undefined) return false;
			
			puRowIdx = ValueUtil.split(puRowIdx, ",");
			if(vcCtl.multiple){//다중 선택 가능한 경우
				if(puRowIdx.length > 0){
					if(!ValueUtil.isNumber(puRowIdx[0])){
						for(var i=0, len=puRowIdx.length; i<len; i++){
							puRowIdx[i] = vcCtl.getIndexByValue(puRowIdx[i]);
						}
					}
					vcCtl.selectItems(puRowIdx, emitEvent);
				}
			}else{
				if(puRowIdx.length > 0){
					if(!ValueUtil.isNumber(puRowIdx[0])){
						var item = vcCtl.getItemByValue(puRowIdx[0]);
						if(item) vcCtl.selectItemByValue(puRowIdx[0], emitEvent);
						else vcCtl.selectItem(0, emitEvent);
					} else {
						if(Number(puRowIdx[0]) >= vcCtl.getItemCount()){
							vcCtl.selectItem(0, emitEvent);
						}else{
							vcCtl.selectItem(puRowIdx[0], emitEvent);
						}
					}
				}
			}
			
			return true;
		};
		
		/**
		 * 모든 아이템을 선택한다.
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {#uicontrol} psCtlId	컨트롤ID
		 * @return void
		 */
		SelectKit.prototype.selectAllItem = function(app, psCtlId){
			/** @type cpr.controls.ComboBox */
			var vcCtl = app.lookup(psCtlId);
			var indices = new Array();
			for(var i=0, len=vcCtl.getItemCount(); i<len; i++){
				indices.push(i);
			}
			vcCtl.selectItems(indices);
		};
		
		/**
		 * 콤보박스의 값을 Reset한다.
		 * @param {cpr.core.AppInstance} 	app 앱인스턴스
		 * @param {#uicontrol} psCtlId	컨트롤ID
		 */
		SelectKit.prototype.reset = function(app, psCtlId){
			/** @type cpr.controls.ComboBox */
			var vcCtl = app.lookup(psCtlId);
			if(vcCtl.dataSet){
				vcCtl.dataSet.clear();
			}
			vcCtl.value = "";
		};
		
		
		/**
		 * 필터링 할 컬럼명(psFilterColumnName)은 데이터셋의 컬럼명을 작성한다.
		 * 그리드에서 사용 금지.
		 * @desc 두 개의 List형 컨트롤이 종속 관계를 가질 때, 종속되는 컨트롤의 데이터를 필터링하기 위한 메소드
		 * @param {#uicontrol} psMainId				 메인 컨트롤 ID
		 * @param {#uicontrol} psSubId				 적용될 컨트롤 ID
		 * @param {String} psFilterColumnName	 적용될 컨트롤의 필터링 할 컬럼명
		 * @param {Number} pbFirstItemSelect	(Optional)  첫번째 아이템 선택 여부  default : true (선택)
		 * @return void
		 */
		SelectKit.prototype.cascadeList = function(app, psMainId, psSubId, psFilterColumnName, pbFirstItemSelect){
			var voMainCtl = app.lookup(psMainId);
			var voSubCtl = app.lookup(psSubId);
		
			if(voMainCtl == null || voSubCtl == null){
				return;
			}
			pbFirstItemSelect = pbFirstItemSelect == null ? true : pbFirstItemSelect;
		
			var vaItems = voMainCtl.getSelection();
			var vsValue = "";
			if(vaItems.length > 0){
				vsValue = vaItems[0].value;
			}
		
			voSubCtl.clearFilter();
		
			var voFirstItem = voSubCtl.getItem(0);
			var vsFirstItemValue = voFirstItem.value;
			var vsFirstItemLable = voFirstItem.label;
		
			//'전체' 아이템 여부
			var vbAllStatus = false;
			//var vsGlsAll = cpr.I18N.INSTANCE.message("UI-GLS-ALL");
			var vsGlsAll = "전체";
		
			if( vsGlsAll ==  vsFirstItemLable && ( ValueUtil.isNull(vsFirstItemValue) || vsFirstItemValue.indexOf("%") != -1)){
				vbAllStatus = true;
			}
		
			//전체아이템이 포함됐을 경우
			if(vbAllStatus)	{
				var vsFilter = psFilterColumnName + "== '" + vsValue + "' || ( label == '" +  vsGlsAll + "' && (value == '' || value == '%'))";
				voSubCtl.setFilter(vsFilter);
				if(pbFirstItemSelect)
					this.selectItem(app, psSubId, 0);
			}else{
				voSubCtl.setFilter(psFilterColumnName + "== '" + vsValue + "'");
				if(pbFirstItemSelect){
					var vaSubCtlItems = voSubCtl.getItems();
					if(vaSubCtlItems.length > 0){
						this.selectItem(app, psSubId, vaSubCtlItems[0].value);
					}else{
						this.selectItem(app, psSubId, 0);
					}
				}
		
			}
		
			voSubCtl.redraw();
		};
		/**
		 * 트리(Tree) 컨트롤 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function TreeKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 트리 컨트롤 초기화.
		 *  - 사이트별 Customizing 필요
		 * @param {any} app
		 * @param {#Tree} paTreeId
		 */
		TreeKit.prototype.init = function(app, paTreeId){
			if(!(paTreeId instanceof Array)){
				paTreeId = [paTreeId];
			}
			
			var _app = app;
			var _appKit = this._appKit;
			for (var i=0, len=paTreeId.length; i <len; i++) {
				/**
				 * @type cpr.controls.Tree
				 */
				var vcTree = (paTreeId[i] instanceof cpr.controls.Tree) ? paTreeId[i] : _app.lookup(paTreeId[i]);
				if(vcTree == null) continue;
				
				var vcDataSet =  vcTree.dataSet;
				vcDataSet._treeId = vcTree.id;
				var vsDataBindCtxId = vcTree.userAttr("bindDataFormId");
				
				if(vsDataBindCtxId != null && vsDataBindCtxId != ""){
					vcTree.addEventListener("selection-change", function(e){
						/**
						 * @type cpr.controls.Tree
						 */
						var tree = e.control;
						var voSelectedItem = e.newSelection[0];
						var itemIdx = tree.getIndex(voSelectedItem);
						var voContext = new cpr.bind.DataRowContext(vcDataSet, itemIdx);
						
						var freeformes = ValueUtil.split(vsDataBindCtxId, ",");
						freeformes.forEach(function(/* eachType */ formId){
							var vcGrp = _app.lookup(formId);
							vcGrp.setBindContext(voContext);
							
							vcGrp.redraw();
						});
					});
					
					//그룹 PK컬럼 enable 설정
					var vaPkColumnNames = ValueUtil.split(vcDataSet.info, ",");
					vaPkColumnNames.some(function(value, idx){
						if(value == "") return false;
						
						//프리폼 PK 컬럼 취득 
						if(!ValueUtil.isNull(vsDataBindCtxId)){
							var freeformes = ValueUtil.split(vsDataBindCtxId, ",");
							freeformes.forEach(function(/* eachType */ formId){
								/**@type cpr.controls.Container */
								var freeform = _app.lookup(formId);
								var vaChildCtrls = freeform.getChildren();
								vaChildCtrls.some(function(ctrl, idx){
									if(ctrl.type == "output") return false;
									if(ctrl.userAttr("ignorePk") == "Y") return false;
									
									var bind = ctrl.getBindInfo("value");
									if(bind && bind.type == "datacolumn" && value == bind.columnName){
										ctrl.bind("enabled").toExpression("getStateString() == 'I' ? true : false");
										ctrl.userAttr("required", "Y");
										ctrl.style.setClasses("require");
									}
								});
							});
						}
					});
					
					//마지막 작업행 findRow
					vcDataSet.addEventListener("update", function(/* cpr.events.CDataEvent */e){
						/** 
						 * @type cpr.data.DataSet
						 */
						var dataset = e.control;
						var rowIndex = e.row.getIndex();
						var vaPkColumns = ValueUtil.split(dataset.info, ",");
						if(vaPkColumns.length < 1){
							dataset._findTreeCondition = null;
						}else{
							var vaTempCond = [];
							vaPkColumns.forEach(function(column){
								vaTempCond.push(dataset.getValue(rowIndex, column));
							});
							
							if(vaTempCond.length > 0){
								dataset._findTreeCondition = vaTempCond.join("");
							}else{
								dataset._findTreeCondition = null;
							}
						}
					});
					
					//트리에 바인딩된 데이터셋(Dataset)이 로드될 때 처리
					//마지막행 찾기, 조회 건수 업데이트
					vcDataSet.addEventListener("load", function(/* cpr.events.CDataEvent */e){
						/** @type cpr.data.DataSet */
						var dataset = e.control;
						/** @type cpr.controls.Tree */
						var tree = _app.lookup(dataset._treeId);
						if(tree == null) return;
						
						//대상 그리드가 정렬된 상태라면... 정렬을 푼다.
						if(dataset.getSort() != ""){
							dataset.clearSort();
						}
						
						//마지막 작업행 찾기
						if(dataset.getRowCount() > 0) {
							if(dataset._findTreeCondition){
								var voRow = dataset.findFirstRow(tree.itemSetConfig.value + "=='" + dataset._findTreeCondition + "'");
								var vnIdx = voRow.getIndex();
								tree.selectItem(vnIdx);
								tree.focusItem(tree.getItem(vnIdx));
							}else{
								tree.selectItem(0, true);
							}
						}
						
						//마지막 작업행 정보 Clear
						dataset._findTreeCondition = null;
						
					});
				}
			}
		}
		
		/**
		 * 현재 선택된 아이템의 value를 반환한다.
		 * @param {cpr.core.AppInstance} 		app 앱인스턴스
		 * @param {#Tree} psTreeId	 트리 Id
		 * @param {String} psDiv (Optional) 얻어올 값 영역(label 또는 value)
		 * @return {String | Array}  multiple 속성이 true 일 경우 Array(String)
		 *                                      false 일 경우 String  
		 */
		TreeKit.prototype.getSelectedValue = function(app, psTreeId, psDiv){
			/** @type cpr.controls.Tree */
			var vcTree = app.lookup(psTreeId);
			var vaItem = vcTree.getSelection();
			//아이템이 없으면... 공백 반환
			if(vaItem.length < 1) return "";
			
			psDiv = (psDiv != null ? psDiv.toUpperCase() : "VALUE");
			if(vcTree.multiple){
				var vaValues = new Array();
				vaItem.forEach(function(vcItem){
					if(psDiv == "LABEL")
						vaValues.push(vcItem.label);
					else
						vaValues.push(vcItem.value);
				});
				return vaValues;
			}else{
				return psDiv == "LABEL" ? vaItem[0].label : vaItem[0].value;
			}
		};
		
		
		/**
		 * @desc 입력한 value에 해당하는 아이템의 label 또는 parentValue를 반환한다.
		 * @param {cpr.core.AppInstance} app
		 * @param {#Tree} psTreeId	트리 id
		 * @param {String} psValue	search value
		 * @param {String} psDiv	가지고 오는 구분자 값(LABEL(디폴트), PVALUE);
		 * @return {String}
		 */
		TreeKit.prototype.getItem = function(app, psTreeId, psValue, psDiv){
			var vcTree = app.lookup(psTreeId);
			if(!!psDiv) psDiv = psDiv.toUpperCase();
			psDiv = !!psDiv ? psDiv : "LABEL";
		
			try {
				var vaItem = vcTree.getSelection();
				if(!psValue && vcItem > 0) psValue = vaItem[0].value;
			} catch(e){
				return null;
			}
		
			var voItem = vcTree.getItemByValue(psValue);
		
			if(!voItem) return null;
		
			if(psDiv == "LABEL"){
				return voItem.label;
			} else {
				return voItem.parentValue;
			}
		};
		
		/**
		 * 해당 아이템의 상위 아이템을 펼친다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Tree} psTreeId		 트리 Id
		 * @param {Object} poItem		 item
		 * @param {Boolean} pbHierarchy (Optional) 계층적으로 모든 상위까지 펼칠지 여부(false인 경우, 바로 상위의 부모 아이템만 펼친다.)
		 * @return void
		 */
		TreeKit.prototype.expandParentItem = function(app, psTreeId, poItem, pbHierarchy){
			/** @type cpr.controls.Tree */
			var vcTree = app.lookup(psTreeId);
			var vaParentItem = new Array();
			
			pbHierarchy == !!pbHierarchy ? pbHierarchy : true;
			
			function checkExpandItem(poPItem){
				var item = vcTree.getItemByValue(poPItem.parentValue);
				if(item != null && item.value != "" && !vcTree.isExpanded(item)){
					vaParentItem.push(item);
					checkExpandItem(item);
				}
			}
			if(pbHierarchy){
				checkExpandItem(poItem);
			}else{
				vaParentItem.push(poItem);
			}
			
			for(var i=0, len=vaParentItem.length; i<len; i++){
				vcTree.expandItem(vaParentItem[i]);
			}
		};
		
		/**
		 * 트리 선택 아이템 변경 이벤트 발생시, 변경 이전에 선택된 아이템을 선택해준다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {cpr.events.CSelectionEvent} event 트리 선택 아이템 변경 이벤트
		 * @param {Boolean} emitEvent (Optional) 이벤트(before-selection-change, selection-change)를 발생시킬지 여부
		 * @return void
		 */
		TreeKit.prototype.selectBeforeRow = function(app, event, emitEvent) {
			/** @type cpr.controls.Tree */
			var vcTree = event.control;
			var emit = emitEvent === true ? true : false;
			
			var voOldSelection = event.oldSelection[0];
			var vsOldVal = voOldSelection.value;
			vcTree.selectItemByValue(vsOldVal, emit);
			vcTree.focusItem(voOldSelection);
		};
		
		/**
		 * @desc 입력한 label 또는 value에 해당하는 트리 아이템을 선택한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Tree} psTreeId	 트리 id
		 * @param {String} psValue	 search value
		 * @param {String} psDiv	 가지고 오는 구분자 값(VALUE(디폴트), LABEL)
		 * @return void
		 */
		TreeKit.prototype.selectItem = function(app, psTreeId, psValue, psDiv){
			var vcTree = app.lookup(psTreeId);
		
			if(!!psDiv) psDiv = psDiv.toUpperCase();
			psDiv = !!psDiv ? psDiv : "VALUE";
		
			if(psDiv == "VALUE"){
				vcTree.selectItemByValue(psValue);
			} else {
				vcTree.selectItemByLabel(psValue);
			}
		};
		
		/**
		 * @desc 아이템에 해당하는 모든 child item을 펼치거나 닫습니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Tree} psTreeId		트리 Id
		 * @param {Boolean} pbExpand	펴기 : true, 닫기 : false
		 * @param {Object} poItem		item 생략가능 default 최상위 item
		 * @return void
		 */
		TreeKit.prototype.expandAllItems = function(app, psTreeId, pbExpand, poItem){
			var vcTree = app.lookup(psTreeId);
		
			if(!!poItem){
				if(pbExpand){
					vcTree.expandItem(poItem);
					vcTree.expandAllItems(poItem);
				} else {
					vcTree.collapseItem(poItem);
					vcTree.collapseAllItems(poItem);
				}
			} else {
				pbExpand ? vcTree.expandAllItems() : vcTree.collapseAllItems();
			}
		
		};
		
		/**
		 * @desc 현재 드래그 중인 선택 항목을 표시하는 컨트롤을 띄운다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {cpr.events.CMouseEvent} event 마우스 이벤트
		 * @param {String} psText	 라벨에 표시할 텍스트
		 * @param {String} psWidth	(optional) 라벨 width
		 * @param {String} psHeight	(optional) 라벨 height
		 * @return void
		 */
		TreeKit.prototype.draggingLabel = function(app, event, psText, psWidth, psHeight){
		
			var dragMessage = new cpr.controls.Output("rowmessage");
			dragMessage.style.css({
				"position": "absolute",
				"box-shadow": "0px 2px 2px 0px rgba(0, 0, 0, .3)",
				width: psWidth?psWidth:"268px",
				height: psHeight?psHeight:"50px",
				border: "solid 1px",
				backgroundColor: "#FFF"
			});
		
			dragMessage.value = /*임시로 적어둠*/"현재 드래그하고 있는 대상 : " + psText;
		
			var dataDragManager = cpr.core.Module.require("module/dataDragManager");
		
			dataDragManager.dragStart(dragMessage, app, event);
		};
		
		/**
		 * 탭(TabFolder) 컨트롤 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function TabKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 현재 선택된 탭아이템 id를 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#TabFolder} psTabId 탭 Id
		 * @return {Number} 탭아이템 id (탭아이템id는 인덱스와 유사 탭아이템 순서대로 id 부여됨)
		 */
		TabKit.prototype.getSelectedId = function(app, psTabId){
			/** @type cpr.controls.TabFolder */
			var vcTab = app.lookup(psTabId);
			var vcTabItem = vcTab.getSelectedTabItem();
			
			return vcTabItem ? vcTabItem.id : "";
		};
		
		/**
		 * 입력한 id에 해당하는 탭 아이템을 선택한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#TabFolder} psTabId 탭Id
		 * @param {Number} pnIndex 탭아이템 id
		 * @param {Boolean} emitEvent (Optional) 이벤트(before-selection-change, selection-change)를 발생시킬지 여부
		 */
		TabKit.prototype.setSelectedTabItemById = function(app, psTabId, pnIndex, emitEvent){
			/** @type cpr.controls.TabFolder */
			var vcTab = app.lookup(psTabId);
			
			var vaTabItem = vcTab.getTabItems();
			var vcTabItem = vaTabItem.filter(function(item){
				return item.id == pnIndex;
			});
			
			var emit = emitEvent != undefined ? emitEvent : true;
			vcTab.setSelectedTabItem(vcTabItem[0], emit);
		};
		
		/**
		 * 탭 페이지를 숨기거나/보여준다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#TabFolder} psTabId 탭Id
		 * @param {Number} pnIndex 탭아이템 id
		 * @param {Boolean} pbVisible - 숨김여주(true/false)
		 */
		TabKit.prototype.setVisibleTabItem = function(app, psTabId, pnIndex, pbVisible){
			/** @type cpr.controls.TabFolder */
			var vcTab = app.lookup(psTabId);
			
			var vaTabItem = vcTab.getTabItems();
			var vcTabItem = vaTabItem.filter(function(item){
				return item.id == pnIndex;
			});
			
			if(vcTabItem){
				vcTabItem[0].visible = pbVisible;
			}
		};
		
		/**
		 * 탭 페이지 버튼을 활성화시키거나 비활성화 시킨다
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#TabFolder} psTabId 탭Id
		 * @param {String || Array} paIndex - 활성화/비활성화 할 탭 Index 또는 Index 배열 (탭 index 시작 = 1) 
		 * @param {Boolean} psEnable - 활성화여부(true/false)
		 */
		TabKit.prototype.setEnableTabItem = function(app, psTabId, paIndex, psEnable){
			/* 2019-05-13 ssb 작성 */
			/** @type cpr.controls.TabFolder */
			var vcTab = app.lookup(psTabId);
			
			if(!(paIndex instanceof Array)){
				paIndex = [paIndex];
			}
			var vaTabItem = vcTab.getTabItems();
			
			for (var i=0, len=paIndex.length; i<len; i++) {
				var vnTabIdx  = paIndex[i] - 1;
				vaTabItem[vnTabIdx].enabled = psEnable;
			}
		};
		
		
		
		/**
		 * Embeded앱 컨트롤 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function EmbeddedAppKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * Embeded 앱내의 함수를 호출한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#EmbeddedApp} psEmbeddedappId 임베디드 앱 ID
		 * @param {String} psFuncName 호출 함수명
		 * @param {String | Array} paArgs 함수에 전달할 아규먼트 
		 * @return {any} method 내 파라미터.
		 */
		EmbeddedAppKit.prototype.callAppMethod = function(app, psEmbeddedappId, psFuncName, paArgs){
			/** @type cpr.controls.EmbeddedApp */
			var vcEmbed = app.lookup(psEmbeddedappId);
			var vsValue = null;
			if(vcEmbed){
				vcEmbed.ready(function(e){
					vsValue = e.callAppMethod(psFuncName, paArgs);
				});
			}
			return vsValue;
		};
		
		
		/**
		 * 메인 MDI 컨트롤 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function MDIKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * close 메인 MDI의 탭으로 화면을 오픈한다.
		 * - Root App에 해당 함수 필요
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#MDIFolder} psMenuId 메뉴ID
		 */
		MDIKit.prototype.open = function(app, psMenuId, poParam){
			app.getRootAppInstance().callAppMethod("doOpenMenuToMdi", psMenuId, poParam);
		};
		
		/**
		 * close 메인 MDI의 화면을 닫는다.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 */
		MDIKit.prototype.close = function(app){
			var vsMenuId = this._appKit.Auth.getMenuInfo(app, "MENU_ID");
			app.getRootAppInstance().callAppMethod("doCloseMdiTab", vsMenuId);
		};
		
		/**
		 * 일반 컨트롤 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function ControlKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 지정한 컨트롤의 Visible 속성을 설정한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {Boolean} pbVisible 컨트롤 숨김 여부(true/false)
		 * @param {#uicontrol | Array} paCtlId 컨트롤 아이디 또는 아이디 배열
		 * @return void
		 */
		ControlKit.prototype.setVisible = function(app, pbVisible, paCtlId) {
			if(!(paCtlId instanceof Array)){
				paCtlId = [paCtlId];
			}
			if (typeof (pbVisible) != "boolean") {
				pbVisible = ValueUtil.fixBoolean(pbVisible);
			}
			for (var i=0, len=paCtlId.length; i<len; i++) {
				app.lookup(paCtlId[i]).visible = pbVisible;
			}
		};
		
		/**
		 * 지정한 컨트롤의 Enable 속성을 설정한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {Boolean} pbEnable 컨트롤 활성화 여부(true/false)
		 * @param {#uicontrol | Array} paCtlId 컨트롤 아이디 또는 아이디 배열
		 * @return void
		 */
		ControlKit.prototype.setEnable = function(app, pbEnable, paCtlId) {
			if(!(paCtlId instanceof Array)){
				paCtlId = [paCtlId];
			}
			if (typeof (pbEnable) != "boolean") {
				pbEnable = ValueUtil.fixBoolean(pbEnable);
			}
			var ctrl;
			for (var i=0, len=paCtlId.length; i<len; i++) {	
				ctrl = app.lookup(paCtlId[i]);
				if(ctrl) ctrl.enabled = pbEnable;
			}
		};
		
		/**
		 * 지정한 컨트롤의 ReadOnly 속성을 설정한다.
		 * 만약, 해당 컨트롤에 readonly이 없을경우 enable 속성으로 제어된다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {Boolean} 		pbReadOnly  컨트롤 readOnly 여부(true/false)
		 * @param {#uicontrol | Array} paCtlId 컨트롤 아이디 또는 아이디 배열
		 * @return void
		 */
		ControlKit.prototype.setReadOnly = function(app, pbReadOnly, paCtlId) {
			if(!(paCtlId instanceof Array)){
				paCtlId = [paCtlId];
			}
				
			for (var i=0, len=paCtlId.length; i<len; i++) {
				var voCtl = app.lookup(paCtlId[i]);
			  	if(voCtl == null || "undefined" == voCtl) continue;
				
				var vsCtlType = voCtl.type;
				if(voCtl.readOnly !== undefined){
					voCtl.readOnly = pbReadOnly;
				}else{
					this.setEnable(app, !pbReadOnly, paCtlId[i]);
				}
			}
		};
		
		/**
		 * 컨트롤의 지정된 사용자 정의 속성(userattr) 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 	  컨트롤 아이디
		 * @param {String} psAttrName  속성
		 * @return {String} 속성값
		 */
		ControlKit.prototype.getUserAttr = function(app, psCtlId, psAttrName){
		   return app.lookup(psCtlId).userAttr(psAttrName);
		};
		
		/**
		 * 컨트롤의 지정된 사용자 정의 속성(userattr)의 값을 설정한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 	   컨트롤 아이디
		 * @param {String} psAttrName  속성
		 * @param {String} psAttrValue 속성값
		 * @return void
		 */
		ControlKit.prototype.setUserAttr = function(app, psCtlId, psAttrName, psAttrValue){
			var ctrl = app.lookup(psCtlId);
			var userAttr = ctrl.userAttr();
			userAttr[psAttrName] = psAttrValue;
		};
		
		/**
		 * 컨트롤를 포커스(focus) 한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 	   컨트롤 아이디
		 */
		ControlKit.prototype.setFocus = function(app, psCtlId){
			var ctrl = app.lookup(psCtlId);
			if(ctrl instanceof cpr.controls.UDCBase){
				var focused = false;
				var embApp = ctrl.getEmbeddedAppInstance();
				embApp.getContainer().getChildren().some(function(embCtrl){
					if(embCtrl.getBindInfo("value") && embCtrl.getBindInfo("value").property == "value"){
						embCtrl.focus();
						focused = true;
						return true;
					}
				});
				if(focused !== true){
					app.focus(ctrl);
				}
			}else{
				app.focus(ctrl);
			}
		}
		
		/**
		 * 컨트롤의 값을 초기화한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol | Array} paCtlId  일반 컨트롤 및 그리드 컨트롤 아이디		
		 * @return void
		 */
		ControlKit.prototype.reset = function(app, paCtlId) {
			if(!(paCtlId instanceof Array)){
				paCtlId = [paCtlId];
			}
			var vcCtrl;
			for (var i=0, len=paCtlId.length; i<len; i++) {
				vcCtrl = app.lookup(paCtlId[i]);
				if(vcCtrl == null) continue;
				if(vcCtrl.type == "grid"){
					vcCtrl.dataSet.clear();
					//그리드 타이틀 영역의 데이터 건수 업데이트
					var titles = this._appKit.Group.getAllChildrenByType(app, "udc.com.comTitle");
					for(var j=0, jlen=titles.length; j<jlen; j++){
						if(titles[j] == null || titles[j].getAppProperty("ctrl") == null) continue;
						if(titles[j].getAppProperty("ctrl").id == vcCtrl.id){
							titles[j].setAppProperty("rowCount", vcCtrl.dataSet.getRowCount());
						}
					}
				}else if(vcCtrl.type == "container"){
					var voDs = this._appKit.Group.getBindDataSet(app, vcCtrl);
					if(voDs) voDs.clear();
					vcCtrl.redraw();
				}else{
					vcCtrl.value = "";
				}
			}
		};
		
		/**
		 * 특정 컨트롤의 자료를 갱신하고 다시 그린다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol | Array} paCtlId 일반 컨트롤 및 그리드 컨트롤 아이디
		 * @return void
		 */
		ControlKit.prototype.redraw = function(app, paCtlId) {
			if(!(paCtlId instanceof Array)){
				paCtlId = [paCtlId];
			}
			for (var i=0, len=paCtlId.length; i<len; i++) {
				var vcCtrl = app.lookup(paCtlId[i]);
				if(vcCtrl) vcCtrl.redraw();
			}
		};
		
		/**
		 * 컨트롤의 지정된 style 속성 값을 가져옵니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 컨트롤 아이디
		 * @param {String} psAttrName style 속성명
		 * @return {String} style 속성값
		 */
		ControlKit.prototype.getStyleAttr = function(app, psCtlId, psAttrName){
			/**@type cpr.controls.UIControl*/
			var vcCtrl = app.lookup(psCtlId);
			return vcCtrl.style.css(psAttrName);
		};
		
		/**
		 * 컨트롤의 지정된 style 속성값을 설정한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 컨트롤 아이디
		 * @param {String} psAttrName 속성
		 * @param {String} psAttrValue 속성값
		 * @return void
		 */
		ControlKit.prototype.setStyleAttr = function(app, psCtlId, psAttrName, psAttrValue){
			/**@type cpr.controls.UIControl*/
			var vcCtrl = app.lookup(psCtlId);
			return vcCtrl.style.css(psAttrName, psAttrValue);
		};
		
		/**
		 * 컨트롤이 실제 그려진 사이즈를 리턴합니다.
		 * 컨트롤이 화면에 그려지지 않은 상태인 경우는 모든 값이 0인 객체가 리턴됩니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId  컨트롤 아이디
		 * @param {String} psPosition 구하고자하는 위치 및 크기 정보(width, height, left, top, bottom, right)
		 * @return {Interface{width: Number, height: Number, left: Number, top: Number, bottom: Number, right: Number}} HTML DOM에서의 컨트롤의 위치 및 크기 정보
		 */
		ControlKit.prototype.getActualRectPosition = function(app, psCtlId, psPosition){
			/** @type cpr.controls.UIControl */
			var vcCtrl = app.lookup(psCtlId);
			var voActRec = vcCtrl.getActualRect();
			return voActRec[psType];
		};
		
		/**
		 * 해당 컨트롤의 제약 조건을 반환합니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 반환하고자 하는 컨트롤.
		 * @param {String} psParentGrp (Optional) 상위 컨트롤
		 *                                        그룹내 컨트롤의 제약 조건을 구할시 사용
		 * @return {cpr.controls.layouts.Constraint} 해당하는 제약조건.
		 */
		ControlKit.prototype.getConsraint = function(app, psCtlId, psParentGrp){
			var vcCtrl = app.lookup(psCtlId);
			var voContainer;
			if(!ValueUtil.isNull(psParentGrp)){
				voContainer = app.lookup(psParentGrp);
			}else{
				voContainer = app.getContainer();		
			}
			var vcChild = app.lookup(psCtlId);
			
			return voContainer.getConstraint(vcChild);
		};
		
		/**
		 * 컨트롤의 지정된 제약 조건(constraint)을 변경합니다.
		 * 타겟 컨트롤에서 부모 컨트롤과의 연계된 위치를 변경합니다.
		 * parameter의 constraints가 포함한 항목만 변경합니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 컨트롤의 아이디
		 * @param {#Container} psParentGrpId 상위 컨트롤의 아이디. app의 container일 경우 null
		 * @param {Object} poConstraint 제약조건
		 * 					상위 컨트롤의 레이아웃이 formlayout일 경우 rowIndex, colIndex 를 반드시 포함한 조건을 설정하여야합니다.
		 * @return {boolean} 성공여부
		 */
		ControlKit.prototype.updateConstraint = function(app, psCtlId, psParentGrpId, poConstraint){
		 	/** @type cpr.controls.UIControl */
		 	var vcChild = app.lookup(psCtlId);
		 	if(vcChild == null) return false;
		 	/** @type cpr.controls.Container */
		 	var voContainer = null;
		 	if(!ValueUtil.isNull(psParentGrpId)){
		 		voContainer = app.lookup(psParentGrpId);
		 	}else {
		 		voContainer = app.getContainer();
		 	}
		 	
		 	var voLayout = voContainer.getLayout();
		 	var voConstraint = null;
		 	if(voLayout instanceof cpr.controls.layouts.ResponsiveXYLayout){
		 		var voSrcConstraint = voContainer.getConstraint(vcChild)["positions"][0];
		 		voConstraint = {
		 			positions:[Object.assign(voSrcConstraint, poConstraint)]
		 		}
		 	}else {
		 		voConstraint = poConstraint;
		 	}
		 	
		 	return voContainer.updateConstraint(vcChild, voConstraint);
		};
		
		/**
		 * 해당 컨트롤의 이벤트를 발생시킨다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 컨트롤의 아이디
		 * @param {String} psEventType 이벤트명(ex-click)
		 */
		ControlKit.prototype.dispatchEvent = function(app, psCtlId, psEventType){
			var vcCtrl = app.lookup(psCtlId);
			if(vcCtrl){
				vcCtrl.dispatchEvent(new cpr.events.CEvent(psEventType));
			}
		};
		
		/**
		 * @desc 지정한 컨트롤의 value를 지정한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtrlId 컨트롤 아이디
		 * @param {String} psValue value
		 * @return void
		 */
		ControlKit.prototype.setValue = function(app, psCtlId, psValue){
		   app.lookup(psCtlId).value = psValue;
		};
		
		/**
		 * @desc 지정한 컨트롤의 value를 취득한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 컨트롤 아이디
		 * @return void
		 */
		ControlKit.prototype.getValue = function(app, psCtlId){
		   return app.lookup(psCtlId).value;
		};
		
		/**
		 * @desc 지정한 컨트롤의 value를 취득한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 컨트롤 아이디
		 * @param {String} psProperty 컨트롤 속성명
		 * @return void
		 */
		ControlKit.prototype.getProperty = function(app, psCtlId, psProperty){
		   return app.lookup(psCtlId)[psProperty];
		};
		
		/**
		 * 데이터셋 컨트롤 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function DataSetKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 데이터셋 또는 데이터맵에 컬럼(Column)을 추가합니다.
		 * Header정보 추가되며, data가 있는 경우 row data에도 해당 column data가 추가됩니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {String} psDataSetId 데이터셋
		 * @param {String} psColumnNm 추가하려는 컬럼명
		 * @param {Object} psValue (Optional) 초기값 설정
		 * @param {String} psColumnType (Optional) 컬럼유형(string/number/decimal/expression)
		 * @return {Boolean} 컬럼 추가 성공 여부
		 */
		DataSetKit.prototype.addColumn = function(app, psDataSetId, psColumnNm, psValue, psColumnType){
			/** @type cpr.data.DataSet */
			var dataset = app.lookup(psDataSetId);
			
			var columnType = !ValueUtil.isNull(psColumnType) ? psColumnType.toLowerCase() : "string";
			return dataset.addColumn(new cpr.data.header.DataHeader(psColumnNm, columnType), psValue);
		};
		
		/**
		 * 데이터셋 특정 값을 가져오는 함수 입니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#DataSet} psDataSetId 데이터셋
		 * @param {String} psCondition 특정 값을 가져올 조건
		 * @param {String} psColumnName 가져오려는 값의 컬럼명
		 * 
		 * ex) util.DataSet.getValue(app, "dsLttmRcd", "CD == '" + vsNewVal + "'", "CD_USG_01");
		 */
		DataSetKit.prototype.getValue = function(app, psDataSetId, psCondition, psColumnName){
			/** @type cpr.data.DataSet */
			var dataset = app.lookup(psDataSetId);
			
			var voRow = dataset.findFirstRow(psCondition);
			return voRow != null ? voRow.getValue(psColumnName) : "";
		};
		
		
		/**
		 * 입력 받은 rowIndex와 columnName에 해당되는 데이터를 수정합니다.<br>
		 * <br>
		 * 1. 상태변경<br>
		 * 해당 columnName에 해당되는 Column이 DisplayColumn이 아니고 Row상태가 UNCHANGED 상태인 경우
		 * Row 상태가 UPDATED로 바뀝니다.(UNCHANGED -> UPDATED)<br>
		 * DELEDED상태이거나 INSERTED상태인 row는 수정할 수 없습니다.<br>
		 * 2. 이벤트<br>
		 * 수정이 된 경우 <b>UPDATED 이벤트가 발생합니다.</b><br>
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#DataSet} psDataSetId Id
		 * @param {Number} pnRowIndex 수정할 row의 row index.
		 * @param {String} psColumnName 수정할 column의 columnName.
		 * @param {Object} psValue 수정할 value 값.
		 * @return {Boolean} 값 수정 성공 여부.
		 */
		DataSetKit.prototype.setValue = function(app, psDataSetId, pnRowIndex, psColumnName, psValue){
			/** @type cpr.data.DataSet */
			var vcDataSet =  app.lookup(psDataSetId);
			return vcDataSet.setValue(pnRowIndex, psColumnName, psValue);
		};
		
		/**
		 * 모든 데이터셋 정보를 제거합니다.<br>
		 * data, sort, filter가 제거됩니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#DataSet} psDataSetId DataSet Id
		 */
		DataSetKit.prototype.clear = function(app, psDataSetId) {
			/** @type cpr.data.DataSet */
			var vcDataSet = app.lookup(psDataSetId);
			vcDataSet.clear();
		}
		
		/**
		 * 지정한 범위 내의 row들 중 조건에 맞는 모든 Row 객체의 배열을 반환
		 * 또는 지정한 범위 내의 row들 중 조건에 맞는 첫번째 Row 객체를 반환
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#DataSet} psDataSetId 데이터셋 ID
		 * @param {String} psCondition 조건식
		 *                 ex)"STUD_DIV_RCD == 'CT101REGU' && SA_NM == '컴퓨터정보과'"
		 * 					사용가능수식 !=", "!==", "$=", "%", "&&", "(", "*", "*=", "+", ",", "-", ".", "/", "/*", "//", "<", "<=", "==", "===", ">", ">=", "?", "[", "^=", "||"
		 * @param {Number} pbAllStatus (optional)
		 *                             true : 조건에 맞는 모든 row 리턴
		 *                             default : 조건에 맞는 첫번째 row 리턴
		 * @param {Number} pnStartIdx (optional) Number  범위지정 시작 row index.
		 * @param {Number} pnEndIdx (optional) Number  범위지정 끝 row index.
		 * @retrun 데이터 로우
		 */
		DataSetKit.prototype.findRow = function(app, psDataSetId, psCondition, pbAllStatus, pnStartIdx, pnEndIdx) {
			/** @type cpr.data.DataSet */
			var vcDataSet = app.lookup(psDataSetId);
		
			if(pbAllStatus){
				return vcDataSet.findAllRow(psCondition, pnStartIdx, pnEndIdx);
			}else{
				return vcDataSet.findFirstRow(psCondition, pnStartIdx, pnEndIdx);
			}
		};
		
		/**
		 * 지정한 범위 내의 row들 중 조건에 맞는 첫번째 Row 객체에 해당하는 컬럼의 value를 취득
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#DataSet} psDataSetId 데이터셋 ID
		 * @param {String} psCondition 조건식
		 *                 ex)"STUD_DIV_RCD == 'CT101REGU' && SA_NM == '컴퓨터정보과'"
		 * 					사용가능수식 !=", "!==", "$=", "%", "&&", "(", "*", "*=", "+", ",", "-", ".", "/", "/*", "//", "<", "<=", "==", "===", ">", ">=", "?", "[", "^=", "||"
		 * @param {String} psColumnName 컬럼명
		 * @param {Number} pnStartIdx (optional)  범위지정 시작 row index.
		 * @param {Number} pnEndIdx (optional)   범위지정 끝 row index.
		 * @retrun 데이터 로우
		 */
		DataSetKit.prototype.getFindRowValue = function(app, psDataSetId, psCondition, psColumnName, pnStartIdx, pnEndIdx) {
			var voRow = this.findRow(app, psDataSetId, psCondition, false, pnStartIdx, pnEndIdx);
			if(voRow != null){
				return voRow.getValue(psColumnName);
			}else{
				return null;
			}
		};
		
		/**
		 * 현재 Row 수를 반환
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#DataSet} psDataSetId 데이터셋 ID
		 * @retrun {Number} 로우 갯수
		 */
		DataSetKit.prototype.getRowCount = function(app, psDataSetId) {
			/** @type cpr.data.DataSet */
			var vcDataSet = app.lookup(psDataSetId);
			return vcDataSet.getRowCount();
		};
		
		/**
		 * 현재 데이터셋의 데이터를 타겟 데이터셋으로 복사합니다.<br>
		 * 타겟 데이터셋의 존재하는 컬럼의 데이터만 복사됩니다.<br>
		 * 복사시 추가되는 데이터는 INSERT 상태입니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스 
		 * @param {#DataSet} psSourceDataSetId DataSet Id
		 * @param {#DataSet} psTargetDataSetId 복사 데이터가 들어갈 타겟 DataSet Id.
		 * @param {String} psFilterCondition (Optional) 복사시 필터링할 조건. (생략시 전체 복사, target의 기존 데이터는 삭제됨)
		 * 				   "STUD_DIV_RCD == 'CT101REGU' && SA_NM == '컴퓨터정보과'" (동일한 로우가 있을경우 복사안함)
		 * @return {Boolean}
		 */
		DataSetKit.prototype.copyToDataSet = function(app, psSourceDataSetId, psTargetDataSetId, psFilterCondition){
			var vcSourceDataSet = app.lookup(psSourceDataSetId);
			var vcTargetDataSet = app.lookup(psTargetDataSetId);
			if(!psFilterCondition) vcTargetDataSet.clear();
			else{
				var vaFindRow = vcTargetDataSet.findAllRow(psFilterCondition);
				if(vaFindRow != null && vaFindRow.length > 0){
					return;
				}
			}
			return vcSourceDataSet.copyToDataSet(vcTargetDataSet, psFilterCondition);
		};
		
		/**
		 * rowData를 입력받아 원하는 특정 row index의 앞이나 뒤에 신규 row를 추가합니다.<br>
		 * <b>INSERTED 이벤트가 발생합니다.</b>
		 * @param {Number} index 삽입하고자 하는 row index.
		 * @param {Boolean} after? 해당 row index의 뒤에 삽입할지 여부. (true:뒤 / false:앞)
		 * @param {cpr.data.RowConfigInfo} rowData? 추가할 row data. (key: header명, value: value 를 갖는 json data)<br>
		{[columnName: string]: string | number | boolean}
		 * @return {cpr.data.Row} 추가한 신규 Row 객체.
		 */
		/**
		 * 
		 * @param {cpr.core.AppInstance} app 앱인스턴스 
		 * @param {#DataSet} psDataSetId DataSet Id
		 * @param {Number} pnIndex index 삽입하고자 하는 row index
		 * @param {Boolean} pbAfter 해당 row index의 뒤에 삽입할지 여부. (true:뒤 / false:앞)
		 * @param {cpr.data.RowConfigInfo} poRowData 추가할 row data. (key: header명, value: value 를 갖는 json data)<br>
		{[columnName: string]: string | number | boolean}
		 */
		DataSetKit.prototype.insertRow = function(app, psDataSetId, pnIndex, pbAfter, poRowData){
			/** @type cpr.data.DataSet */
			var vcDataSet = app.lookup(psDataSetId);
			if(poRowData == null){
				return vcDataSet.insertRow(pnIndex, pbAfter);
			}else{
				return vcDataSet.insertRowData(pnIndex, pbAfter, poRowData);
			}
		
		};
		
		/**
		 * 데이터맵(DataMap) 데이터 컴포넌트 유틸
		 * @param {common.AppKit} appKit
		 */
		function DataMapKit(appKit){
			this._appKit = appKit;
		}
		
		/**
		 * 입력 받은 columnName에 해당되는 데이터를 반환
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#DataMap} psDataMapId 데이터맵 Id
		 * @param {String} psColumnName 값을 가져오고자 하는 컬럼명
		 * @return {Object} 해당 데이터
		 * 					header dataType에 따라 반환타입이 정해짐.
							해당 columnName의 column이 존재 할 경우 해당 값 반환
							해당 columnName의 값이 없을 경우 ""(공백) 반환
							해당 columnName이 존재하지 않을 경우 null 반환
		 */
		DataMapKit.prototype.getValue = function(app, psDataMapId, psColumnName){
			/** @type cpr.data.DataMap */
			var vcDataMap = app.lookup(psDataMapId);
			return vcDataMap.getValue(psColumnName);
		};
		
		/**
		 * 입력 받은 columnName에 해당되는 데이터를 수정
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#DataMap} psDataMapId 데이터맵 Id
		 * @param {String} psColumnName 값을 가져오고자 하는 컬럼명
		 * @param {String} value 수정할 value 값
		 * @return {Boolean} 값 수정 성공 여부
		 */
		DataMapKit.prototype.setValue = function(app, psDataMapId, psColumnName, psValue){
			/** @type cpr.data.DataMap */
			var vcDataMap = app.lookup(psDataMapId);
			return vcDataMap.setValue(psColumnName, psValue);
		};
		
		/**
		 * 데이터를 모두 제거합니다.
		 * (data가 모두 공백으로 설정됩니다.)
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param  {#DataMap} psDataMapId 데이터맵 Id
		 */
		DataMapKit.prototype.clear = function(app, psDataMapId){
			/** @type cpr.data.DataMap */
			var vcDataMap = app.lookup(psDataMapId);
			vcDataMap.clear();
		};
		
		/**
		 * 데이터를 모두 초기화합니다.
		 * (data 모두 초기 설정값으로 설정됩니다.)
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param  {#DataMap} psDataMapId 데이터맵 Id
		 */
		DataMapKit.prototype.reset = function(app, psDataMapId){
			/** @type cpr.data.DataMap */
			var vcDataMap = app.lookup(psDataMapId);
			vcDataMap.reset();
		};
		
		/**
		 * 현재 데이터맵의 데이터를 타겟 데이터맵으로 복사합니다. <br>
		 * 복사시 타겟 데이터맵의 alterColumnLayout 속성에 따라 복사방법의 설정됩니다. <br>
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#DataMap} psSourceDataMapId 데이터맵 Id
		 * @param {#DataMap} psTargetDataMapId 복사 데이터가 들어갈 타겟 맵 ID.
		 * @return {Boolean}
		 */
		DataMapKit.prototype.copyToDataMap = function(app, psSourceDataMapId, psTargetDataMapId){
			var vcDataMap = app.lookup(psSourceDataMapId);
			var vcTargetDataMap = app.lookup(psTargetDataMapId);
			return vcDataMap.copyToDataMap(vcTargetDataMap);
		};
		
		/**
		 * Column을 추가합니다.
		 * Header정보에 추가되며, data가 있는 경우 row data에도 해당 column data가 추가됩니다.
		 * @param {#DataMap} psDataMapId 데이터맵 ID
		 * @param {String} psColumnNm 추가하려는 Header 명
		 * @param {String} psValue (Optional) 초기값 설정
		 * @return {Boolean} 컬럼 추가 성공 여부
		 */
		DataMapKit.prototype.addColumn = function(app, psDataMapId, psColumnNm, psValue){
			var vcDataMap = app.lookup(psDataMapId);
			return vcDataMap.addColumn(new cpr.data.header.DataHeader(psColumnNm, "string"), psValue);
		};
		
		/**
		 * Column을 삭제합니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#DataMap} psDataMapId 데이터맵 ID
		 * @param {String} psColumnName 삭제할 컬럼 명
		 * @return {Boolean} 컬럼 삭제 성공 여부
		 */
		DataMapKit.prototype.deleteColumn = function(app, psDataMapId, psColumnName){
			var vcDataMap = app.lookup(psDataMapId);
			return vcDataMap.deleteColumn(psColumnName);
		};
		
		/**
		 * 그리드(Grid) 컨트롤 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function GridKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 그리드를 초기화한다.<br/>
		 * 1. 상태 컬럽 바인드 지정  (N, U, D)<br/>
		 * 2. 인덱스컬럼 text및 css지정<br/>
		 * 3. 소트 컬럼 자동지정<br/>
		 * 4. 읽기 전용 컬럼 헤더 Text 변경<br/>
		 * 5. 그리드, 프리폼 PK컬럼 enable 설정<br/>
		 * 6. update이벤트 추가 ( 저장후 그리드의 마지막 작업행을 찾기 위함)<br/>
		 * 7. 그리드 매핑 데이터셋에 load 이벤트 추가 (그리드의 마지막행 찾기, 조회 건수 업데이트)<br/>
		 * 8. 그리드 selection-dispose 이벤트 추가(삭제로 인한, 선택행이 없는 경우... 이전 행 자동 선택하도록(행 추가 -> 삭제시))<br/>
		 * 9. enableCheckDuplicatePk 사용자정의 속성에 따른 PK 중복체크<br/>
		 * 10. 그리드 contextmenu 이벤트 추가 (찾기, 정렬, 필터, 컬럼숨김)<br/>
		 * 그리드에 대한 공통 로직 및 이벤트 추가 용도<br/>
		 *  - appHeader에서 공통 적용됨<br/>
		 *  - 사이트별 Customizing 필요<br/>
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid | Array} paGridId 그리드 ID
		 * @return void
		 */
		GridKit.prototype.init = function(app, paGridId){
			if(!(paGridId instanceof Array)){
				paGridId = [paGridId];
			}
			
			//Index 컬럼 반환
			function getIndexDetailColumn(poGrid){
				var detail = poGrid.detail;
				var column;
				for(var i=0, len=detail.cellCount; i<len; i++){
					column = detail.getColumn(i);
					if(column.columnType == "rowindex"){
						return column;
					}
				}
				return null;
			}
			
			var _app = app;
			var _appKit = this._appKit;
			for (var i=0, len=paGridId.length; i <len; i++) {
				/**
				 * @type cpr.controls.Grid
				 */
				var vcGrid = (paGridId[i] instanceof cpr.controls.Grid) ? paGridId[i] : _app.lookup(paGridId[i]);
				if(vcGrid == null) continue;
				
				var columnMoveableYn = ValueUtil.fixNull(vcGrid.userAttr("columnMoveFix"));
				var columnResiableYn = ValueUtil.fixNull(vcGrid.userAttr("columnResizeFix"));
				var columnSortableYn = ValueUtil.fixNull(vcGrid.userAttr("columnSortFix"));
				var clickModeFixYn = ValueUtil.fixNull(vcGrid.userAttr("clickModeFix"));
				if(columnMoveableYn == "Y") {
					vcGrid.columnMovable = false;
				}else{
					vcGrid.columnMovable = true;
				}
				if(columnResiableYn == "Y") {
					vcGrid.columnResizable = false;
				}else{
					vcGrid.columnResizable = true;
				}
				//그리드 선택 모드 변경
				if(clickModeFixYn != "Y"){
					if(vcGrid.readOnly === true){
						vcGrid.clickMode = "select";
					}else{
						vcGrid.clickMode = "edit";
					}
				}
				
				//디자인시 적용한 AutoFit 백업(컬럼숨김 팝업에서 사용)
				vcGrid._origin_autoFit = vcGrid.autoFit;
				
				var vcDataSet =  vcGrid.dataSet;
				vcDataSet._gridId = vcGrid.id;
				vcDataSet.stateRestore = true; //현재값과 Origin이 같으면... 변경없도록 처리
				
				//상태컬럼
				var statusColumn = this.getHeaderStatusColumn(app, vcGrid.id);
				if(statusColumn != null){
					// Status 컬럼 숨김
					//statusColumn.visible = false;
					var detailColumn = vcGrid.detail.getColumn(statusColumn.colIndex);
					var statusColumnCtrl = detailColumn ? detailColumn.control : null;
					if(statusColumnCtrl){
						statusColumnCtrl.bind("value").toExpression("switch(getStateString()){ case 'I' : 'N'  case 'U' : 'U'  case 'D' : 'D'  default : ''}");
						statusColumnCtrl.style.css({"text-align" : "center"});
					}
				}
				//인덱스컬럼
				var indexColumn = getIndexDetailColumn(vcGrid);
				if(indexColumn != null){
					indexColumn.style.css({"text-align" : "center"});
					var hIndexColumn = vcGrid.header.getColumn(indexColumn.colIndex);
					if(hIndexColumn && hIndexColumn.text != "No") hIndexColumn.text = "No";
				}
				
				//소트 컬럼 자동지정
				if(columnSortableYn != "Y"){
					var dColumn, hColumn, vaHColumns;
					var vsFixColSort = "";
					for(var j=0, jlen=vcGrid.detail.cellCount; j<jlen; j++){
						dColumn = vcGrid.detail.getColumn(j);
						if(dColumn.columnType == "checkbox" || dColumn.columnType == "rowindex") continue;
						if(dColumn.columnName == null || dColumn.columnName == "") continue;
						
						vsFixColSort = dColumn.control ? dColumn.control.userAttr("columnSortFix") : ""; //컬럼 정렬무시옵션
						vaHColumns = vcGrid.header.getColumnByColIndex(dColumn.colIndex, dColumn.colSpan);
						if(vaHColumns){
							vaHColumns.forEach(function(/* cpr.controls.gridpart.GridColumn */ column){
								if(vsFixColSort !== "Y"){
									column.sortable = true;
								}
								if(column.targetColumnName == null || column.targetColumnName == "") {
									column.targetColumnName = dColumn.columnName;
								}
							});
						}
					}
				}
				/*
				//읽기 전용 컬럼 헤더 Text 변경
				var vbGReadOnly = vcGrid.readOnly === true ? true : false;
				var readHTextClass = "readonly";
				var readHColor = "#959495";
				if(vbGReadOnly){
					vcGrid.style.header.css({color: readHColor});
					for(var k=0, klen=vcGrid.detail.cellCount; k<klen; k++){
						var dColumn = vcGrid.detail.getColumn(k);
						if(dColumn.control){
							if(dColumn.controlType == "numbereditor"){
								if(dColumn.control.spinButton != false && dColumn.control.style.css("text-align") == ""){
									dColumn.control.style.css({"text-align":"center"});
								}
							}
							if((dColumn.control.format === "0000" || dColumn.control.format === "9999") && dColumn.control.max == 0){
								dColumn.control.max = 1.7976931348623157E308;
							}
						}
					};
				}else{
					var vaHeaderColumn = null;
					for(var k=0, klen=vcGrid.detail.cellCount; k<klen; k++){
						var dColumn = vcGrid.detail.getColumn(k);
						if(dColumn.columnType == "rowindex"){
							vaHeaderColumn = vcGrid.header.getColumnByColIndex(dColumn.colIndex, dColumn.colSpan);
							vaHeaderColumn.forEach(function(column){
								column.style.addClass(readHTextClass);
							});
						}else if(dColumn.control == null || dColumn.controlType == "output" || dColumn.controlType == "image" || dColumn.controlType == "button"){
							vaHeaderColumn = this.getHeaderColumnByColIdex(app, vcGrid.id, dColumn.colIndex);
							vaHeaderColumn.forEach(function(column){
								column.style.addClass(readHTextClass);
							});
						}else if((dColumn.control.getBindInfo("readOnly") == undefined && dColumn.control.readOnly === true) || (dColumn.control.getBindInfo("enabled") == undefined && dColumn.control.enabled === false)){
							vaHeaderColumn = this.getHeaderColumnByColIdex(app, vcGrid.id, dColumn.colIndex);
							vaHeaderColumn.forEach(function(column){
								if(column.style.getClasses().indexOf("require") == -1){
									column.style.addClass(readHTextClass);
								}
							});
						}
						
						if(dColumn.control){
							if(dColumn.controlType == "numbereditor" && dColumn.control.spinButton != false && dColumn.control.style.css("text-align") == ""){
								dColumn.control.style.css({"text-align":"center"});
							}
						}
					}
				}
				*/
				//헤더 컬럼 Visible 원래값 저장
				var vsHidenColumnIdxs = "";
				for(var k=0, klen=vcGrid.header.cellCount; k<klen; k++){
					if(vcGrid.header.getColumn(k).visible === false){
						vsHidenColumnIdxs += k+",";
					}
				}
				vcGrid.userAttr("originHiddenColumns", vsHidenColumnIdxs);
				
				//그리드 PK컬럼 enable 설정
				var vaPkColumnNames = ValueUtil.split(vcDataSet.info, ",");
				var vsDataBindCtxId = vcGrid.userAttr("bindDataFormId");
				vaPkColumnNames.some(function(value, idx){
					if(value == "") return false;
					//그리드 PK컬럼 설정(필수 스타일, 활성화/비활성화 바인딩 처리등)
					var columns = vcGrid.detail.getColumnByName(value);
					var vaHColumns = _appKit.Grid.getHeaderColumn(_app, vcGrid.id, value);
					if(columns != null && columns.length > 0){
						columns.forEach(function(col){
							if(col.control){
								if(col.control.userAttr("editablePK") !== "Y"){
									col.control.bind("enabled").toExpression("getStateString() == 'I' ? true : false");
									col.control.userAttr("required", "Y");
									if(vaHColumns){
										vaHColumns.forEach(function(/* cpr.controls.gridpart.GridColumn */ column){
											column.style.setClasses("require");
										});
									}
									
								}
							}
						});
					}
				});
				
				//프리폼 PK 컬럼 설정 
				if(!ValueUtil.isNull(vsDataBindCtxId) && vaPkColumnNames.length > 0){
					var freeformes = ValueUtil.split(vsDataBindCtxId, ",");
					freeformes.forEach(function(/* eachType */ formId){
						/**@type cpr.controls.Container */
						var freeform = _app.lookup(formId);
						if(freeform != null){
							var vaChildCtrls = freeform.getAllRecursiveChildren();
							vaPkColumnNames.some(function(value, idx){
								if(value == "") return false;
								vaChildCtrls.some(function(ctrl, ix){
									if(ctrl.type == "output") return false;
									if(ctrl.userAttr("ignorePk") == "Y") return false;
									if(ctrl.userAttr("editablePK") == "Y") return false;
									var bind = ctrl.getBindInfo("value");
									if(bind && bind.type == "datacolumn" && value == bind.columnName){
										ctrl.bind("enabled").toExpression("getStateString() == 'I' ? true : false");
										ctrl.userAttr("required", "Y");
									}
								});
							});	
						}
					});
				}
				
				//마지막 작업행을 찾기위해서...그리드 findRow 설정
				vcDataSet.addEventListener("update", function(/* cpr.events.CDataEvent */e){
					/** 
					 * @type cpr.data.DataSet
					 */
					var dataset = e.control;
					var rowIndex = e.row.getIndex();
					var row = e.row;
					var vaPkColumns = ValueUtil.split(dataset.info, ",");
					if(vaPkColumns.length < 1){
						dataset._findRowCondition = null;
					}else{
						var vaTempCond = [];
						vaPkColumns.forEach(function(column){
							vaTempCond.push(column + "==" + "'" + dataset.getValue(rowIndex, column) + "'");
						});
						dataset._findRowCondition = vaTempCond.length > 0 ? vaTempCond.join(" && ") : null;
					}
					
				});
				
				//그리드에 바인딩된 데이터셋(Dataset)이 로드될 때 처리
				//마지막행 찾기, 조회 건수 업데이트
				vcDataSet.addEventListener("load", function(/* cpr.events.CDataEvent */e){
					/** @type cpr.data.DataSet */
					var dataset = e.control;
					/** @type cpr.controls.Grid */
					var grd = dataset.getAppInstance().lookup(dataset._gridId);
					if(grd == null) return;
					
					//대상 그리드가 정렬된 상태라면... 정렬을 푼다.
					if(dataset.getSort() != ""){
						dataset.clearSort();
					}
					
					//마지막 작업행 찾기
					if(dataset.getRowCount() > 0) {
						if(dataset._findRowCondition){
							var row = dataset.findFirstRow(dataset._findRowCondition);
							if(row) {
								if(grd.selectionUnit == "cell"){
									grd.focusCell(row.getIndex(), 0);
								}else{
									setTimeout(function(){
										_appKit.Grid.selectRow(_app, grd.id, row.getIndex());
									}, 200);
								}
							}else{
								grd.selectionUnit == "cell" ? grd.focusCell(0, 0) : _appKit.Grid.selectRow(_app, grd.id, 0);
							}
						}else{
							if(grd.selectionUnit == "cell") grd.focusCell(0, 0); else _appKit.Grid.selectRow(_app, grd.id, 0);
						}
					}else{
					}
					
					//마지막 작업행 정보 Clear
					dataset._findRowCondition = null;
					
					//그리드 타이틀 영역의 데이터 건수 업데이트
					var titles = _appKit.Group.getAllChildrenByType(_app, "udc.com.comTitle");
					for(var i=0, len=titles.length; i<len; i++){
						if(titles[i] == null) continue;
						if(titles[i].getAppProperty("ctrl") == null) continue;
						if(titles[i].getAppProperty("ctrl").id == grd.id){
							titles[i].setAppProperty("rowCount", dataset.getRowCount());
							break;
						}
					}
				});
				
				//행 삭제로 인한, 선택행이 없는 경우... 이전 행 자동 선택하도록(행 추가 -> 삭제시)
				vcGrid.addEventListener("selection-dispose", function(/* cpr.events.CGridEvent */e){
					var oldSelection = e.oldSelection;
					if (oldSelection != null && oldSelection.length > 0 && oldSelection[0] > -1 && oldSelection[0] < e.control.rowCount) {
						e.control.selectRows(oldSelection[0]);
					}
				});
				
				//그리드 키다운(Up/Down) 이벤트 처리 - 현재 포커싱된 그리드 객체정보 저장
		//		vcGrid.addEventListener("keydown", function(/* cpr.events.CKeyboardEvent */ e){
		//			if(e.keyCode == cpr.events.KeyCode.UP || e.keyCode == cpr.events.KeyCode.DOWN){
		//				_appKit.getMainApp(e.control.getAppInstance()).__focusGrid = e.control;
		//			}
		//		});
				
				//PK 중복체크
				if(vcGrid.userAttr("enableCheckDuplicatePk") === "true"){
					var _this = this;
					vcGrid.addEventListener("update", function(/* cpr.events.CGridEvent */ e){
						var vaPkColumnNames = ValueUtil.split(e.control.dataSet.info, ",");
						if(e.row.getState() == cpr.data.tabledata.RowState.INSERTED && vaPkColumnNames.indexOf(e.columnName) != -1 && e.newValue != ""){
							var pkValue = "";
							var check = true;
							var codition = "";
							vaPkColumnNames.some(function(columnName, idx){
								if(columnName == "") return false;
								var value = e.control.getCellValue(e.rowIndex, columnName);
								if(value == null || value == ""){
									check = false;
									return false;
								}
								if(codition == "") codition = columnName + "=='" + value + "'";
								else codition += "&&" + columnName + "=='" + value + "'";
							});
							
							if(check){
								var vaRows = e.control.findAllRow(codition);
								if(vaRows != null && vaRows.length > 1){
									var msgValue = "";
									var vaChildCtrls = e.control.getChildren();
									
									vaPkColumnNames.some(function(columnName, idx){
										if(columnName == "") return false;
										//var value = e.control.getCellValue(e.rowIndex, columnName);
										
										var value = _this.getHeaderColumnText(app, e.control.id, columnName);
										
										if(!ValueUtil.isNull(value)){
											vaChildCtrls.some(function(ctrl, idx){
												if(!ValueUtil.isNull(ctrl.getBindInfo("value"))){
													if(ctrl.getBindInfo("value").columnName == columnName){
									       
									       				if(ctrl instanceof cpr.controls.ComboBox
									       				  || ctrl instanceof cpr.controls.CheckBox
									       				  || ctrl instanceof cpr.controls.RadioButton){
									       				  	
															value = ctrl.getSelectionFirst().label;
														 //2019.12.02 udc예외추가	
									       				}else if(ctrl instanceof cpr.controls.UDCBase){
									       					value = ctrl.getText();
									       				}else{
									       					value = e.control.getCellValue(e.rowIndex, columnName);
									       				}
									       			    if(msgValue == "") msgValue = ValueUtil.isNull(value) ? "" : value;								
														else msgValue += ValueUtil.isNull(value) ? "" : ", "+value;
										        	}
												}
								        		
									        });
										}
									});
									
									var vnTargetRowIdx = 0;
									for(var j=0, jlen=vaRows.length; j<jlen; j++){
										if(vaRows[j].getIndex() != e.rowIndex){
											vnTargetRowIdx = vaRows[j].getIndex();
											e.control.setEditRowIndex(e.rowIndex, true);
											break;
										}
									}
									e.control.setCellValue(e.rowIndex, e.columnName, "");
									_appKit.Msg.alert("WRN-M281", [msgValue, (vnTargetRowIdx + 1)]);
									
								}
							}
						}
					});
				}
				
				vcGrid.addEventListener("contextmenu", function(/* cpr.events.CDataEvent */e){
		//			if(e.targetObject == null) return;
					/** @type cpr.controls.Grid */
					var targetGrid = e.control;
					e.preventDefault();
					
					var ctxMenu = targetGrid._contextMenu;
					if(ctxMenu == undefined || ctxMenu == null){
						ctxMenu = new cpr.controls.Menu();
						//ctxMenu.addItem(new cpr.controls.TreeItem("찾기", "1", "root"));
						ctxMenu.addItem(new cpr.controls.TreeItem("정렬취소", "2", "root"));
						ctxMenu.addItem(new cpr.controls.TreeItem("필터", "3", "root"));
						ctxMenu.addItem(new cpr.controls.TreeItem("필터취소", "4", "root"));
						ctxMenu.addItem(new cpr.controls.TreeItem("컬럼숨김", "5", "root"));
						
						targetGrid._contextMenu = ctxMenu;
						
						ctxMenu.addEventListener("item-click", function(/**@type cpr.events.CItemEvent */ e){
							var itemValue = e.item.value;
							//찾기
							if(itemValue == "1"){
								//팝업 호출 파라메터
								var initValue = {"grid": targetGrid};
								_appKit.Dialog.open(app, "app/cmn/cmnPFind", 500, 110, function(e){
								
								}, initValue);
							//정렬취소
							}else if(itemValue == "2"){
								if(targetGrid) targetGrid.header.clearSort();
							//필터 보여주기
							}else if(itemValue == "3"){
								var isHFiltered = false;
								var column, filterStr;
								for(var i=0, len=targetGrid.header.cellCount; i<len; i++){
									column = targetGrid.header.getColumn(i);
									filterStr = column.getFilter();
									if(filterStr != null && filterStr[0] != "__all__"){
										isHFiltered = true;
										break;
									}
								}
								if(!isHFiltered){
									for(var i=0, len=targetGrid.header.cellCount; i<len; i++){
										column = targetGrid.header.getColumn(i);
										if(column.targetColumnName != ""){
											column.filterable = true;
										}
									}
								}
							//필터 해제 및 필터 숨김
							}else if(itemValue == "4"){
								if(targetGrid){
									targetGrid.header.clearFilter();
									var column;
									for(var i=0, len=targetGrid.header.cellCount; i<len; i++){
										column = targetGrid.header.getColumn(i);
										column.filterable = false;
									}
								}
							//컬럼 숨김/보이기
							}else if(itemValue == "5"){
								//팝업 호출 파라메터
								var initValue = {"grid": targetGrid};
								_appKit.Dialog.open(app, "app/cmn/cmnPColumns", 400, 300, function(e){
								
								}, initValue);
							}
							ctxMenu.dispose();
							targetGrid._contextMenu = null;
						});
						ctxMenu.addEventListenerOnce("blur", function(/**@type cpr.events.CFocusEvent*/ e){
							ctxMenu.dispose();
							targetGrid._contextMenu = null;
						});
					}
				
					/**@type cpr.controls.Container */
					var rootContainer = null;
					var showConstraint = {
						"position" : "absolute",
						"top" : e.clientY + "px",
						"left" : (e.clientX - 130) + "px",
						"width" : "130px",
						"height" : "60px"
					};
					if(_appKit.Dialog.isPopup(targetGrid.getAppInstance())){
						rootContainer = targetGrid.getAppInstance().getContainer();
						if((e.clientY - rootContainer.getActualRect().top + 130) > rootContainer.getActualRect().height )
							showConstraint.top = (e.clientY - rootContainer.getActualRect().top - 130) +"px";
						else
							showConstraint.top = (e.clientY - rootContainer.getActualRect().top) +"px";
						
						//팝업은 항상 가운데 띄우기
						showConstraint.left = (targetGrid.getActualRect().width - 130)/2 +"px";
		//				if((e.x + 130) > targetGrid.getActualRect().width)
		//					showConstraint.left = targetGrid.getActualRect().width-130 +"px";
		//				else
		//					showConstraint.left = e.x +"px";
					}else{
						rootContainer = targetGrid.getAppInstance().getRootAppInstance().getContainer();
						if(e.clientX < 130){
							showConstraint.left = "0px";
						}
					}
					if(rootContainer.getLayout() instanceof cpr.controls.layouts.FormLayout){
						app.floatControl(ctxMenu, showConstraint);
					}else{
						rootContainer.addChild(ctxMenu, showConstraint);
					}
					ctxMenu.focus();
				});
				
				//그리드 noData
				vcGrid.noDataMessage = "조회된 내역이 없습니다.";
			}
		};
		
		/**
		 * 그리드 특정 cell의 값을 변경한다. (detail 영역) 
		 * (주의) for문 등으로 대량의 데이터를 setCellValue 호출하는 경우에는 pbEmitEvent값을 false로 주어서, 스크립트 실행시간을 줄여줄 수 있다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId  그리드 아이디
		 * @param {String | Number} psDataColmnId cellIndex 값을 변경하고자 하는 cell의 cell index. (또는 binding된 data column name)
		 * @param {String} psValue 변경하고자 하는 값.
		 * @param {Number} pnRowIndex (Optional) 값을 변경하고자 하는 cell의 row index.
		 *                 defalut : 선택된 rowindex
		 * @param {Boolean} pbEmitEvent (Optional) 이벤트(before-update, update)를 발생시킬지 여부.
		 * @return void
		 */
		GridKit.prototype.setCellValue = function(app, psGridId, psDataColmnId, psValue, pnRowIndex, pbEmitEvent){
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			var rowIndex = pnRowIndex == null ? this.getIndex(app, psGridId) : pnRowIndex;
			
			vcGrid.setCellValue(rowIndex, psDataColmnId, psValue, pbEmitEvent);
		};
		
		/**
		 * 그리드 특정 cell의 값을 반환한다.(detail 영역) 
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId  그리드 ID
		 * @param {String | Number} psDataColmnId cellIndex 값을 가져오고자 하는 cell의 cell index. (또는 binding된 data column name)
		 * @param {Number} pnRowIdx (Optional) 값을 변경하고자 하는 cell의 row index.
		 *                 defalut : 선택된 rowindex
		 * @return {Object} 해당 cell의 값.
		 */
		GridKit.prototype.getCellValue = function(app, psGridId, psDataColmnId, pnRowIndex){
			/**@type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			var rowIndex = pnRowIndex == null ? this.getIndex(app, psGridId) : pnRowIndex;
			return vcGrid.getCellValue(rowIndex, psDataColmnId);
		};
		
		/**
		 * 현재 연결된 데이터 구조체에 sort 조건을 변경하고, sort 적용
		 * Grid.sort(app, "grd1", "a, b DESC")
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId  그리드 아이디
		 * @param {String} psCondition sort 조건식.
		 * @return void
		 */
		GridKit.prototype.sort = function(app, psGridId, psCondition){
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			vcGrid.clearSort();
			vcGrid.sort(psCondition);
			vcGrid.redraw();
		};
		
		/**
		 * 그리드 초기화(데이터 clear)
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid | Array} paGridId 그리드 ID
		 * @return void
		 */
		GridKit.prototype.reset = function(app, paGridId){
			if(!(paGridId instanceof Array)){
				paGridId = [paGridId];
			 }
			
			for (var i = 0; i < paGridId.length; i++) {
				var vcGrid = app.lookup(paGridId[i]);
				vcGrid.dataSet.clear();
				vcGrid.redraw();
			}
		};
		
		
		/**
		 * 현재 연결된 데이터 구조체에 filter 조건을 변경하고, filter합니다.<br/>
		 * Grid.filter(app, "grd1", "age >= 20")<br/>
		 * 	=> "age"컬럼의 값이 20이상인 값만 필터링합니다.<br/>
		 * Grid.filter(app, "grd1", "name ^= '김'")<br/>
		 * 	=> "name"컬럼의 값이 '김'으로 시작하는 값만 필터링합니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 아이디
		 * @param {String} psCondition filter 조건식.
		 * @return void
		 */
		GridKit.prototype.filter = function(app, psGridId, psCondition){
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			var vsFilter = vcGrid.getFilter();
			if(!ValueUtil.isNull(vsFilter)){
				vcGrid.clearFilter();	
			}
			vcGrid.filter(psCondition);
		};
		
		
		/**
		 * 그리드의 변경사항 유/무를 반환를 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid | Array} paGridId 그리드 ID
		 * @param {String} psAftMsg  (Optional) MSG or CRM or SAVE
		 *						MSG : 변경사항 내역이 없을 경우 '변경된 내역이 없습니다.' 메세지 출력
		 *  					CRM : 변경내역이 존재할경우 '변경사항이 반영되지 않았습니다. 계속 하시겠습니까?' confirm 메시지출력 
		 * 						SAVE : 변경된 데이터가 있습니다. 저장 하시겠습니까? confirm 메시지출력
		 * @param {cpr.events.CSelectionEvent} event (Optional) 이벤트 객체
		 * @param {Function} poCallBackFunc  (Optional) 콜백함수
		 * @return {Boolean} 데이터 변경 여부
		 */
		GridKit.prototype.isModified = function(app, paGridId, psAftMsg, event, poCallBackFunc){
			//유효성 체크로 인해서 행선택 변경 발생으로 변경여부 체크가 되는 경우는 SKIP...
			if(event != null && event.control != null && event.control.userAttr("selectionChangeByValidation") === "true"){
				event.control.removeUserAttr("selectionChangeByValidation");
				return false;
			}
			
			if(!(paGridId instanceof Array)){
				paGridId = [paGridId];
			}
			psAftMsg = psAftMsg == null ? "" : psAftMsg;
			
			var modify = false;
			var vcGrid = null;
			for (var i=0, len=paGridId.length; i<len; i++) {
				if(paGridId[i] instanceof cpr.controls.Grid) { 
					vcGrid = paGridId[i];
				}else{
					vcGrid = app.lookup(paGridId[i]);
				}
				
				//사용자 정의 속성에 modify 무시 속성이 있는 경우... SKIP
				if(vcGrid.userAttr("ignoreModify") === "Y") continue;
				if(vcGrid.dataSet == null) continue;
				
				if (vcGrid.dataSet.isModified()) {
					modify = true;
					break;
				}
			}
			
			if(modify){
				if(psAftMsg.toUpperCase() == "CRM"){//변경사항이 반영되지 않았습니다. 계속 하시겠습니까? confirm
					if(!this._appKit.Msg.confirm("CRM-M003", [vcGrid.fieldLabel])) return true;
					else return false;
				}
			}else{
				if(psAftMsg.toUpperCase() == "MSG"){//변경된 내역이 없습니다.
					this._appKit.Msg.notify(app, "INF-M006");
				}
			}
			
			return modify;
		};
		
		/**
		 * 해당 그리드의 체크된 행(Row)이나 선택된 행의 인덱스를 반환한다.(check된 행이 있는 경우, 체크된 행이 우선적으로 반환된다.)
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId  그리드 ID
		 * @return {Number[]} 선택된 row index 배열.
		 */
		GridKit.prototype.getCheckOrSelectedRowIndex = function(app, psGridId){
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			if(vcGrid.rowCount < 1) return [];
			
			var vaChkIndexs = vcGrid.getCheckRowIndices();
			if(vaChkIndexs != null && vaChkIndexs.length > 0 ){
				return vaChkIndexs;
			}else{
				if(vcGrid.selectionUnit == "cell"){
					var vaSelIndices = vcGrid.getSelectedIndices();
					var rowIndices = [];
					for(var i=0, len=vaSelIndices.length; i<len; i++){
						rowIndices.push(vaSelIndices[i].rowIndex);
					}
					return rowIndices;
				}else{
					return vcGrid.getSelectedRowIndices();
				}
			}
		};
		
		/**
		 * 해당 그리드의 체크된 행(Row)의 인덱스를 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId  그리드 ID
		 * @return {Number[]} 선택된 row index 배열.
		 */
		GridKit.prototype.getCheckedRowIndex = function(app, psGridId){
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			if(vcGrid.rowCount < 1) return [];
			
			var vaChkIndexs = vcGrid.getCheckRowIndices();
			if(vaChkIndexs != null && vaChkIndexs.length > 0 ){
				return vaChkIndexs;
			}else{
				return [];
			}
		};
		
		/**
		 * 그리드 내 변경된 특정 행(Row)의 데이터를 원상태로 복구한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId  그리드 ID
		 * @param {Number} pnRowIndex (Optional) 원복하고 싶은 row index
		 *                 default : 현재 체크 및 선택된 로우
		 * @return void
		 */
		GridKit.prototype.revertRowData = function(app, psGridId, pnRowIndex){
			/**@type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			
			if(pnRowIndex == null){
				var vaSelectIdx = this.getCheckOrSelectedRowIndex(app, psGridId);
				if(vaSelectIdx.length < 1){
					return false;
				}
				var vcDataSet = vcGrid.dataSet;
				var rowIndex;
				for(var i = vaSelectIdx.length - 1; i >= 0; i--) {
					rowIndex = vaSelectIdx[i];
					vcGrid.setCheckRowIndex(rowIndex, false); //체크 해제
					var vsStatus = "";
				    if (vcDataSet != null ){
						vsStatus = vcDataSet.getRowStateString(rowIndex);			    	
				    }
					vcGrid.revertRowData(rowIndex); //데이터 원복
					//신규 행이면...
					if (vsStatus == "I") {
						if(rowIndex == vcGrid.getRowCount()){
							if(rowIndex == 0){
								vcGrid.clearSelection();
							}else{
								this.selectRow(app, vcGrid.id, rowIndex-1);
							}
						}else{
							this.selectRow(app, vcGrid.id, rowIndex);
						}
					}
				}
			}else{
				vcGrid.revertRowData(pnRowIndex);
			}
		};
		
		/**
		 * 그리드 내에서 변경된 모든 데이터를 원상태로 복구한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId  그리드 ID
		 */
		GridKit.prototype.revertAllData = function(app, psGridId){
			var vcGrid = app.lookup(psGridId);
			vcGrid.revertData();
		};
		
		/**
		 * 그리드의 특정 행 데이터를 그룹 폼의 데이터셋에 복사한다.<br/>
		 * (사용처) 그리드의 데이터셋을 바인딩하여 사용하지 않는 경우에... 그리드의 선택된 행 데이터를 프리폼/그룹에 매핑하기 위한 용도임
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드ID
		 * @param {#Container} psTargetForm 복사할 Group Form ID
		 * @param {Number} pnRowIdx 복사할 그리드 로우 인덱스 
		 * @return void
		 */
		GridKit.prototype.copyRowToGroupForm = function(app, psGridId, psTargetForm, pnRowIdx){
			var vcGrid = app.lookup(psGridId);
			var rowIndex = pnRowIdx == null ? this.getIndex(app, psGridId) : pnRowIdx;
			
			var vcGrpFrm = app.lookup(psTargetForm);
			vcGrpFrm.getBindContext().rowIndex = rowIndex;
			vcGrpFrm.redraw();
		};
		
		/**
		 * 소스(Source) 그리드의 선택된 행(Row)의 데이터를 타겟(Target) 그리드로 복사한다.
		 * 단, 복사할려는 데이터가 타겟 그리드에 이미 존재하는 경우에는 복사하지 않는다.(중복 복사 방지)
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psSrcGridId 그리드ID
		 * @param {#Grid} psDesGridId 복사할 그리드 ID
		 * @param {Number} pnSrcRowIdx (Optional) 그리드 로우 인덱스
		 *                 default : 체크된 row 나 선택된 row 인덱스를 취득 (check우선)
		 * @return void
		 */
		GridKit.prototype.copyToGridData = function(app, psSrcGridId, psDesGridId, pnSrcRowIdx){
			var vcSrcGrid = app.lookup(psSrcGridId);
			var vcDesGrid = app.lookup(psDesGridId);
			
			var rowIndexs = pnSrcRowIdx == null ? this.getCheckOrSelectedRowIndex(app, psSrcGridId) :  pnSrcRowIdx;
			if(!(rowIndexs instanceof Array)){
				rowIndexs = [rowIndexs];
			}
			//복사할 ROW가 없으면...SKIP
			if (rowIndexs.length < 1) return;
			
			var srcDataSet = vcSrcGrid.dataSet;
			var tarDataSet = vcDesGrid.dataSet;
			for (var i=0, len=rowIndexs.length; i<len; i++) {
				//신규 후 삭제된 행은 제외
				if(srcDataSet.getRowState(rowIndexs[i]) == cpr.data.tabledata.RowState.INSERTDELETED) continue;
				
				var data = srcDataSet.getRowData(rowIndexs[i]);
				// json 형식의 row의 데이터
				var str = [];
				// 이미 존재하는 row를 찾기 위해 row의 모든 column을 비교하는 조건 제작
				// str = "column1 == 'value1' && column2 == 'value2'..."
				for ( var key in data) {
					str.push(key + " == '" + data[key] + "'");
				}
				str = str.join(" && ");
				// 조건에 맞는 row 탐색
				var findRow = tarDataSet.findAllRow(str);
				// 조건에 해당하는 row가 없다면 target 그리드에 선택된 row를 추가
				if (findRow == null || findRow.length < 1) {
					tarDataSet.addRowData(data);
				}
			}
			
			vcDesGrid.redraw();
		};
		
		/**
		 * 소스(Source) 그리드의 모든 행(Row)의 데이터를 타겟(Target) 그리드로 복사한다.
		 * 단, 복사할려는 데이터가 타겟 그리드에 이미 존재하는 경우에는 복사하지 않는다.(중복 복사 방지)
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psSrcGridId 그리드ID
		 * @param {#Grid} psDesGridId 복사할 그리드 ID
		 * @return void
		 */
		GridKit.prototype.copyToAllGridData = function(app, psSrcGridId, psDesGridId){
			var vcSrcGrid = app.lookup(psSrcGridId);
		
			var indices = [];
			for (var i=0, len=vcSrcGrid.rowCount; i<len; i++) {
				indices.push(i);
			}
			
			this.copyToGridData(app, psSrcGridId, psDesGridId, indices);
		};
		
		/**
		 * 그리드 작업행을 찾기 위한 조건을 설정한다. 데이터셋에 설정된 PK정보를 기준으로 자동 지정된다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드ID
		 * @param {Number} pnRowIndex (Optional) 그리드 로우(Row) 인덱스
		 * @param {Boolean} pbForce (Optional) 기존에 로우에 대한 정보가 있으면 SKIP 여부
		 * @return void
		 */
		GridKit.prototype.markFindRowCondition = function(app, psGridId, pnRowIndex, pbForce){
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			var voDataSet = vcGrid.dataSet;
			
			if(pbForce != undefined && ValueUtil.fixBoolean(pbForce) === true){
				if(!ValueUtil.isNull(voDataSet._findRowCondition)) return;
			}
			
			var rowIndex = !ValueUtil.isNull(pnRowIndex) ? pnRowIndex : this.getIndex(app, psGridId);
			
			var vaTempCond = [];
			var vaPkColumns = ValueUtil.split(voDataSet.info, ",");
			vaPkColumns.forEach(function(column){
				vaTempCond.push(column + "==" + "'" + voDataSet.getValue(rowIndex, column) + "'");
			});
			
			if(vaTempCond.length > 0){
				voDataSet._findRowCondition = vaTempCond.join(" && ");
			}else{
				voDataSet._findRowCondition = null;
			}
		};
		
		/**
		 * 소스(Source) 그리드의 선택된 행(Row)의 데이터를 타겟(Target) 그리드로 이동한다.
		 * 데이터 이동 후, 소스(Source) 그리드의 이동된 행(Row)의 상태는 delete모드로 상태값만 변경된다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psSrcGridId 그리드ID
		 * @param {#Grid} psDesGridId 이동할 그리드 ID
		 * @param {Number | Number[]} pnSrcRowIdx (Optional) 그리드 로우 인덱스<br/>
		 *                            default : 체크된 row 나 선택된 row 인덱스를 취득 (check우선)
		 * @return void
		 */
		GridKit.prototype.moveToGridData = function(app, psSrcGridId, psDesGridId, pnSrcRowIdx){
			var vcSrcGrid = app.lookup(psSrcGridId);
			var vcDesGrid = app.lookup(psDesGridId);
			
			var rowIndexs = pnSrcRowIdx == null ? this.getCheckOrSelectedRowIndex(app, psSrcGridId) :  pnSrcRowIdx;
			if(!(rowIndexs instanceof Array)){
				rowIndexs = [rowIndexs];
			}
			//이동할 ROW가 없으면...SKIP
			if(rowIndexs.length < 1) return;
			
			var srcDataSet = vcSrcGrid.dataSet;
			var tarDataSet = vcDesGrid.dataSet;
			for(var i=0, len=rowIndexs.length; i<len; i++){
				//신규 후 삭제된 행은 제외
				if(srcDataSet.getRowState(rowIndexs[i]) == cpr.data.tabledata.RowState.INSERTDELETED) continue;
				
				tarDataSet.addRowData(srcDataSet.getRowData(rowIndexs[i]));
			}
			vcDesGrid.redraw();
			vcSrcGrid.deleteRow(pnSrcRowIdx);
		};
		
		/**
		 * 소스(Source) 그리드의 모든 데이터행(Row)을 타겟(Target) 그리드로 이동한다.
		 * 데이터 이동 후, 소스(Source) 그리드의 이동된 행(Row)의 상태는 delete모드로 상태값만 변경된다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psSrcGridId 그리드ID
		 * @param {#Grid} psDesGridId 이동할 그리드 ID
		 */
		GridKit.prototype.moveToAllGridData = function(app, psSrcGridId, psDesGridId) {
			var vcSrcGrid = app.lookup(psSrcGridId);
		
			var indices = [];
			for (var i=0, len=vcSrcGrid.rowCount; i<len; i++) {
				indices.push(i);
			}
			
			this.moveToGridData(app, psSrcGridId, psDesGridId, indices);
		};
		
		/**
		 * 그리드에서 로우(Row)를 선택해준다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드ID
		 * @param {Number} pnRowIndex (Optional) 포커스를 부여할 Row의 인덱스(default : 현재 행 인덱스)
		 * @return void
		 */
		GridKit.prototype.selectRow = function(app, psGridId, pnRowIndex) {
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			if(pnRowIndex == null || pnRowIndex == undefined){
				pnRowIndex = this.getIndex(app, psGridId);
			}
			
			vcGrid.selectRows(pnRowIndex);
			vcGrid.focusCell(pnRowIndex, 0);
		};
		
		/**
		 * 그리드에서 조건을 만족하는 로우(Row)를 선택해준다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드ID
		 * @param {String} psCondition 조건식
		 *                 ex)"STUD_DIV_RCD == 'CT101REGU' && SA_NM == '컴퓨터정보과'"
		 * 					사용가능수식 !=", "!==", "$=", "%", "&&", "(", "*", "*=", "+", ",", "-", ".", "/", "/*", "//", "<", "<=", "==", "===", ">", ">=", "?", "[", "^=", "||"
		 * @param {Number} pnCellIdx (Optional) 포커스를 부여할 Cell의 인덱스
		 *                 default : 조건에 만족하는 행 select
		 * @return void
		 */
		GridKit.prototype.selectRowByCondition = function(app, psGridId, psCondition, pnCellIdx) {
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			var voRow = vcGrid.findFirstRow(psCondition);
			
			if(voRow){
				if(pnCellIdx) vcGrid.focusCell(voRow.getIndex(), pnCellIdx);
				else vcGrid.selectRows(voRow.getIndex());
			}
		};
		
		/**
		 * 그리드 행선택 변경 이벤트 발생시, 변경 이전에 선택된 행을 선택해준다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {cpr.events.CSelectionEvent} event 그리드 선택행 변경 이벤트
		 * @param {Boolean} emitEvent (Optional) 이벤트(before-selection-change, selection-change)를 발생시킬지 여부
		 * @return void
		 */
		GridKit.prototype.selectBeforeRow = function(app, event, emitEvent) {
			/** @type cpr.controls.Grid */
			var vcGrid = event.control;
			var emit = emitEvent === true ? true : false;
			
			var voOldSelection = event.oldSelection[0];
			var vsPkValues = this.getRowPKColumnValues(app, vcGrid.id, voOldSelection);
			var voFindRow = vcGrid.findFirstRow(vsPkValues);
			if(voFindRow){
				vcGrid.clearSelection(false);
				if(vcGrid.selectionUnit == "cell"){
					vcGrid.selectCells([{rowIndex:voFindRow["rowIndex"], cellIndex:voFindRow["cellIndex"]}], emit);
				}else{
					vcGrid.selectRows(voFindRow.getIndex(), emit);
				}
			}
		};
		
		/**
		 * 그리드에 신규 행(Row)을 추가한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId      그리드 ID
		 * @param {String | Number} pnEditCellIdx 시작 cellIndex cell index 또는 column name.
		 * @param {Number} pnRowIdx (Optional) 추가하고자 하는 Row index
		 *                 defalut : 현재 선택된 로우 이후
		 * @param {Object} poRowData (Optional) 추가할 row data. (key: header명, value: value 를 갖는 json data)
		 * @return {cpr.controls.provider.GridRow} 추가한 Row의 GridRow 객체.
		 */
		GridKit.prototype.insertRow = function(app, psGridId, pnEditCellIdx, pnRowIdx, poRowData) {
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			var rowIndex = pnRowIdx == null ? this.getIndex(app, psGridId) : pnRowIdx;
			
			var insertedRow = null;
			if(poRowData != null)
				insertedRow = vcGrid.insertRowData(rowIndex, true, poRowData);
			else
				insertedRow = vcGrid.insertRow(rowIndex, true);
			
			var vnInsIdx = insertedRow.getIndex();
			
			if(vcGrid.readOnly){
				vcGrid.selectRows([ vnInsIdx ]);
			}else{
				vcGrid.selectRows([ vnInsIdx ]);
				vcGrid.setEditRowIndex(vnInsIdx, true);
			}
			
				
			if(pnEditCellIdx){
				vcGrid.focusCell(vnInsIdx, pnEditCellIdx);
				//포커싱할 컬럼이 UDC인 경우에...
				if(!ValueUtil.isNumber(pnEditCellIdx)){
					for(var i=0,len=vcGrid.detail.cellCount; i<len; i++){
						if(vcGrid.detail.getColumn(i).columnName == pnEditCellIdx){
							var ctrl = vcGrid.detail.getColumn(i).control;
							if(ctrl instanceof cpr.controls.UDCBase){
								var empApp = ctrl.getEmbeddedAppInstance();
								ctrl = AppUtil.getUDCBindValueControl(ctrl);
								if(ctrl) empApp.focus(ctrl.id);
							}
							break;
						}
					}
				}
			}else{
				vcGrid.focusCell(vnInsIdx, 0);
			}
			//그리드에 바인딩된 프리폼이 있는 경우... 프리폼 활성화
			if(!ValueUtil.isNull(vcGrid.userAttr("bindDataFormId"))){
				var freeformes = ValueUtil.split(vcGrid.userAttr("bindDataFormId"), ",");
				freeformes.forEach(function(/* eachType */ formId){
					/**@type cpr.controls.Container */
					var freeform = vcGrid.getAppInstance().lookup(formId);
					if(freeform != null){
						if(freeform._expressEnabled) freeform.bind("enabled").toExpression(freeform._expressEnabled);
						else freeform.enabled = true;
					}
				});
			}
			
			return insertedRow;
		};
		
		/**
		 * 그리드에 단 한건의 신규 행(Row)을 추가한다. (단하나의 신규 행만 추가하고자 하는 경우에 사용)
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId      그리드 ID
		 * @param {String | Number} pnEditCellIdx 시작 cellIndex cell index 또는 column name.
		 * @param {#Grid | Array} paModifiedGrid
		 * @param {Number} pnRowIdx (Optional) 추가하고자 하는 Row index
		 *                 defalut : 현재 선택된 로우 이후
		 * @param {Object} poRowData (Optional) 추가할 row data. (key: header명, value: value 를 갖는 json data)
		 * @return {cpr.controls.provider.GridRow} 추가한 Row의 GridRow 객체.
		 */
		GridKit.prototype.insertRowOnlyOne = function(app, psGridId, pnEditCellIdx, paModifiedGrid, pnRowIdx, poRowData) {
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			if(vcGrid == null) return null;
			var rowIndex = pnRowIdx == null ? this.getIndex(app, psGridId) : pnRowIdx;
			
			var insertedRow = null;
			if(vcGrid.dataSet.getRowStatedCount(cpr.data.tabledata.RowState.INSERTED) > 0){
				for(var i=0, len=vcGrid.rowCount; i<len; i++){
					if(vcGrid.getRowState(i) == cpr.data.tabledata.RowState.INSERTED){
						insertedRow = vcGrid.getRow(i);
						break;
					}
				}
			}
			
			if(insertedRow){
				//신규 추가된 행이 존재합니다.변경사항이 반영되지 않았습니다. 계속 하시겠습니까?
				if(!this._appKit.Msg.confirm("CRM-M206", [vcGrid.fieldLabel])) return null;
				this._appKit.Control.reset(app, paModifiedGrid);
				var vaColumns = vcGrid.dataSet.getColumnNames();
				vaColumns.forEach(function(column){
					vcGrid.setCellValue(insertedRow.getIndex(), column, "", false);
				});
			}else{
				if(this.isModified(app, paModifiedGrid, "CRM")) return null;
				this._appKit.Control.reset(app, paModifiedGrid);
				insertedRow = vcGrid.insertRow(rowIndex, true);
			}
			
			var vnInsIdx = insertedRow.getIndex();
			if(vcGrid.readOnly){
				vcGrid.selectRows([ vnInsIdx ]);
			}else{
				vcGrid.selectRows([ vnInsIdx ]);
				vcGrid.setEditRowIndex(vnInsIdx, true);
			}
				
			if(pnEditCellIdx){
				vcGrid.focusCell(vnInsIdx, pnEditCellIdx);
				//포커싱할 컬럼이 UDC인 경우에...
				if(!ValueUtil.isNumber(pnEditCellIdx)){
					for(var i=0,len=vcGrid.detail.cellCount; i<len; i++){
						if(vcGrid.detail.getColumn(i).columnName == pnEditCellIdx){
							var ctrl = vcGrid.detail.getColumn(i).control;
							if(ctrl instanceof cpr.controls.UDCBase){
								var empApp = ctrl.getEmbeddedAppInstance();
								ctrl = AppUtil.getUDCBindValueControl(ctrl);
								if(ctrl) empApp.focus(ctrl.id);
							}
							break;
						}
					}
				}
			}
			
			return insertedRow;
		};
		
		/**
		 * 그리드의 선택된 행(Row)를 삭제한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 아이디
		 * @param {Number | Number[]} pnRowIdx (Optional) 삭제하고자 하는 Row index
		 *                 default : 체크된 row 나 선택된 row 인덱스를 취득 (check우선)
		 * @return {Number[]} 삭제된 행 (배열)                
		 */
		GridKit.prototype.deleteRow = function(app, psGridId, pnRowIdx) {
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			var _this = this;
			
			var rowIndexs = pnRowIdx == null ? this.getCheckOrSelectedRowIndex(app, psGridId) :  pnRowIdx;
			
			if(!(rowIndexs instanceof Array)){
				rowIndexs = [pnRowIdx];
			}
			//삭제할 행이 없는 경우... 메시지 박스를 보여줌
			if(rowIndexs.length < 1){
				//삭제할 데이터가 없습니다.
				this._appKit.Msg.alert("INF-M007");
				return false;
			}
			
			//신규 후 삭제시... 디테일 데이터에 대한 Reference 삭제(삭제 플래그로 업데이트)
			var vaDetailCtrls = null;
			
			var vcDataSet = vcGrid.dataSet;
			for(var i = rowIndexs.length - 1; i >= 0; i--) {
			    var rowIdx = rowIndexs[i];
			    vcGrid.deleteRow(rowIdx);
			    
				if (vcDataSet != null ){
					if (vcDataSet.getRowState(rowIdx) == cpr.data.tabledata.RowState.INSERTDELETED) {
						
						vcGrid.revertRowData(rowIdx);
						if(rowIdx == vcGrid.getRowCount()){
							if(rowIdx == 0){
								vcGrid.clearSelection();
							}else{
								vcGrid.selectRows(rowIdx-1);						
							}
						}else{
							vcGrid.selectRows(rowIdx);
						}
					}
				}	
			}
			
			//그리드에 바인딩된 프리폼이 있는 경우... 프리폼 활성화
			if(!ValueUtil.isNull(vcGrid.userAttr("bindDataFormId"))){
				var freeformes = ValueUtil.split(vcGrid.userAttr("bindDataFormId"), ",");
				freeformes.forEach(function(/* eachType */ formId){
					/**@type cpr.controls.Container */
					var freeform = vcGrid.getAppInstance().lookup(formId);
					if(freeform != null){
						var voDs = _this._appKit.Group.getBindDataSet(freeform.getAppInstance(), freeform);
						//데이터 건수가 없으면... 프리폼 비활성화
						if(voDs.getRowCount() < 1) {
							freeform.enabled = false;
						}
					}
				});
			}
			
			return rowIndexs;
		};
		
		/**
		 * 특정 row의 상태값을 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId
		 * @param {Number} pnRowIdx 상태를 알고자 하는 row index
		 * @return {cpr.data.tabledata.RowState} 해당 row index의 상태값.<br>
					<state 종류><br>
					cpr.data.tabledata.RowState.EMPTIED : 삭제된 로우를 커밋 시 삭제된 배열을에서 제거하기 위한 임시 상태.<br>
					cpr.data.tabledata.RowState.UNCHANGED : 변경되지 않은 상태.<br>
					cpr.data.tabledata.RowState.INSERTED : 행이 신규로 추가된 상태.<br>
					cpr.data.tabledata.RowState.UPDATED : 행이 수정된 상태.<br>
					cpr.data.tabledata.RowState.DELETED : 행이 삭제된 상태.<br>
					cpr.data.tabledata.RowState.INSERTDELETED : 행이 추가되었다가 삭제된 상태.
		 */
		GridKit.prototype.getRowState = function(app, psGridId, pnRowIdx) {
			var vcGrid = app.lookup(psGridId);
			var rowIndex = pnRowIdx == null ? this.getIndex(app, psGridId) : pnRowIdx;
			return vcGrid.getRowState(rowIndex);
		};
		
		/**
		 * 특정 row의 상태를 변경한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @param {cpr.data.tabledata.RowState} state 변경할 상태값. <br>
				<state 종류><br>
				cpr.data.tabledata.RowState.UNCHANGED : 변경되지 않은 상태.<br>
				cpr.data.tabledata.RowState.INSERTED : 행이 신규로 추가된 상태.<br>
				cpr.data.tabledata.RowState.UPDATED : 행이 수정된 상태.<br>
				cpr.data.tabledata.RowState.DELETED : 행이 삭제된 상태.<br>
		 * @param {Number} pnRowIdx pnRowIdx 변경하고자 하는 row index
		 */
		GridKit.prototype.setRowState = function(app, psGridId, state, pnRowIdx) {
			var vcGrid = app.lookup(psGridId);
			var rowIndex = pnRowIdx == null ? this.getIndex(app, psGridId) : pnRowIdx;
			vcGrid.setRowState(rowIndex, state);
		};
		
		/**
		 * 전체 row의 상태값을 특정 상태(state)로 일괄 업데이트 한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @param {cpr.data.tabledata.RowState} state 변경할 상태값. <br>
				<state 종류><br>
				cpr.data.tabledata.RowState.UNCHANGED : 변경되지 않은 상태.<br>
				cpr.data.tabledata.RowState.INSERTED : 행이 신규로 추가된 상태.<br>
				cpr.data.tabledata.RowState.UPDATED : 행이 수정된 상태.<br>
				cpr.data.tabledata.RowState.DELETED : 행이 삭제된 상태.<br>
		 */
		GridKit.prototype.setRowStateAll = function(app, psGridId, state) {
			var vcGrid = app.lookup(psGridId);
			var vcDataSet = vcGrid.dataSet;
			vcDataSet.setRowStateAll(state);
			vcGrid.redraw();
		};
		
		/**
		 * 해당 상태 값을 갖는 row를 검색하여 row index 배열을 반환합니다.
		 * <pre><code>
		 * Grid.getRowStatedIndices("grd1",cpr.data.tabledata.RowState.UPDATED)
		 * </code></pre>
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} 그리드 ID
		 * @param {cpr.data.tabledata.RowState} state 검색할 상태값.<br>
					<state 종류><br>
					cpr.data.tabledata.RowState.UNCHANGED : 변경되지 않은 상태.<br>
					cpr.data.tabledata.RowState.INSERTED : 행이 신규로 추가된 상태.<br>
					cpr.data.tabledata.RowState.UPDATED : 행이 수정된 상태.<br>
					cpr.data.tabledata.RowState.DELETED : 행이 삭제된 상태.<br>
		 * @return {Array} row index 배열
		 */
		GridKit.prototype.getRowStatedIndices = function(app, psGridId, state) {
			var vcGrid = app.lookup(psGridId);
			return vcGrid.dataSet.getRowStatedIndices(state);
		};
		
		/**
		 * 그리드의 로우 갯수 반환
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @return {Number}  로우 카운트 
		 */
		GridKit.prototype.getRowCount = function(app, psGridId) {
			var vcGrid = app.lookup(psGridId);
			return vcGrid.rowCount;
		};
		
		/**
		 * 그리드의 현재 선택된 행의 인덱스(Index)를 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @return {Number}  로우(Row) 인덱스 
		 */
		GridKit.prototype.getIndex = function(app, psGridId) {
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			return vcGrid.selectionUnit != "cell" ? vcGrid.getSelectedRowIndex() : vcGrid.getSelectedIndices()[0]["rowIndex"];
		};
		
		/**
		 * 그리드 디테일 columnname로 헤더 컬럼 취득
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드ID
		 * @param {String} psColumnName 컬럼명
		 * @return {Array} 헤더 컬럼 배열Array(cpr.controls.gridpart.GridColumn)
		 */
		GridKit.prototype.getHeaderColumn = function(app, psGridId, psColumnName) {
			/** @type cpr.controls.Grid*/
			var vcGrid = app.lookup(psGridId);
		    var vaDetailColumn = vcGrid.detail.getColumnByName(psColumnName);
			
			var vaHeaderColumns = new Array();
			vaDetailColumn.forEach(function(dColumn){
				var vaHeaderColumn = vcGrid.header.getColumnByColIndex(dColumn.colIndex, dColumn.colSpan);
				vaHeaderColumn.forEach(function(hColumn){
					vaHeaderColumns.push(hColumn);	
				});
			});
			
			return vaHeaderColumns;
		};
		
		/**
		 * 그리드 디테일 컬럼의 ColIndex로 헤더 컬럼 취득
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드ID
		 * @param {Number} pnColIndex 컬럼 ColIndex
		 * @return {Array} 헤더 컬럼 배열Array(cpr.controls.gridpart.GridColumn)
		 */
		GridKit.prototype.getHeaderColumnByColIdex = function(app, psGridId, pnColIndex) {
			/** @type cpr.controls.Grid*/
			var vcGrid = app.lookup(psGridId);
			var voHeader = vcGrid.header;
			
			var vaHeaderColumns = new Array();
			var hColumn;
			for(var i=0, len=voHeader.cellCount; i<len; i++){
				hColumn = voHeader.getColumn(i);
				if(hColumn != null && hColumn.colIndex == pnColIndex){
					vaHeaderColumns.push(hColumn);
				}
			}
			
			return vaHeaderColumns;
		};
		
		/**
		 * 그리드 헤더 컬럼의 텍스트(text) 문자열을 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @param {String} psColumnName 컬럼명
		 * @return {String} 헤더 컬럼 text
		 */
		GridKit.prototype.getHeaderColumnText = function(app, psGridId, psColumnName) {
			var vaColumns = this.getHeaderColumn(app, psGridId, psColumnName);
			return vaColumns.length > 0 ? vaColumns[0].getText() : "";
		};
		
		/**
		 * 그리드 헤더 중에 STATUS 컬럼 객체를 반환한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @return {cpr.controls.gridpart.GridHeaderColumn} 헤더 컬럼
		 */
		GridKit.prototype.getHeaderStatusColumn = function(app, psGridId) {
			var header = app.lookup(psGridId).header;
			var column = null;
			for(var i=0, len=header.cellCount; i<len; i++){
				column = header.getColumn(i);
				if(column.getText() == "F"){
					return column;
				}
			}
			return null;
		};
		
		/**
		 * 그리드 내 컬럼을 숨긴다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @param {String} psColumnName 컬럼 명
		 * @return void
		 */	 
		GridKit.prototype.hideColumn = function(app, psGridId, psColumnName){
		 	/** @type cpr.controls.Grid*/
		 	var vcGrid = app.lookup(psGridId);
			var vaColumns = this.getHeaderColumn(app, psGridId, psColumnName);
			if(vaColumns.length > 0){
			 	vcGrid.columnVisible(vaColumns[0].colIndex, false);
			}
		};
		 
		/**
		 * 그리드 컬럼을 보이도록 변경한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @param {String} psColumnName 컬럼명
		 * @return void
		 */	 
		GridKit.prototype.showColumn = function(app, psGridId, psColumnName){
		 	/** @type cpr.controls.Grid*/
		 	var vcGrid = app.lookup(psGridId);
			var vaColumns = this.getHeaderColumn(app, psGridId, psColumnName);
			if(vaColumns.length > 0){
			 	vcGrid.columnVisible(vaColumns[0].colIndex, true);
			}
		};
		
		/**
		 * 그리드의 데이터셋의 FindRow를 지정한다.
		 * 해당 함수 사용시 그리드 조회시 psFindRowCond로 지정된 행이 자동 선택된다. 
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @param {String} psCondition 조건식 <br/>
		 *                 ex)"STUD_DIV_RCD == 'CT101REGU' && SA_NM == '컴퓨터정보과'" <br/>
		 * 					사용가능수식 !=", "!==", "$=", "%", "&&", "(", "*", "*=", "+", ",", "-", ".", "/", "/*", "//", "<", "<=", "==", "===", ">", ">=", "?", "[", "^=", "||" 
		 * @return void
		 */
		GridKit.prototype.setFindRowCondition = function(app, psGridId, psCondition){
			var vcGrid = app.lookup(psGridId);
			vcGrid.dataSet._findRowCondition = psCondition;
		};
		
		/**
		 * 현재 로우의 key(pk) value를 반환한다. 
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @param {Number} pnRowIndex (Optional) 취득하고자하는 row index. <br/>
		 *                 defalut : 선택된 rowindex
		 * @return {String}
		 */
		GridKit.prototype.getRowPKColumnValues = function(app, psGridId, pnRowIndex){
			/** @type cpr.controls.Grid*/
			var vcGrid = app.lookup(psGridId);
			var vcDataSet = vcGrid.dataSet;
			
			var rowIndex = pnRowIndex == null ? this.getIndex(app, psGridId) : pnRowIndex;
			
			var vaPkColmns = ValueUtil.split(vcDataSet.info, ",");
			var vaTempCond = [];
			vaPkColmns.forEach(function(column){
				var vsPkValue = vcDataSet.getValue(rowIndex, column);
				vaTempCond.push(column + "==" + "'" + vcDataSet.getValue(rowIndex, column) + "'"); 
			});
			
			return vaTempCond.length > 0 ? vaTempCond.join(" && ") : "";
		};
		
		/**
		 * 그리드의 선택 유/무 체크 및 PK값이 입려되어 있는지를 체크한다. 
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @param {String | Array} paIgnoreCol PK값 입력 체크 예외 컬럼명
		 * @return {Boolean}
		 */
		GridKit.prototype.checkSelectionWithPkValues = function(app, psGridId, paIgnoreCol){
			/** @type cpr.controls.Grid*/
			var vcGrid = app.lookup(psGridId);
			var rowIndex = this.getIndex(app, vcGrid.id);
			//Row 선택여부 확인
			if(rowIndex < 0){
				this._appKit.Msg.alert("INF-M226", [vcGrid.fieldLabel]); //선택된 데이터가 없습니다.
				return false;
			}
			//ROW의 PK값 입력여부 체크
			var vaPKColumns = ValueUtil.split(ValueUtil.fixNull(vcGrid.dataSet.info), ",");
			var valid = true, text, focusColumn, vbChk = false;
			for(var i=0, len=vaPKColumns.length; i<len; i++){
				if(ValueUtil.isNull(vcGrid.getCellValue(rowIndex, vaPKColumns[i]))){
				    if(!(paIgnoreCol instanceof Array)){
				        paIgnoreCol = [paIgnoreCol];
				    }
				    
				    vbChk = false;
		            paIgnoreCol.some(function(colName){
		                if(colName == vaPKColumns[i]) {
		                	vbChk = true;
		                	return false;
		                }
		            });
		            
		            if(vbChk) continue;
					
					valid = false;
					focusColumn = vaPKColumns[i];
					text = this.getHeaderColumnText(app, vcGrid.id, focusColumn);
					break;
				}
			}
			
			if(!valid){
				//항목은 필수입력 항목입니다.
				this._appKit.Msg.alert("WRN-M001", [vcGrid.fieldLabel+"의 "+text]);
				vcGrid.setEditRowIndex(rowIndex, true);
				vcGrid.focusCell(rowIndex, focusColumn);
				//포커싱할 컬럼이 UDC인 경우에...
				var vaDetailColumns = vcGrid.detail.getColumnByName(focusColumn);
				var dctrl = vaDetailColumns != null && vaDetailColumns.length > 0 ? vaDetailColumns[0].control : null;
				if(dctrl != null && dctrl instanceof cpr.controls.UDCBase){
					var empApp = dctrl.getEmbeddedAppInstance();
					dctrl = AppUtil.getUDCBindValueControl(dctrl);
					if(dctrl) empApp.focus(dctrl.id);
				}
				return false;
			}
			
			return true;
		};
		
		/**
		 * 현재 로우의 key(pk) value를 반환한다. 
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Grid} psGridId 그리드 ID
		 * @param {String} psFileName export 파일명
		 * @param {String} psExcludeColumns (Optional) 출력시 제외할 컬럼명(여러개인 경우 콤마로 구분) ex- COL1,COL2,COL3
		 * @param {String} psFileType (Optional) 파일유형(xls,xlsx,cvs)
		 * @param {Array} metadata
		 * @param {Boolean} pbExcludeHideColumn
		 * @param {String} psExCludePart (Optional) 출력시 제외영역(ex-footer, gfooter)
		 * @return void
		 */
		GridKit.prototype.exportData = function(app, psGridId, psFileName, psExcludeColumns, psFileType, metadata, pbExcludeHideColumn, psExCludePart){
			var _this = this;
			/** @type cpr.controls.Grid */
			var vcGrid = app.lookup(psGridId);
			var vsFileType = !ValueUtil.isNull(psFileType) ? psFileType : "xlsx";
			
			pbExcludeHideColumn = ValueUtil.isNull(pbExcludeHideColumn) ? true : pbExcludeHideColumn;
			
			var subExport = new cpr.protocols.Submission();
			subExport.action = "../export/" + psFileName.replace("\/", "") + "."+vsFileType;
			subExport.mediaType = "application/json";
			subExport.responseType = "blob";
			var voMenuInfo = this._appKit.Auth.getMenuInfo(app);
			if(voMenuInfo != null && voMenuInfo.size() > 0){
				var vsMenuKey = voMenuInfo.get("MENU_ID");
				subExport.addParameter("_AUTH_MENU_KEY", vsMenuKey);
			}
			
			//기본 출력 제외 컬럼(인덱스 컬럼, 선택용 체크 컬럼)
			var voColumn, voHColumn;
			var vaExcludeCellIndexs = [];
			for(var i=0, len=vcGrid.detail.cellCount; i<len; i++){
				voColumn = vcGrid.detail.getColumn(i);
				if(voColumn.columnType == "checkbox" || voColumn.columnType == "rowindex"){
					vaExcludeCellIndexs.push(i);
				}else if(voColumn.control instanceof cpr.controls.UDCBase){
					if(voColumn.control == null || voColumn.control.getBindInfo("value") == null){
						vaExcludeCellIndexs.push(i);
					}
				}
		//		else if(voColumn.columnName == null || voColumn.columnName == ""){
		//			vaExcludeCellIndexs.push(i);
		//		}
				else{
					//숨김컬럼 제외
					if(pbExcludeHideColumn){
						voHColumn = this.getHeaderColumn(app, psGridId, voColumn.columnName);
						if(voHColumn != null && voHColumn.length > 0){
							if(voHColumn[0].visible === false){
								vaExcludeCellIndexs.push(i);
							}
						}
					}
				}
			}
			
			//상태컬럼 제외
			var statusColumn = this.getHeaderStatusColumn(app, vcGrid.id);
			if(statusColumn != null){
				vaExcludeCellIndexs.push(statusColumn.colIndex);
			}
			
			//그외 추가적인 출력 제외 컬럼이 존재하는 경우
			if(!ValueUtil.isNull(psExcludeColumns)){
				var vaExclColumns = ValueUtil.split(psExcludeColumns, ",");
				var vaDColumns;
				for(var j=0, jlen=vaExclColumns.length; j<jlen; j++){
					vaDColumns = vcGrid.detail.getColumnByName(vaExclColumns[j]);
					if(vaDColumns){
						vaDColumns.forEach(function(/* Object */ each){
							vaExcludeCellIndexs.push(each.colIndex);
						});
					}
				}
			}
			
			var exportData = vcGrid.getExportData({exceptStyle:false, freezeHeader:true, excludeCols:vaExcludeCellIndexs});
			if (metadata != null) {
				exportData["metadata"] = {};
				if (metadata["password"] != null) {
					exportData["metadata"]["password"] = metadata["password"];
				}
				if (metadata["printPageOrientation"] != null) {
					exportData["metadata"]["printPageOrientation"] = metadata["printPageOrientation"];
				}
			}
			//풋터 또는 그룹풋터 제외하는 경우
			if(!ValueUtil.isNull(psExCludePart)){
				var len = exportData.rowgroups.length;
				for(var i = (len-1); i >= 0; i--) {
					if (exportData.rowgroups[i].region == psExCludePart) {
						exportData.rowgroups.splice(i,1);
					}
				}
			}
			
			//그리드 출력 스타일지정
			for (var i=0, len=exportData.rowgroups.length; i<len; i++) {
				// band별로 원하는 스타일 추가 가능 (header, detail, footer, gheader, gfooter)
				var rowGroup = exportData.rowgroups[i];
				var cellLength = rowGroup.style.length;
				for (var j = 0; j < cellLength; j++) {
					rowGroup.style[j].style["border-bottom-color"] = "black";
					rowGroup.style[j].style["border-bottom-style"] = "solid";
					rowGroup.style[j].style["border-bottom-width"] = "1px";
					rowGroup.style[j].style["border-left-color"] = "black";
					rowGroup.style[j].style["border-left-style"] = "solid";
					rowGroup.style[j].style["border-left-width"] = "1px";
					rowGroup.style[j].style["border-right-color"] = "black";
					rowGroup.style[j].style["border-right-style"] = "solid";
					rowGroup.style[j].style["border-right-width"] = "1px";
					rowGroup.style[j].style["border-top-color"] = "black";
					rowGroup.style[j].style["border-top-style"] = "solid";
					rowGroup.style[j].style["border-top-width"] = "1px";
					
					if (rowGroup.region == "header") {
						rowGroup.style[j].style["background-color"] = "#dddddd";
						rowGroup.style[j].style["text-align"] = "center";
					}
				}
			}
			
			subExport.setRequestObject(exportData);
		
			subExport.send();
		};
		
		/**
		 * 데이터셋 컨트롤 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function SubmissionKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * Submission Before Handler<br/>
		 * 사이트별 Customizing 필요<br/>
		 *  1. _AUTH_MENU_KEY를 Parameter로 보내는 부분 보완 예정 (uri를 통해 메뉴정보를 취득 할 예정)<br/>
		 *  2. 시스템 컬럼 수정 필요 (CRT_USER_ID, CRT_PGM_ID, CRT_IP_MAC, UPD_USER_ID, UPD_PGM_ID, UPD_IP_MAC)
		 * @param {cpr.events.CSubmissionEvent} e
		 */
		SubmissionKit.prototype._onBeforeSubmit = function(e) {
			/** 
			 * @type cpr.protocols.Submission
			 */
			var submit = e.control;
			var _app = submit.getAppInstance();
			
			//메뉴정보(메뉴키) 추가
			var voMenuInfo = this._appKit.Auth.getMenuInfo(_app);
			if(voMenuInfo != null && voMenuInfo.size() > 0){
				var vsMenuKey = voMenuInfo.get("MENU_ID");
				submit.addParameter("_AUTH_MENU_KEY", vsMenuKey); 
			}
		
			//for.AUTO SAVE
			submit.setDataRowHandler(function(/** @type cpr.data.Row */ rowdata) {
				var additionalValue = {};
				//추가 DB 관리필드 컬럼 추가
				if(rowdata.getState() == cpr.data.tabledata.RowState.INSERTED || cpr.data.tabledata.RowState.UPDATED ||cpr.data.tabledata.RowState.DELETED){
					additionalValue["CRT_USER_ID"] = "";
					additionalValue["CRT_PGM_ID"] = "";
					additionalValue["CRT_IP_MAC"] = "";
					additionalValue["UPD_USER_ID"] = "";
					additionalValue["UPD_PGM_ID"] = "";
					additionalValue["UPD_IP_MAC"] = "";
				}
				
				//PK키 original값 추가
				var dsInfo = rowdata.getDataSetInfo();
				if(dsInfo && (rowdata.getState() == cpr.data.tabledata.RowState.UPDATED || cpr.data.tabledata.RowState.DELETED)){
					var vaPks = dsInfo.split(",");
					vaPks.some(function(value, idx){
						value = value.replace(/(^\s*)|(\s*$)/g, "")
						if(value == "") return false;
						
						additionalValue[value + "__origin"] = rowdata.getOriginalValue(value);
					});
				}else if(dsInfo && (rowdata.getState() == cpr.data.tabledata.RowState.INSERTED)){
					var vaPks = dsInfo.split(",");
					vaPks.some(function(value, idx){
						value = value.replace(/(^\s*)|(\s*$)/g, "")
						if(value == "") return false;
						
						additionalValue[value + "__origin"] = rowdata.getValue(value);
					});
				}
				
				return additionalValue;
			});
		};
		
		/**
		 * @private
		 * Submission Receive Handler<br/>
		 * 사이트별 Customizing 필요<br/>
		 *  - 1. 에러메시지 키 변경 필요
		 * @param {cpr.events.CSubmissionEvent} e
		 * @param {Boolean} pbSuccess
		 */
		SubmissionKit.prototype._onSubmitReceive = function(e, pbSuccess) {
			/** 
			 * @type cpr.protocols.Submission
			 */
			var submission = e.control;
			var xhr = submission.xhr;
			var contentType = xhr.getResponseHeader("Content-Type");
			if(contentType == null) return true;
			
			contentType = contentType.toLowerCase();
			if (contentType.indexOf(";") > -1) {
				contentType = contentType.substring(0, contentType.indexOf(";"));
			}
			contentType = ValueUtil.trim(contentType);
			if ("application/json" != contentType || "text/tab-separated-values" == contentType) {
				return true;
			}
			
			var response = xhr.responseText;
			var jsonRes = JSON.parse(response);
			var errMsgInfo = jsonRes["ERRMSGINFO"];
			if (errMsgInfo) {
				var vsErrMsg = "";
				try{
					vsErrMsg = eval("\"" +  errMsgInfo.ERRMSG+ "\"");	
				}catch(e){
					vsErrMsg = errMsgInfo.ERRMSG;
				}
				
				alert(vsErrMsg.replace(/\r\n/ig, "\n").replace(/\\n/gi, "\n"));
				var urlContext = top.location.pathname.substring(0, top.location.pathname.indexOf("/",2));
				if(urlContext == "/") urlContext = "";
				//사용자 세션없는 오류인 경우
				if("CMN003.CMN@CMN003" == errMsgInfo.ERRCODE){
					top.location.href = urlContext+"/logout.jsp";
				//중복로그인 오류인 경우
				}else if("CMN003.CMN@CMN062" == errMsgInfo.ERRCODE){
					top.location.href = urlContext+"/logout.jsp";
				//수강신청 기간체크 - 재로그인처리
				}else if("CMN003.CMN@CMN063" == errMsgInfo.ERRCODE){
					top.location.href = urlContext+"/logout.jsp";
				}
				return false;
			}
				
			return true;
		};
		
		/**
		 * 
		 * @param {cpr.events.CSubmissionEvent} e
		 */
		SubmissionKit.prototype._onSubmitLoadProgress = function(e) {
			/** 
			 * @type cpr.protocols.Submission
			 */
			var submission = e.control;
			var loadmask = this._getLoadMask(submission);
			if(loadmask){
				try {
					if(submission.getResponseDataCount() > 0){
						var rowCnt = submission.getResponseData(0).data.getRowCount();
						loadmask.module.count(rowCnt);
					}
				}catch(ex){}
			}
		};
		
		/**
		 * 
		 * @param {cpr.events.CSubmissionEvent} e
		 * @param {Boolean} pbSuccess
		 */
		SubmissionKit.prototype._onSubmitSuccess = function(e, pbSuccess) {
			return pbSuccess;
		};
		
		/**
		 * @private
		 * Submission Error Handler
		 * @param {cpr.events.CSubmissionEvent} e
		 */
		SubmissionKit.prototype._onSubmitError = function(e) {
			/** 
			 * @type cpr.protocols.Submission
			 */
			var submission = e.control;
			var _app = submission.getAppInstance();
			//시스템 내부 장애가 발생하였습니다.\n 관리자에게 문의 하시기 바랍니다.
			this._appKit.Msg.alert("ERR-SRV");
			
			var msg = submission.getMetadata("msg");
			if(msg) {
				this._appKit.Msg.notify(_app, msg);
			} else if(e.nativeEvent) {
				this._appKit.Msg.notify(_app, "network : " + e.nativeEvent.type);
			}
			
			return false;
		};
		
		/**
		 * @private
		 * Submission Done Handler<br/>
		 * 1. 서버에서 생성된 최신 로우 찾기<br/>
		 * 2. 어플리케이션 비즈니스 콜백 메소드 실행<br/>
		 * 3. 로딩 마스크 제거<br/>
		 * @param {cpr.events.CSubmissionEvent} e
		 * @param {Function} poCallbackFunc
		 * @param {Boolean} pbSuccess
		 * @param {Boolean} pbAppDisable
		 */
		SubmissionKit.prototype._onSubmitDone = function(e, poCallbackFunc, pbSuccess, pbAppDisable) {
			/** 
			 * @type cpr.protocols.Submission
			 */
			var submission = e.control;
			var _app = submission.getAppInstance();
			
			//마지막 행찾기
			var vsFindRowKey = submission.getMetadata("strFindRowKey");
			if(!ValueUtil.isNull(vsFindRowKey)){
				var vnDsCnt = submission.getRequestDataCount();
				var voDs, vaFindKey;
				var vaFindRowKeys = ValueUtil.split(vsFindRowKey, "|");
				var findKey = null;
				for(var i=0, len=vaFindRowKeys.length; i<len; i++){
					findKey = ValueUtil.trim(vaFindRowKeys[i]);
					if(findKey == "") continue;
					vaFindKey = ValueUtil.split(findKey, ":");
					if(vaFindKey.length == 2){
						for(var j=0; j<vnDsCnt; j++){
							voDs = submission.getRequestData(j).data;
							if(voDs.type != "dataset") continue;
							if(voDs.id == vaFindKey[0]){
								voDs._findRowCondition = vaFindKey[1];
								break;
							}
						}
					}else{
						for(var j=0; j<vnDsCnt; j++){
							voDs = submission.getRequestData(j).data;
							if(voDs.type != "dataset") continue;
							voDs._findRowCondition = vaFindKey[0];
						}
					}
				}
			}
			
			var idx = this._appKit._activeSubmission.indexOf(submission);
			if(idx != -1) {
				this._appKit._activeSubmission.splice(idx, 1);
			}
			
			//실패한 경우.. 커버를 씌움
			if(pbAppDisable === true && pbSuccess != true){
				this._appKit.coverPage(_app);
			}
			
			submission.removeAllFileParameters();
			submission.removeAllParameters();
			submission.removeAllEventListeners();
		
			//콜백이 존재하는 경우... 콜백함수 호출	
			//콜백을 제일 뒤로 옮김
			if (poCallbackFunc != null && (typeof poCallbackFunc == "function")) {
				poCallbackFunc(pbSuccess, e.control);
			}
			
			// submission success에서 다른 submission을 실행했을 경우 loadmask를 내리지 않는다.
			if(this._appKit._activeSubmission.length == 0) {
				// hide loadmask
				try{
					this._appKit.hideLoadMask(_app);
				}catch(ex){}
			}
		};
		
		/**
		 * @param {cpr.protocols.Submission} poSubmission
		 */
		SubmissionKit.prototype._getLoadMask = function(poSubmission) {
			var _app = poSubmission.getAppInstance();
			var _container = null;
			if(_app.getHost() && _app.getHost().modal === true){
				_container = _app.getContainer();
			}else{
				_container = _app.getRootAppInstance().getContainer();
			}
			_app = _container.getAppInstance();
			
			return _app.lookup("__loadmask__");
		};
		
		/**
		 * 해당 서브미션 요청 데이터를 가지고 있는지 체크
		 * @private
		 * @param {cpr.protocols.Submission} poSubmission - 서브미션 객체
		 * @param {String} psDataId - 데이터셋/맵 ID
		 */
		SubmissionKit.prototype._hasRequestData = function(poSubmission, psDataId){
			for(var i=0, len=poSubmission.getRequestDataCount(); i<len; i++){
				if(poSubmission.getRequestData(i).data.id == psDataId){
					return true;
				}
			}
			return false;
		}
		
		/**
		 * 해당 서브미션 요청 데이터를 가지고 있는지 체크
		 * @private
		 * @param {cpr.protocols.Submission} poSubmission - 서브미션 객체
		 * @param {String} psDataId - 데이터셋/맵 ID
		 */
		SubmissionKit.prototype._hasResponseData = function(poSubmission, psDataId){
			for(var i=0, len=poSubmission.getResponseDataCount(); i<len; i++){
				if(poSubmission.getResponseData(i).data.id == psDataId){
					return true;
				}
			}
			return false;
		}
		
		/**
		 * 전송시 추가로 전달되는 파라미터를 추가합니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Submission} psSubmissionId 서브미션 ID
		 * @param {String} psParamName 파라미터의 이름
		 * @param {String} psValue 파라미터의 값
		 * @return void
		 */
		SubmissionKit.prototype.addParameter = function(app, psSubmissionId, psParamName, psValue){
			/** @type cpr.protocols.Submission */
			var vcSubmission = app.lookup(psSubmissionId);
			vcSubmission.addParameter(psParamName, psValue);
		};
		
		/**
		 * 전송시 추가로 전달되는 파라미터를 추가합니다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Submission} psSubmissionId 서브미션 ID
		 * @param {String} name 파라미터의 이름
		 * @param {String} value 파라미터의 값
		 * @return void
		 */
		SubmissionKit.prototype.addFileParameter = function(app, psSubmissionId, paFiles){
			/** @type cpr.protocols.Submission */
			var vcSubmission = app.lookup(psSubmissionId);
			if(paFiles == null) return;
			if(paFiles instanceof Array){
				paFiles.forEach(function(voFile){
					vcSubmission.addFileParameter("exb.fileupload.filelist", voFile);
				});
			}else{
				vcSubmission.addFileParameter("exb.fileupload.filelist", paFiles);
			}
		};
		
		/**
		 * 서브미션 호출<br/>
		 * - 사이트별 Customizing 필요<br/>
		 * 1. 공통 코드, 현재일자 서브미션 가능 (옵션)<br/>
		 *  - CRUD용 파라메터, 코드조회용 파라메터, 현재일자조회 파라메터 (개발가이드 2.24	공통 서브미션 호출 서비스 참고)
		 * 2. 서브미션에 before-submit,  receive, submit-error, submit-success, submit-done 이벤트 부여
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#Submission} 	 psSvcId 서브미션 ID
		 * @param {Array} paParams
		 * @param {Function} successCallback 서브미션 후 콜백 메소드
		 * @param {Boolean}  pbAppEnable (Optional) 서브미션 오류 및 exception 발생시 커버페이지를 쒸움
		 * @param {Boolean}  pbAsync (Optional) 공통서브미션 호출시 비동기 호출여부(디폴트 비동기)
		 * @param {String} maskType
		 */
		SubmissionKit.prototype.send = function(app, psSvcId, paParams, successCallback, pbAppEnable, pbAsync, maskType){
			var _app = app;
		
			var submission = _app.lookup(psSvcId);
			if(submission == null || !(submission instanceof cpr.protocols.Submission)){
				//요청 서브미션
				submission = _app.lookup("subCommExbuilder_"+psSvcId);
				if(submission == null){
					submission 				= new cpr.protocols.Submission("subCommExbuilder_"+psSvcId);
					submission.action 		= "../CommSubmit/egovXbuilder.do";
					submission.async		= (pbAsync != "undefined" && pbAsync != null) ? pbAsync : true;
					submission.mediaType 	= "application/x-www-form-urlencoded";
					submission.method 		= "post";
					submission.responseType = "text";
					_app.register(submission);
				}
				
				if(!(paParams instanceof Array)){
					paParams = [paParams];
				}
				if(paParams.length > 0){
					submission.removeAllRequestData();
					submission.removeAllResponseData();
					
					var dsReqParam = _app.lookup("dsCommExbuilderParam"); //CRUD용 파라메터
					if(dsReqParam == null){
						dsReqParam = new cpr.data.DataSet("dsCommExbuilderParam");
						dsReqParam.addColumn(new cpr.data.header.DataHeader("MAPPER", "string"));
						dsReqParam.addColumn(new cpr.data.header.DataHeader("QRY", "string"));
						dsReqParam.addColumn(new cpr.data.header.DataHeader("TYPE", "string"));
						dsReqParam.addColumn(new cpr.data.header.DataHeader("IN_DS", "string"));
						dsReqParam.addColumn(new cpr.data.header.DataHeader("OUT_DS", "string"));
						dsReqParam.addColumn(new cpr.data.header.DataHeader("OUT_DS_TYPE", "string"));
						dsReqParam.addColumn(new cpr.data.header.DataHeader("REQ_PARAM", "string"));
						_app.register(dsReqParam);
					}else{
						dsReqParam.clear();
					}
					
					var dsReqCodeParam = _app.lookup("dsCommExbuilderCodeParam"); //코드조회용 파라메터
					if(dsReqCodeParam == null){
						dsReqCodeParam = new cpr.data.DataSet("dsCommExbuilderCodeParam");
						dsReqCodeParam.addColumn(new cpr.data.header.DataHeader("CODE", "string"));
						dsReqCodeParam.addColumn(new cpr.data.header.DataHeader("CD", "string"));
						dsReqCodeParam.addColumn(new cpr.data.header.DataHeader("USE_YN", "string"));
						dsReqCodeParam.addColumn(new cpr.data.header.DataHeader("AUTH_YN", "string"));
						dsReqCodeParam.addColumn(new cpr.data.header.DataHeader("OUT_DS", "string"));
						dsReqCodeParam.addColumn(new cpr.data.header.DataHeader("OUT_DS_TYPE", "string"));
						_app.register(dsReqCodeParam);
					}else{
						dsReqCodeParam.clear();
					}
					var dmReqTimeParam = _app.lookup("dmCommExbuilderTimeParam"); //현재일자조회 파라메터
					if(dmReqTimeParam == null){
						dmReqTimeParam = new cpr.data.DataMap("dmCommExbuilderTimeParam");
						dmReqTimeParam.addColumn(new cpr.data.header.DataHeader("NODE", "string"));
						dmReqTimeParam.addColumn(new cpr.data.header.DataHeader("FORMAT", "string"));
						dmReqTimeParam.addColumn(new cpr.data.header.DataHeader("OUT_DS", "string"));
						dmReqTimeParam.addColumn(new cpr.data.header.DataHeader("OUT_DS_TYPE", "string"));
						_app.register(dmReqTimeParam);
					}else{
						dmReqTimeParam.clear();
					}
					
					var voParam = null;
					for(var i=0, len=paParams.length; i<len; i++){
						voParam = paParams[i];
						if(!ValueUtil.isNull(voParam["mapper"]) && !ValueUtil.isNull(voParam["qry"])){
							var in_dataset = [];
							var out_dataset = [];
							//요청 데이터셋 셋팅
							if(!ValueUtil.isNull(voParam["inds"])){
								var vaInDs = ValueUtil.split(voParam["inds"], ",");
								for(var k=0, klen=vaInDs.length; k<klen; k++){
									var vaInDsInfo = ValueUtil.split(ValueUtil.fixNull(vaInDs[k]), ":");
									var voInDs = _app.lookup(vaInDsInfo[0]);
									if(voInDs && !this._hasRequestData(submission, voInDs.id)){
										in_dataset.push(voInDs.id);
										if(vaInDsInfo.length == 2){
											submission.addRequestData(voInDs, "", vaInDsInfo[1]);
										}else{
											submission.addRequestData(voInDs, "");
										}
									}
								}
							}
							//응답 데이터셋 셋팅
							if(!ValueUtil.isNull(voParam["outds"])){
								var vaOutDs = ValueUtil.split(voParam["outds"], ",");
								for(var k=0, klen=vaOutDs.length; k<klen; k++){
									var vaOutDsInfo = ValueUtil.split(ValueUtil.fixNull(vaOutDs[k]), ":");
									var voOutDs = _app.lookup(vaOutDsInfo[0]);
									if(!this._hasResponseData(submission, voOutDs.id)){
										out_dataset.push(voOutDs.id);
										if(vaOutDsInfo.length == 2){
											submission.addResponseData(voOutDs, ValueUtil.fixBoolean(vaOutDsInfo[1]));
										}else{
											submission.addResponseData(voOutDs, false);
										}
									}
								}
							}
				
							if(!(voParam["qry"] instanceof Array)){
								voParam["qry"] = [voParam["qry"]];
							}
							for(var j=0, jlen=voParam["qry"].length; j<jlen; j++){
								var vaDsInfo = ValueUtil.split(voParam["qry"][j], ":");
								var vaSqlIds = ValueUtil.split(vaDsInfo[0], ",");
								var vsDsId = ValueUtil.trim(vaDsInfo[1]);
								var vsOutDsType = "";
								
								var vsInDsId = "";
								var vsOutDsId = "";
								for(var k=0, klen=vaSqlIds.length; k<klen; k++){
									vsInDsId = "", vsOutDsId = "", vsOutDsType = "";
									for(var z=0, zlen=in_dataset.length; z<zlen; z++){
										if(vsDsId == in_dataset[z]){
											vsInDsId = in_dataset[z];
											break;
										}
									}
									for(var z=0, zlen=out_dataset.length; z<zlen; z++){
										if(vsDsId == out_dataset[z]){
											vsOutDsId = out_dataset[z];
											break;
										}
									}
									
									vsOutDsType = (_app.lookup(vsOutDsId) instanceof cpr.data.DataSet ? "ds" : "dm")
									dsReqParam.addRowData({"MAPPER":voParam["mapper"], "QRY":ValueUtil.trim(vaSqlIds[k]), "TYPE":(!ValueUtil.isNull(voParam["type"]) ? voParam["type"] : "R"), "IN_DS":vsInDsId, "OUT_DS":vsOutDsId, "REQ_PARAM":voParam["param"], "OUT_DS_TYPE":vsOutDsType});
								}
							}
							var voParamDs = _app.lookup(voParam["param"]);
							if(voParamDs && !this._hasRequestData(submission, voParamDs.id)){
								submission.addRequestData(voParamDs, "", "all");
							}
						}else if(!ValueUtil.isNull(voParam["stime"])){
							var vsTimeOutDsName = voParam["stime"][0];
							var voOutDs = _app.lookup(vsTimeOutDsName);
							if(voOutDs == null) continue;
							//응답 데이터셋 셋팅
							if(!this._hasResponseData(submission, voOutDs.id)){
								submission.addResponseData(voOutDs, false);
							}
							dmReqTimeParam.setValue("NODE", voParam["stime"][1]);
							dmReqTimeParam.setValue("OUT_DS", voParam["stime"][0]);
							dmReqTimeParam.setValue("FORMAT", voParam["stime"][2]);
							dmReqTimeParam.setValue("OUT_DS_TYPE", (voOutDs instanceof cpr.data.DataSet ? "ds" : "dm"));
						}else{
							var vsCodeOutDsName = voParam[0];
							var voOutDs = _app.lookup(vsCodeOutDsName);
							if(voOutDs == null) continue;
							//응답 데이터셋 셋팅
							if(!this._hasResponseData(submission, voOutDs.id)){
								submission.addResponseData(voOutDs, false);
							}
							dsReqCodeParam.addRowData({"CODE":voParam[1], "CD":voParam[2], "USE_YN":voParam[3], "AUTH_YN":voParam[4], "OUT_DS":voParam[0], "OUT_DS_TYPE":(voOutDs instanceof cpr.data.DataSet ? "ds" : "dm")});
						}
					}
					//요청 파라메터 셋팅
					dsReqParam.setRowStateAll(cpr.data.tabledata.RowState.UNCHANGED);
					dsReqCodeParam.setRowStateAll(cpr.data.tabledata.RowState.UNCHANGED);
					submission.addRequestData(dsReqParam, "", "all");
					submission.addRequestData(dsReqCodeParam, "", "all");
					submission.addRequestData(dmReqTimeParam, "", "");
				}
			}
			
			if(!submission || submission.status == "SENDING") return;
		//	if(!submission) return;
			
			//context-path를 고려하여, action URL이 ../로 시작하도록 변경
			if(submission.action.indexOf("/") == 0){
				submission.action = ".."+submission.action;
			}
			
			//어플리케이션 전체에 마스크(Mask)를 씌운다.
			this._appKit.showLoadMask(app, maskType);
			
			if(submission.userAttr("responseType") === "TSV"){
				var loadmask = this._getLoadMask(submission);
				if(loadmask && loadmask.module.count){
					loadmask.module.count(0);
					loadmask.module.show();
				}
			}
			
			var vbSuccess = true;
			var _this = this;
			submission.addEventListenerOnce("before-submit", function(e){
				_this._onBeforeSubmit(e);
			});
			
			if(submission.userAttr("responseType") === "TSV"){
				submission.addEventListener("submit-load-progress", function(e){
					_this._onSubmitLoadProgress(e);
				}); 
			}
			
			submission.addEventListenerOnce("receive", function(e){
				vbSuccess = _this._onSubmitReceive(e);
			}); 
					
			submission.addEventListenerOnce("submit-error", function(e){
				vbSuccess = _this._onSubmitError(e);
			}); 
					
			submission.addEventListenerOnce("submit-success", function(e){
				vbSuccess = _this._onSubmitSuccess(e, vbSuccess);
			});
			
			submission.addEventListenerOnce("submit-done", function(e) {
				_this._onSubmitDone(e, successCallback, vbSuccess, pbAppEnable);
			});
			
			this._appKit._activeSubmission[this._appKit._activeSubmission.length] = submission;
			submission.send();
		};
		
		
		/**
		 * HeaderKit(헤더) 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function HeaderKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 지정한 컨트롤의 Enable 속성을 설정한다.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {Boolean} pbEnable 컨트롤 활성화 여부(true/false)
		 * @param {String | Array} paCtlId 배열 [I:신규, D:삭제, S:저장, 미지정 : 전체]
		 * @return void
		 */
		HeaderKit.prototype.setEnable = function(app, pbEnable, paCtlId) {
			if(!(paCtlId instanceof Array)){
				paCtlId = [paCtlId];
			}
			if (typeof (pbEnable) != "boolean") {
				pbEnable = ValueUtil.fixBoolean(pbEnable);
			}
			
			var appHeader = this._appKit.Group.getAllChildrenByType(app, "udc.com.appHeader");
			for (var i=0, len=appHeader.length; i<len; i++) {	
				var ctrl = appHeader[i];
				ctrl.setEnableCtrls(pbEnable, paCtlId);
			}
		};
		
		/**
		 * 헤더에 있는 컨트롤의 이벤트를 발생시킨다.
		 * - 사이트별 Customizing 필요
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 컨트롤의 아이디
		 * @param {String} psEventType 이벤트명(ex-click)
		 */
		HeaderKit.prototype.dispatchEvent = function(app, psCtlId, psEventType){
			var header = this._appKit.Group.getAllChildrenByType(app, "udc.com.appHeader");
			if(header != null && header.length > 0){
				var vcCtrl = header[0].getEmbeddedAppInstance().lookup(psCtlId);
				if(vcCtrl){
					vcCtrl.dispatchEvent(new cpr.events.CEvent(psEventType));
				}
			}
		};
		
		
		/**
		 * ComUdcBtnKit(공통, 버튼) 유틸
		 * @constructor
		 * @param {common.AppKit} appKit
		 */
		function ComUdcBtnKit(appKit){
			this._appKit = appKit;
		};
		
		/**
		 * 지정한 컨트롤의 Enable 속성을 설정한다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {Boolean} pbEnable 컨트롤 활성화 여부(true/false)
		 * @param {String | Array} paCtlId 배열 [I:신규, D:삭제, S:저장, 미지정 : 전체]
		 * @return void
		 */
		ComUdcBtnKit.prototype.setEnable = function(app, pbEnable, paCtlId) {
			if(!(paCtlId instanceof Array)){
				paCtlId = [paCtlId];
			}
			if (typeof (pbEnable) != "boolean") {
				pbEnable = ValueUtil.fixBoolean(pbEnable);
			}
			
			var comButton = this._appKit.Group.getAllChildrenByType(app, "udc.com.comButton");
			for (var i=0, len=comButton.length; i<len; i++) {	
				var ctrl = comButton[i];
				ctrl.setEnableCtrls(pbEnable, paCtlId);
			}
		};
		
		/**
		 * 공통 버튼 UDC 있는 컨트롤의 이벤트를 발생시킨다.
		 * @param {cpr.core.AppInstance} app 앱인스턴스
		 * @param {#uicontrol} psCtlId 컨트롤의 아이디
		 * @param {String} psEventType 이벤트명(ex-click)
		 */
		ComUdcBtnKit.prototype.dispatchEvent = function(app, psCtlId, psEventType){
			
			var comUdc;
			
			if(psCtlId == "btnSearch"){
				comUdc = this._appKit.Group.getAllChildrenByType(app, "udc.com.comBtnSearch");
			}else{
				comUdc = this._appKit.Group.getAllChildrenByType(app, "udc.com.comButton");
			}
			
			if(comUdc != null && comUdc.length > 0){
				var vcCtrl = comUdc[0].getEmbeddedAppInstance().lookup(psCtlId);
				if(vcCtrl){
					vcCtrl.dispatchEvent(new cpr.events.CEvent(psEventType));
				}
			}
		};
		
		
		exports.MsgKit = MsgKit;
		exports.DialogKit = DialogKit;
		exports.GroupKit = GroupKit;
		exports.FreeFormKit = FreeFormKit;
		exports.SelectKit = SelectKit;
		exports.TreeKit = TreeKit;
		exports.TabKit = TabKit;
		exports.EmbeddedAppKit = EmbeddedAppKit;
		exports.MDIKit = MDIKit;
		exports.ControlKit = ControlKit;
		exports.DataSetKit = DataSetKit;
		exports.DataMapKit = DataMapKit;
		exports.GridKit = GridKit;
		exports.SubmissionKit = SubmissionKit;
		exports.HeaderKit = HeaderKit;
		exports.ComUdcBtnKit = ComUdcBtnKit;
	});
})();
/// end - module/extension
/// start - module/focuser
/*
 * Module URI: module/focuser
 * SRC: module/focuser.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/focuser", function(exports, globals, module){
		/************************************************
		 * focuser.module.js
		 * Created at 2021. 4. 8. 오후 4:59:06.
		 *
		 * @author HANS
		 ************************************************/
		
		var userAttrNm1 = "inputType";
		var userAttrNm2 = "moveTarget"
		
		cpr.events.EventBus.INSTANCE.addFilter("focus", function(e) {
			var control = e.control;
			
			if(control instanceof cpr.controls.InputBox) {
				
				var vsUserAtt = control.userAttr(userAttrNm1);
				
				if(vsUserAtt != "") {
					
					if(vsUserAtt == "keyboard") {
						
						var rootApp = control.getAppInstance().getRootAppInstance();
						var controlRect = control.getActualRect();
						rootApp.openDialog("202104/keyboard", {width : 600, height : 300,top:controlRect.bottom,left:controlRect.bottomLeft.x}, function(dialog){
							dialog.headerVisible = false;
							dialog.ready(function(dialogApp){
								dialogApp.setAppProperty("targetCtrl", control);
								// 필요한 경우, 다이얼로그의 앱이 초기화 된 후, 앱 속성을 전달하십시오.
							});
						}).then(function(returnValue){
							;
						});
					} else if(vsUserAtt == "popup") {
						
						var popID = userAttrNm2;
						
						rootApp.openDialog(popID, {width : 500, height : 500}, function(dialog){
							dialog.ready(function(dialogApp){
								// 필요한 경우, 다이얼로그의 앱이 초기화 된 후, 앱 속성을 전달하십시오.
							});
						}).then(function(returnValue){
							if(returnValue) {
								control.value = returnValue;
							}
						});
					}
				}
			}
		});
	});
})();
/// end - module/focuser
/// start - module/mobileGenerator
/*
 * Module URI: module/mobileGenerator
 * SRC: module/mobileGenerator.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/mobileGenerator", function(exports, globals, module){
		///************************************************
		// * mobileGenerator.module.js
		// * Created at 2021. 1. 5. 오전 10:14:17.
		// *
		// * @author HANS
		// ************************************************/
		//
		//
		//cpr.events.EventBus.INSTANCE.addFilter("init", function(e){
		//	var control = e.control;
		//	
		//	if(control instanceof cpr.core.AppInstance) {
		//		
		//		
		//		var a = control.getContainer();
		//		
		//		var b = a.getAllRecursiveChildren();
		//		
		//		var comboArr = b.filter(function(each){
		//			
		//			return each instanceof cpr.controls.ComboBox
		//		});
		//		var dt = b.filter(function(each){
		//			return each instanceof cpr.controls.DateInput;
		//		});
		//		dt.forEach(function(each){
		//			/** @type cpr.controls.DateInput */
		//			var combo = each;
		//			
		//			var parent = combo.getParent();
		//			
		//			var rect = parent.getConstraint(combo);
		//			
		//			var sheCmb = new udc.han.DateInput();
		//			
		//			if(parent.getLayout() instanceof cpr.controls.layouts.VerticalLayout) {
		//				
		//				var children = parent.getChildren();
		//				var idx = children.indexOf(combo);
		//				console.log(idx);
		//				parent.addChild(sheCmb, rect);
		//				parent.reorderChild(sheCmb, idx);
		//				
		//			} else {
		//				
		//				parent.addChild(sheCmb, rect);
		//			}
		//			
		//			combo.dispose();
		//		});
		//		comboArr.forEach(function(each){
		//			/** @type cpr.controls.ComboBox */
		//			var combo = each;
		//			
		//			var parent = combo.getParent();
		//			
		//			var rect = parent.getConstraint(combo);
		//			var ds = combo.dataSet;
		//			var itemSet = combo.itemSetConfig;
		//			
		//			var sheCmb = new udc.han.cmb();
		//			sheCmb.targetDs = ds;
		//			sheCmb.labelC = itemSet.label;
		//			sheCmb.valueC = itemSet.value;
		//			
		//			if(parent.getLayout() instanceof cpr.controls.layouts.VerticalLayout) {
		//				
		//				var children = parent.getChildren();
		//				var idx = children.indexOf(combo);
		//				console.log(idx);
		//				parent.addChild(sheCmb, rect);
		//				parent.reorderChild(sheCmb, idx);
		//				
		//			} else {
		//				
		//				parent.addChild(sheCmb, rect);
		//			}
		//			
		//			combo.dispose();
		//		});
		//	}
		//});
	});
})();
/// end - module/mobileGenerator
/// start - module/testerModule
/*
 * Module URI: module/testerModule
 * SRC: module/testerModule.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/testerModule", function(exports, globals, module){
		/************************************************
		 * testerModule.module.js
		 * Created at 2020. 12. 17. 오전 10:53:41.
		 *
		 * @author HANS
		 ************************************************/
		
	});
})();
/// end - module/testerModule
/// start - module/validation
/*
 * Module URI: module/validation
 * SRC: module/validation.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("module/validation", function(exports, globals, module){
		
		//exports.id = "validation.module.js";
		
		// 의존 모듈 선언.
		module.depends("module/common");
		
		/**
		 * 공통 Validator Class
		 */
		Validator = function(appKit) {
			/** @type AppKit */
			this._appKit = appKit;
		};
		
		/**
		 * 해당 값이 'E-mail' 유형인지 여부를 반환한다.
		 * @param {String} value - 값  문자열
		 * @return {Boolean} true/false
		 */
		Validator.prototype.isEmail = function(value){
			if(!value) return true;
			
			if(/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/.test(value)) {
				return true;
			}
			
			return false;
		}
		
		/**
		 * 해당 값이 'URL' 형식에 맞는 문자열인지 여부를 반환한다.
		 * @param {String} value - 값  문자열
		 * @return {Boolean} true/false
		 */
		Validator.prototype.isURL = function(value){
			if(!value) return true;
			
			// w3resource.com
			var regexp = /^(?:(?:https?|ftp):\/\/)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/\S*)?$/;
			if(regexp.test(value)) {
				return true;
			}
			
			return false;
		}
		
		/**
		 * 해당 값이 '사업자 번호' 형식에 맞는 문자열인지 여부를 반환한다.
		 * @param {String} value - 값  문자열
		 * @return {Boolean} true/false
		 */
		Validator.prototype.isBizCSN = function(value){
			if(!value) return true;
			
			// 넘어온 값의 정수만 추츨하여 문자열의 배열로 만들고 10자리 숫자인지 확인합니다.
			if ((value = (value + '').match(/\d{1}/g)).length != 10) {
				return false;
			}
		
			// 합 / 체크키
			var sum = 0, key = [1, 3, 7, 1, 3, 7, 1, 3, 5];
		
			// 0 ~ 8 까지 9개의 숫자를 체크키와 곱하여 합에 더합니다.
			for (var i = 0 ; i < 9 ; i++) { sum += (key[i] * Number(value[i])); }
		
			// 각 8번배열의 값을 곱한 후 10으로 나누고 내림하여 기존 합에 더합니다.
			// 다시 10의 나머지를 구한후 그 값을 10에서 빼면 이것이 검증번호 이며 기존 검증번호와 비교하면됩니다.
			return (10 - ((sum + Math.floor(key[8] * Number(value[8]) / 10)) % 10)) == Number(value[9]);
		}
		
		/**
		 * 해당 값이 '주민등록번호' 형식에 맞는지 여부를 반환한다.
		 * 주민등록번호 체크 (전자정부프레임워크 : http://www.egovframe.go.kr/wiki/doku.php?id=egovframework:rte:ptl:validation:add_rules_in_commons_validator)
		 * @param {String} value - 값  문자열
		 * @return {Boolean} true/false
		 */
		Validator.prototype.isSSN = function(value){
			if(!value) return true;
			value = value.replace(/[\-]/g, "");
			
			
			var fmt = /^\d{6}[1234]\d{6}$/;
			if(!fmt.test(value)){
				return false;
			}
		
			var birthYear = (value.charAt(7) <= "2") ? "19" : "20";
			birthYear += value.substr(0, 2);
			var birthMonth = value.substr(2, 2) - 1;
			var birthDate = value.substr(4, 2);
			var birth = new Date(birthYear, birthMonth, birthDate);
		
			if( birth.getYear() % 100 != value.substr(0, 2) ||
			    birth.getMonth() != birthMonth ||
			    birth.getDate() != birthDate) {
			    return false;
			}
		
			var arrDivide = [2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5];            	
			var checkdigit = 0;            	
			for(var i = 0; i < value.length - 1; i++) {
				checkdigit += parseInt(value.charAt(i)) * parseInt(arrDivide[i]);
			}
			checkdigit = (11 - (checkdigit % 11)) % 10;
			if(checkdigit != value.charAt(12)){
				return false;
			} else {
				return true;
			}
		}
		
		/**
		 * 해당 값이 일반 '전화번호' 형식에 맞는 문자열인지 여부를 반환한다.
		 * @param {String} value - 값  문자열
		 * @return {Boolean} true/false
		 */
		Validator.prototype.isTelNo = function(value){
			if(!value) return true;
			if(/^\d{2,3}[\)\-\. ]?\d{3,4}[\-\. ]?\d{4}$/.test(value)){
				return true;
			}
			
			return false;
		}
		
		/**
		 * 해당 값이 '핸드폰번호' 형식에 맞는 문자열인지 여부를 반환한다.
		 * @param {String} value - 값  문자열
		 * @return {Boolean} true/false
		 */
		Validator.prototype.isTelMobile = function(value){
			if(!value) return true;
			if(/^01([0|1|6|7|8|9]?)[\-\. ]?([0-9]{3,4})[\-\. ]?([0-9]{4})$/.test(value)) {
				return true;
			}
			
			return false;
		}
		
		/**
		 * 해당 값이 'function' 유형인지 여부를 반환한다.
		 * @param {Function} poFunc  
		 * @return {Boolean} true/false
		 */
		Validator.prototype.isFunc = function(poFunc){
			if (poFunc != null && (typeof poFunc == "function")) {
				return true;
			}else return false;
		}
		
		/**
		 * 
		 * @param {cpr.controls.UIControl} ctrl
		 * @param {String} ctrlValue
		 * @param {cpr.controls.UIControl} poParentCtl
		 * @param {Number} pnIdx
		 * @param {Number} pnCellIdx
		 */
		Validator.prototype.validate = function(ctrl, ctrlValue, poParentCtl, pnIdx, pnCellIdx, poRow, poMstCtrl) {
			if(!ctrl) return true;
			if(ctrl.type == "output" || ctrl.type == "img" || ctrl.type == "button") return true;
			
			//바인딩 및 헤더컬럼으로 수정 필요
			var vsFieldLabel = ctrl.fieldLabel;
			if(ValueUtil.isNull(vsFieldLabel) && ctrl.getHost){
				vsFieldLabel = ctrl.getHost().fieldLabel;
			}
			function getGridFieldLabel(poParentCtl, psFieldLabel){
		//		if(poParentCtl instanceof cpr.controls.Grid && ValueUtil.isNull(psFieldLabel)){
				if(poParentCtl instanceof cpr.controls.Grid){
					var vcDetailCtl = poParentCtl.detail.getColumn(pnCellIdx);
					var vaHeaderCtl = poParentCtl.header.getColumnByColIndex(vcDetailCtl.colIndex, vcDetailCtl.colSpan);
					if(vaHeaderCtl.length > 0){
						var vcHeaderCtl = vaHeaderCtl[0];
						if(vcHeaderCtl){
							psFieldLabel = vcHeaderCtl.getText();
						}
					}
				}
				return psFieldLabel;
			}
			
			var _appKit = this._appKit;
			function parentValidMsg(psMsg, poParentCtl, pnIdx){
				//그리드 내 컨트롤
				if(poParentCtl instanceof cpr.controls.Grid){
					var vsMsg = "";
					var vsDsRefKey = "EX6_REF_KEY_";
					vsMsg = "";
					vsMsg = _appKit.Msg.getMsg("WRN-M002", [poParentCtl.fieldLabel, Number(pnIdx)+1]);
					psMsg = vsMsg + " " + psMsg;
				}
				_appKit.Msg.alert(psMsg, "WARNING");
			}
			
			// 필수 입력 체크
			{
				var notnull = "";
				if(poParentCtl instanceof cpr.controls.Grid && ctrl instanceof cpr.controls.UDCBase){
					notnull = ctrl.getAppProperty("required") === true || ctrl.getAppProperty("required") === "Y" ? "Y" : "";
				}else{
					notnull = ctrl.userAttr("required");
				}
				if(notnull === "Y") {
					if(ctrlValue == null || new String(ctrlValue) == "") {
						vsFieldLabel = getGridFieldLabel(poParentCtl, vsFieldLabel);
						//{0}은(는) 필수 입력 항목입니다.
						var vsMsg = this._appKit.Msg.getMsg("WRN-M001", [vsFieldLabel]);
						parentValidMsg(vsMsg, poParentCtl, pnIdx);
						
						return false;
					}
				}
			}
			
			
			
			// 지정된 컬럼중 하나 이상 필수 입력 체크
			// 그리드일경우 columnname, 그룹 및 일반컨트롤일 경우 id
			{
				var xorNull = ctrl.userAttr("xorRequired");
				if(xorNull) {
					var vaXorNull = ValueUtil.split(xorNull.replace(/\[|\]/g,""), ",");
					var vsName = "";
					//그리드 내 컨트롤
					
					var vbStatus = false;
					if(poParentCtl instanceof cpr.controls.Grid){
						for (var j = 0; j < vaXorNull.length; j++) {
							var vsValue = poRow != null ? poRow.getValue(vaXorNull[j]) : poParentCtl.getCellValue(pnIdx, vaXorNull[j]);
							if(!ValueUtil.isNull(vsValue)){
								vbStatus = true;
								break;
							}
							var vaDetailCell = poParentCtl.detail.getColumnByName(vaXorNull[j]);
							vaDetailCell.some(function(vcCell){
								var vcHeaderCtl = poParentCtl.header.getColumn(vcCell.colIndex).control;
								if(vcHeaderCtl)
									vsName += vcHeaderCtl.getText() + " ,";
								//vsName += vcCell.control.userattr("name") + " ,";
							});
						}
						if(!vbStatus){
							//{0}중 하나는 필수 입력 항목입니다.
							var vsMsg = this._appKit.Msg.getMsg("WRN-M003", [vsName.substring(0, vsName.length -1)]);
							parentValidMsg(vsMsg, poParentCtl, pnIdx);
							return false;
						}
					}else{
						for (var j = 0; j < vaXorNull.length; j++) {
							var vcCtl = ctrl.getAppInstance().lookup(vaXorNull[j]);
							var vsValue = vcCtl.value;
							if(!ValueUtil.isNull(vsValue)){
								vbStatus = true;
								break;
							}
							vsName += vcCtl.fieldLabel + " ,";
						}
						
						if(!vbStatus){
							//{0}중 하나는 필수 입력 항목입니다.
							var vsMsg = this._appKit.Msg.getMsg("WRN-M003", [vsName.substring(0, vsName.length -1)]);
							parentValidMsg(vsMsg, poParentCtl, pnIdx);
							return false;
						}
					}
				}
			}
			
			// 나머지 항목은 값이 있을 때만 체크
			if(ctrlValue == null || ctrlValue == "") return true;
			
			// type check
			{
				var type = ctrl.userAttr("columnType");
				if(type) {
					var isChk = true;
					if(type == "email"){
						isChk = this.isEmail(ctrlValue);
					}else if(type == "ssn"){
						isChk = this.isSSN(ctrlValue);
					}else if(type == "bizno"){
						isChk = this.isBizCSN(ctrlValue);
					}else if(type == "phone"){
						isChk = this.isTelMobile(ctrlValue);
					}else if(type == "tel"){
						isChk = this.isTelNo(ctrlValue);
					}else if(type == "url"){
						isChk = this.isURL(ctrlValue);
					}
					if(isChk == false) {
						vsFieldLabel = getGridFieldLabel(poParentCtl, vsFieldLabel);
						//{0}은(는) 유효하지 않은 형식입니다.
						var vsMsg = this._appKit.Msg.getMsg("WRN-M004", [vsFieldLabel]);
						parentValidMsg(vsMsg, poParentCtl, pnIdx);
						return false;
					}
				}
			}
			
			// minlength
			{
				var minlength = ctrl.userAttr("minlength");
				if(minlength) {
					var minlengthNum = Number(minlength);
					var length = ValueUtil.getLength(ctrlValue, ctrl.lengthUnit);
					if(length < minlength) {
						vsFieldLabel = getGridFieldLabel(poParentCtl, vsFieldLabel);
						//{0}은(는) {1}자 이상으로 입력하십시오.
						var vsMsg = this._appKit.Msg.getMsg("WRN-M005", [vsFieldLabel, minlength]);
						parentValidMsg(vsMsg, poParentCtl, pnIdx);
						return false;
					}
				}
			}
			
			// fixlength
			{
				var fixlength = ctrl.userAttr("fixlength");
				if(fixlength) {
					var fixlength = Number(fixlength);
					var length = ValueUtil.getLength(ctrlValue, ctrl.lengthUnit);
					if(length != fixlength) {
						vsFieldLabel = getGridFieldLabel(poParentCtl, vsFieldLabel);
						//{0}은(는) {1} 자리수만큼 입력하십시오.
						var vsMsg = this._appKit.Msg.getMsg("WRN-M006", [vsFieldLabel, fixlength]);
						parentValidMsg(vsMsg, poParentCtl, pnIdx);
						return false;
					}
				}
			}
			
			{
				//두 값을 비교
				//그리드 일경우 컬럼명, 일반 컨트롤일 경우 컨트롤 id
				var compare = ctrl.userAttr("compare");
				if(!ValueUtil.isNull(compare)) {
					var compareCol = compare.substring(0, compare.indexOf(","));
					var compareType = compare.substr(compare.indexOf(",") + 1).trim();
					//그리드 내 컨트롤
					var vbStatus = false;
					var vsCompareColValue;
		        	var vsCompareColLable;
		        	var value = ctrlValue;
					if(poParentCtl instanceof cpr.controls.Grid){
						vsCompareColValue = poRow != null ? poRow.getValue(compareCol) : poParentCtl.getCellValue(pnIdx, compareCol);
						var vcDetailColumn = poParentCtl.detail.getColumnByName(compareCol)[0];
						var vaHeaderCol = poParentCtl.header.getColumnByColIndex(vcDetailColumn.colIndex, vcDetailColumn.colSpan);
						if(vaHeaderCol.length > 0){
							var vcHeaderCtl = vaHeaderCol[0];
							if(vcHeaderCtl){
								vsCompareColLable = vcHeaderCtl.getText();
							}
						}
					}else{
						vsCompareColValue = ctrl.getAppInstance().lookup(compareCol).value;
						vsCompareColLable = ctrl.getAppInstance().lookup(compareCol).fieldLabel
					}
					
					if(!ValueUtil.isNull(value) && !ValueUtil.isNull(vsCompareColValue)){
						var vbReturn = false;
						if (ValueUtil.isNumber(value) && ValueUtil.isNumber(vsCompareColValue)) {
							vbReturn = eval(value + compareType + vsCompareColValue);
						}else{
							vbReturn = eval("'"+value+"'" + compareType + "'"+vsCompareColValue+"'");
						}
				            
			            if (!vbReturn) {
			            	 vsFieldLabel = getGridFieldLabel(poParentCtl, vsFieldLabel);
			            	 var vsMsg = "";
			            	if(compareType == "<=" || compareType == "<" ){
			            		//{0}은(는) {1}보다 클 수 없습니다.
			            		vsMsg = this._appKit.Msg.getMsg("WRN-M009", [vsFieldLabel, vsCompareColLable]);
			            	}else if (compareType == ">=" || compareType == ">" ){
			            		//{0}은(는) {1}보다 작을수 없습니다.
			            		vsMsg = this._appKit.Msg.getMsg("WRN-M010", [vsFieldLabel, vsCompareColLable]);
			            	}else if (compareType == "==" || compareType == "="){
			            		//{0}은(는) {1}와 같아야 합니다.
			            		vsMsg = this._appKit.Msg.getMsg("WRN-M011", [vsFieldLabel, vsCompareColLable]);
			            	}else{
			            		
			            	}
			            	parentValidMsg(vsMsg, poParentCtl, pnIdx);
			                return false;
			            }
					}
				}
			}
			return true;
		}
		
	});
})();
/// end - module/validation
/// start - portlet
/*
 * Module URI: portlet
 * SRC: portlet.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("portlet", function(exports, globals, module){
		///************************************************
		// * portlet.module.js
		// * Created at 2020. 10. 7. 오후 1:24:49.
		// *
		// * @author HANS
		// ************************************************/
		//
		///************************************************
		// * hansCustom.module.js
		// * Created at 2020. 2. 19. 오전 10:25:50.
		// *
		// * @author HANS
		// ************************************************/
		//
		///**
		// * 본 모듈은 폼 레이아웃 내에서 사용자가 구획을 드래그 앤 드랍하여 포틀릿의 특성을 구현하기 위해서 만들어진 공통 모듈입니다.
		// * 포틀릿을 구현한 뒤 개인화를 위해 쿠키에 저장하여 관리할 수 있습니다.
		// * 
		// * [사용법]
		// * 로드되는 모든 화면에 대해서 이벤트 캐치를 하지 않습니다.
		// * 따라서 각 화면의 BodyLoad시점에서 글로벌 함수 출판된 createDragManager를 사용하고 사용자속성을 정의합니다.
		// * 개인화를 하기위해서는 글로벌 함수로 출판된 portletIndividual을 사용합니다. 
		// * 개인화와 관련된 함수는 글로벌 함수인 portletIndividual의 하위에 속해있습니다.
		// * 
		// * 1. 포틀릿을 적용할 그룹(폼레이아웃일때만 가능)을 선택한 뒤, 선택한 그룹의 사용자 속성으로 portlet 을 정의하고 값은 Y로 지정합니다.
		// * 2. 해당 포틀릿이 한 화면에서 하나의 폼 레이아웃에서만 사용하는게 아닐 경우가 있을 수 있기 때문에, dataType이라는 사용자 속성을 사용하여 드래그소스,
		// * 	   드랍타겟에 대한 범위를 제한할 수 있습니다. (단, dataType속성에 대한 값은 unique해야 합니다.)
		// * 3. 화면이 로딩되었을 때, onBodyLoad이벤트리스너에서 출판된 메서드 createDragManager를 호출합니다. 호출 시 전달인자는 아래와 같습니다.
		// * 		1) 화면의 앱인스턴스
		// * 		2) 드래그앤드랍 시, 중복되는 컨트롤에 대한 포틀릿 여부(true/false)
		// * 4. 드래그앤드랍을 빈공간에 할 경우, 타겟컨트롤이 없는경우에는 드랍이 불가능합니다.
		// *     따라서 해당 구획에는 빈 그룹을 배치해야 가능합니다.
		// * 
		// * [사용가능한 메서드]
		// * 1. createDragManager : 드래그앤드롭을 시작합니다.
		// * 2. removeDragManager : 드래그앤드롭 객체를 삭제합니다.
		// * 3. setDragManagerStop : 전체 포틀릿 적용을 해제합니다.
		// * 4. setResizePortlet : 포틀릿을 확대/축소합니다. (마우스가 눌린 시점부터 발생하기 때문에 mouseDown 이벤트리스너에서 호출하여 사용합니다.)
		// * 5. setCookie : 쿠키를 생성합니다.
		// * 6. getCookie : 쿠키를 반환합니다. 반환되는 쿠키는 포틀릿의 constraint 형식으로 반환됩니다.
		// * 7. deketeCookie : 쿠키를 삭제합니다.
		// * 
		// */
		//
		//// TODO 없는 로우에 span 했을 경우 안되는거 고쳐야 할지 알 수 없음
		//
		//var mcFeedback; // 드래그 할 때 플로팅되는 컨트롤
		//var maDragSource = []; // 드래그 소스 배열
		//var maDropTarget =[];  // 드롭타겟 배열
		//var maDragDelta = null; // 드래그의 이동량
		//
		//var mbDraggable = true; // 포틀릿 적용 여부
		//var mbPermitDupl = true; // 중복컨트롤에 대해 포틀릿 이동 및 확대/축소 적용여부
		//var mbResize = false; // 소스컨트롤 확대 및 축소 여부
		//var mbIncreaseRow = true; // 드래그 시 row증가 여부
		//
		///**
		// * 드래그 시작하는 메서드
		// * @param {cpr.core.AppInstance} _app 앱인스턴스
		// * @param {Boolean} pbDuplicate 드래그앤드롭 시 아이템간 중복 시 드롭여부(true:중복된 아이템과 위치 스위칭, false : 드롭방지)
		// */
		//function createDragManager(_app, pbPermitDupl){
		//	
		//	if(pbPermitDupl != null) {
		//		mbPermitDupl = pbPermitDupl;
		//	}
		//	
		//	var voApp = _app;
		//	var voContainer = voApp.getContainer();
		//	
		//	var vaRecursiveCtrls = voContainer.getAllRecursiveChildren();
		//	var vaDraggableContainers = vaRecursiveCtrls.filter(function(each){
		//		if (each.userAttr("portlet")== "Y") {
		//			return each;
		//		}
		//	});
		//
		//	vaDraggableContainers.forEach(function(/** cpr.controls.Container*/each){
		//			var vsDataType = each.userAttr("dataType");
		//			each.getChildren().forEach(function(eachs){
		//				if(eachs.userAttr("isAlready") == "") {
		//					eachs.userAttr("isAlready","Y");				
		//					_createDragSource(voApp, eachs, vsDataType);
		//					_createDropTarget(eachs, vsDataType);
		//				}
		//		});
		//	});
		//}
		//
		///**
		// * 특정 그룹의 드래그앤드롭 속성을 삭제합니다.
		// * @param {cpr.controls.Container} pcContainer
		// */
		//function removeDragManager(pcContainer) {
		//
		//	if(pcContainer) {
		//		var vaRecursiveCtrls = pcContainer.getChildren();
		//		vaRecursiveCtrls.forEach(function(each){
		//			each.removeAllUserAttr();
		//		});
		//		
		//		var vsDataType = pcContainer.userAttr("dataType");
		//		maDragSource.forEach(function(each,idx){
		//			if(each.dataType == vsDataType) {
		//				maDropTarget[idx].dispose();
		//				maDragSource[idx].dispose();
		//			}
		//		});
		//	}
		//
		//}
		//
		///**
		// * 전체화면의 포틀릿 적용 여부를 저장합니다.
		// * @param {Boolean} pBool
		// */
		//function setDragManagerStop(pbDrag){
		//	mbDraggable = pbDrag
		//}
		//
		///**
		// * 포틀릿 특성이 적용되어 있을 때, 선택한 컨트롤의 확대/축소 여부를 저장합니다.
		// * @param {Boolean} pbResize
		// */
		//function setResizePortlet(pbResize) {
		//	mbResize = pbResize;
		//}
		//
		///**
		// * 드래그소스를 만들어주는 함수
		// * @param {cpr.core.AppInstance} _app
		// * @param {cpr.controls.UIControl} pcDragCtrl
		// * @param {any} psDataType
		// */
		//function _createDragSource(_app, pcDragCtrl, psDataType) {
		//	
		//	var voRootApp = _app.getRootAppInstance();
		//	var vnIncreateIndex = true;
		//	
		//	var dragSource = new cpr.controls.DragSource(pcDragCtrl, {
		//		options: {
		//			dataType: psDataType,
		//			threadhold: 10, // 10px만큼 이동해야 드래그시작으로 인식
		//		},
		//		
		//		onDragStart: function(context) {
		//
		//			if (mbDraggable) {
		//				
		//				if(context.source.control.type == "container" && context.source.control.getChildrenCount() == 0) {
		//					context.cancel();
		//				} else {
		//					var actualRect = pcDragCtrl.getActualRect();
		//					pcDragCtrl.style.css("opacity", " 0.5");
		//	
		//					if (mbResize == true) {
		//						// Span
		//						context.cursor = "se-resize";
		//						mcFeedback = _createDragSourceFeedback(actualRect, pcDragCtrl.getParent());
		//						voRootApp.floatControl(mcFeedback, actualRect);
		//					} else {
		//						// Drag
		//						context.cursor = "grabbing";
		//						mcFeedback = _createDragSourceFeedback(actualRect, pcDragCtrl.getParent());
		//						var newActualRect = actualRect.getTranslatedByDimension(context.dragDelta);
		//						voRootApp.floatControl(mcFeedback, cpr.controls.layouts.XYLayout.createConstraintWithRect(newActualRect));
		//					}
		//				}
		//
		//			} else {
		//				context.cancel();
		//			}
		//		},
		//		onDragMove: function(context) {
		//
		//			var actualRect = context.source.control.getActualRect();
		//			
		//			if (mbResize == true) {
		//				// Span
		//				context.cursor = "se-resize";
		//				maDragDelta = context.dragDelta;
		//
		//				var voFloatConstraint = getDragDirection(actualRect, pcDragCtrl);
		//				voRootApp.floatControl(mcFeedback, voFloatConstraint);
		//			} else {
		//				// Drag
		//				context.cursor = "grabbing";
		//				var newRect = actualRect.getTranslatedByDimension(context.dragDelta);
		//				voRootApp.floatControl(mcFeedback, cpr.controls.layouts.XYLayout.createConstraintWithRect(newRect));
		//				
		//				if(mbIncreaseRow== true) {
		//					var vcParent = pcDragCtrl.getParent();
		//					var voLayout = vcParent.getLayout();
		//					var voRow = voLayout.getRows();
		//					var voColumn = voLayout.getColumns();
		//				
		//					if(context.target == null) {
		//						var vnChildCount = vcParent.getChildrenCount();
		//						var voBlankContainer = vcParent.getChildren().filter(function(each) {
		//							if(each.type == "container" && each.getChildrenCount() == 0) {
		//								return each;
		//							}
		//						});
		//						var voLastChildRect = voBlankContainer[voBlankContainer.length-1].getActualRect();
		//						var voFeedbackRect= mcFeedback.getActualRect();
		//						
		//						var voFormLayout = new cpr.controls.layouts.FormLayout();
		//						voFormLayout.setColumns(voColumn);
		//						
		//						var voNewRow = voRow;
		//						if(voFeedbackRect.bottom > (vcParent.getActualRect().top + voLastChildRect.bottom) && voRow == voNewRow) {
		//							if(vnIncreateIndex == true) {
		//								voNewRow.push(voRow[0]);
		//								voFormLayout.setRows(voNewRow);
		//								vcParent.setLayout(voFormLayout);
		//								
		//								for(var idx = 0; idx < voColumn.length; idx++){
		//									var vcNewTarget = new cpr.controls.Container();
		//									vcParent.insertChild(vnChildCount-(vnChildCount-voBlankContainer.length), vcNewTarget, {
		//										rowIndex : voNewRow.length-1,
		//										colIndex : idx
		//									});
		//								}
		//								vnIncreateIndex = false;
		//							}
		//						}
		//						createDragManager(_app, mbPermitDupl);
		//					}
		//				}
		//			}
		//		},
		//		onDragEnd: function(context) {
		//
		//			if (mbResize == true && context.target) { // Span
		//				setFormSpan(pcDragCtrl);
		//			}
		//			
		//			// 마지막 row에 아무런 아이템이 없을경우 삭제
		//			removeBlankRow(pcDragCtrl);
		//
		//			context.cursor = "";
		//			mcFeedback.dispose();
		//			mcFeedback = null;
		//			pcDragCtrl.style.removeStyle("opacity");
		//			
		//			mbResize = false;
		//			vnIncreateIndex = true;
		//		}
		//	});
		//
		//	maDragSource.push(dragSource);
		//}
		//
		//
		///**
		// * 드래그소스의 부모객체를받아와서 부모객체에 드랍타겟을 만들어주는 함수
		// * @param {cpr.controls.Container} pcCtrlDrop
		// * @param {any} psDataType
		// */
		//function _createDropTarget(pcCtrlDrop, psDataType) {
		//	var vcContainer = pcCtrlDrop.getParent();
		//	var voLayout = vcContainer.getLayout();
		//
		//	var dropTarget = new cpr.controls.DropTarget(pcCtrlDrop, {
		//		isImportant: function(source) {
		//			return source.dataType == psDataType;
		//		},
		//		
		//		onDragEnter: function(context) {
		//			if (mbResize == false) { 
		//				// Drag 일 경우에만 타겟 스타일 적용
		//				context.target.control.style.css({
		//					"border": "solid 2px orange"
		//				});
		//			}
		//		},
		//		onDragLeave: function(context) {
		//			context.target.control.style.removeStyle("border");
		//		},
		//		onDragMove: function(context) {
		//		},
		//		onDrop: function(context) {
		//			if (mbResize == false) { 
		//				// Drag 일 경우에만 변경되 위치로 드롭
		//				var voTargetCtrlRect = vcContainer.getConstraint(context.target.control);
		//				var voSourceCtrlRect = vcContainer.getConstraint(context.source.control);
		//				context.target.control.style.removeStyle("border");
		//				
		//				var vnSrcRowSpan = voSourceCtrlRect.rowSpan ? voSourceCtrlRect.rowSpan : 1;
		//				var vnSrcColSpan = voSourceCtrlRect.colSpan ? voSourceCtrlRect.colSpan : 1;
		//				if(mbPermitDupl == true) {
		//					/* 중복허용 - 위치 스위칭 */
		//					// FIXME 타겟영역만큼 이동하는게 맞는걸까... 소스크기만큼 이동하는게 맞는걸까....
		//					
		//					// TODO 영역이동 시, 겹치는 아이템의 위치를 이동하십시오.
		//					
		//					// 소스컨트롤이 이동영역 안 일경우에만 constraint 변경
		//					if( voTargetCtrlRect.rowIndex + vnSrcRowSpan  <= vcContainer.getLayout().getRows().length &&  
		//						voTargetCtrlRect.colIndex + vnSrcColSpan  <= vcContainer.getLayout().getColumns().length) {
		//						// source 위치 이동
		//						vcContainer.updateConstraint(context.source.control, {
		//							rowIndex : voTargetCtrlRect.rowIndex,
		//							colIndex : voTargetCtrlRect.colIndex,
		//							rowSpan : voSourceCtrlRect.rowSpan,
		//							colSpan : voSourceCtrlRect.colSpan
		//						});
		//						// target 위치 이동
		//						vcContainer.updateConstraint(context.target.control,{
		//							rowIndex : voSourceCtrlRect.rowIndex,
		//							colIndex : voSourceCtrlRect.colIndex,
		//							rowSpan : voTargetCtrlRect.rowSpan,
		//							colSpan : voTargetCtrlRect.colSpan
		//						});
		//					}
		//				} else {
		//					/* 중복미허용 - 드롭방지 */
		//					if(context.target.control.type == "container" && context.target.control.getChildrenCount() == 0) {
		//						var voUpdateConstraint = {
		//							rowIndex : voTargetCtrlRect.rowIndex,
		//							colIndex : voTargetCtrlRect.colIndex,
		//							rowSpan : voSourceCtrlRect.rowSpan,
		//							colSpan : voSourceCtrlRect.colSpan
		//						};
		//						
		//						// 넓힌 영역에 겹치는 아이템 유무 확인(소스컨트롤 제외)
		//						var voDuplCtrl = vcContainer.getLayout().findControls(voUpdateConstraint).filter(function(each){
		//							if(each.type != "container" && each != context.source.control) {
		//								return each;
		//							}
		//						});
		//
		//						if(voDuplCtrl.length == 0 && 
		//							voUpdateConstraint.rowIndex + vnSrcRowSpan  <= vcContainer.getLayout().getRows().length &&  
		//							voUpdateConstraint.colIndex + vnSrcColSpan  <= vcContainer.getLayout().getColumns().length) {
		//								// 드롭간능 영역 중, 중복되는 아이템이 없을 경우에만 드롭
		//								vcContainer.updateConstraint(context.source.control, voUpdateConstraint); 
		//						}
		//					}
		//				}
		//			}
		//		}
		//	});
		//	
		//	maDropTarget.push(dropTarget);
		//}
		//
		//
		///**
		// * 이동하고자하는 영역을 잡고 마우스를 드래그할 때 구획에 대한 피드백을 제공하는 함수입니다.
		// * @param {cpr.geometry.Rectangle} voRect
		// * @param {cpr.controls.Container} pcParent
		// * @returns {cpr.controls.UIControl} feedbacks
		// */
		//function _createDragSourceFeedback(voRect, pcParent){
		//	
		//	var voParentRect = pcParent.getActualRect();
		//	var voRow = pcParent.getLayout().getRows();
		//	var vnColLen = pcParent.getLayout().getColumns().length;
		//	
		//	var feedbacks = new cpr.controls.Output("feed");
		//	feedbacks.style.css({
		//		"opacity" : "0.8",
		//		"width": voRect.width + "px",
		//		"height": voRect.height +"px",
		//		"min-width": (voParentRect.width / vnColLen) + "px",
		//		"min-height": voRow[0],
		//		"border": "solid 1px red",
		//		"text-align" : "center",
		//		"color" : "black",
		//		"border-radius": "10px",
		//		"background": "white",
		//		"box-shadow": "0px 2px 10px #ddd",
		//		"cursor": "se-resize"
		//	});
		//	return feedbacks;
		//}
		//
		//
		///**
		// * 전달받은 Constraint에서 rowSpan과 colSpan에 기본값을 넣어주기 위한 함수입니다.
		// * @param {cpr.controls.layouts.FormConstraint} poConstraint
		// * @returns {cpr.controls.layouts.FormConstraint} constraint
		// */
		//function _checkConstraint(poConstraint){
		//	
		//	var constraint = {
		//		"rowIndex" : poConstraint.rowIndex,
		//		"colIndex" : poConstraint.colIndex,
		//		"rowSpan" : poConstraint.rowSpan ? poConstraint.rowSpan : 1,
		//		"colSpan" : poConstraint.colSpan ? poConstraint.colSpan : 1
		//	}
		//
		//	return constraint;
		//}
		//
		//
		///**
		// * 이동이 끝났을 때 마지막 행이 모두 비어있을 경우 삭제합니다.
		// * @param {any} pcDragCtrl
		// */
		//function removeBlankRow (pcDragCtrl) {
		//	var voLayout = pcDragCtrl.getParent().getLayout();
		//	var voRows = voLayout.getRows();
		//	var voColumns = voLayout.getColumns();
		//	
		//	var voFindCtrls = [];
		//	for(var i = 0; i < voColumns.length; i++){
		//		var vcCtrl = voLayout.findControls({
		//			rowIndex : voRows.length-1,
		//			colIndex : i
		//		});
		//		if(vcCtrl.length == 1 && vcCtrl[0].getChildrenCount() == 0) voFindCtrls.push(vcCtrl);
		//	}
		//
		//	if(voFindCtrls.length == voColumns.length) {
		//		voRows.splice(voRows.length-1, 1);
		//		voFindCtrls.forEach(function(each){
		//			pcDragCtrl.getParent().removeChild(each[0], true);
		//		});
		//	}
		//	
		//	var voFormLayout = new cpr.controls.layouts.FormLayout();
		//	voFormLayout.setColumns(voColumns);
		//	voFormLayout.setRows(voRows);
		//	pcDragCtrl.getParent().setLayout(voFormLayout);
		//}
		//
		//
		///**
		// * 드래그 플로팅 constraint
		// * @param {any} poSourceRect
		// * @param {any} pcDragCtrl
		// * @return {cpr.controls.layouts.Constraint} constraint
		// */
		//function getDragDirection (poSourceRect, pcDragCtrl) {
		//	
		//	var vcParent = pcDragCtrl.getParent();
		//	var voConstraint = vcParent.getConstraint(pcDragCtrl);
		//	
		//	var vsTop = poSourceRect.top + "px";;
		//	var vsLeft = poSourceRect.left + "px";;
		//	var vsWidth = (poSourceRect.width + maDragDelta.width) + "px";
		//	var vsHeight = (poSourceRect.height + maDragDelta.height) + "px";
		//	
		//	if(voConstraint.rowSpan > 1 || voConstraint.colSpan > 1) {
		//		// 확장된 영역에서 피드백 크기 감소
		//		vsTop = poSourceRect.top + "px";			
		//		vsLeft = poSourceRect.left + "px";			
		//		vsWidth = (poSourceRect.width + maDragDelta.width) + "px";
		//		vsHeight = (poSourceRect.height + maDragDelta.height) + "px";
		//	}
		//
		//	/* 포틀릿 위치 벗어나지 않도록 영역 제한 */
		//	if(vsTop.split("px")[0] < vcParent.getActualRect().top) { // 위
		//		vsTop = vcParent.getActualRect().top + "px";
		//		vsHeight = mcFeedback.getActualRect().height + "px";
		//	}
		//	
		//	if(vsLeft.split("px")[0] < vcParent.getActualRect().left) { // 왼쪽
		//		vsLeft = vcParent.getActualRect().left + "px";
		//		vsWidth = mcFeedback.getActualRect().width + "px";
		//	} 
		//	
		//	if((parseInt(vsWidth.split("px")[0])+parseInt(vsLeft.split("px")[0])) > vcParent.getActualRect().right) { // 오른쪽
		//		vsWidth = (vcParent.getActualRect().right - vsLeft.split("px")[0]) + "px";
		//	}
		//	
		//	if((parseInt(vsHeight.split("px")[0])+parseInt(vsTop.split("px")[0])) > vcParent.getActualRect().bottom) { // 아래
		//		vsHeight = (vcParent.getActualRect().bottom - vsTop.split("px")[0]) + "px";
		//	}
		//
		//	return {
		//		top : vsTop, 
		//		left : vsLeft,
		//		width : vsWidth,
		//		height : vsHeight
		//	};
		//}
		//
		//
		///**
		// * 폼레이아웃 확대/축소(span)
		// * 타겟 영역의 절반 이상일 때만 확대/축소합니다.
		// * 폼레이아웃의 row와 column은 모두 같은 크기로만 구성되어있어야 합니다.
		// * @param {cpr.controls.Container} pcDragCtrl
		// */
		//function setFormSpan (pcDragCtrl) {
		//	
		//	var vcParent = pcDragCtrl.getParent();
		//	var voConstraint = vcParent.getConstraint(pcDragCtrl);
		//	var voLayout = vcParent.getLayout();
		//
		//	var vnRowLen = voLayout.getRows().length;
		//	var vnColLen = voLayout.getColumns().length;
		//	var vnOneWidth = voLayout.getColumns()[0].indexOf("fr") > 0 ? vcParent.getActualRect().width / vnColLen : voLayout.getColumns()[0].split("px")[0];
		//	var vnOneHeight = voLayout.getRows()[0].indexOf("fr") > 0 ? vcParent.getActualRect().height / vnRowLen : voLayout.getRows()[0].split("px")[0];
		//	
		//	/* span 영역 */
		//	var voActualRect = pcDragCtrl.getActualRect();
		//	var voFeedbackRect = mcFeedback.getActualRect();
		//	
		//	// 1. rowSpan
		//	var vnRowSpan = parseInt(Math.round(voFeedbackRect.height / vnOneHeight));
		//	if(vnRowSpan == 0) vnRowSpan =1 ; 
		//	
		//	// 2. colSpan
		//	var vnColSpan = parseInt(Math.round(voFeedbackRect.width / vnOneWidth));
		//	if(vnColSpan == 0) vnColSpan =1 ; 
		//
		//	// 3. rowIndex
		//	var vnRowIndex = voConstraint.rowIndex;
		//	if(voConstraint.rowSpan != vnRowSpan) {
		//		var vnRowDiff = voConstraint.rowSpan - vnRowSpan;
		//		if(maDragDelta.height < 0 && vnRowSpan > voConstraint.rowSpan) {
		//			vnRowIndex = vnRowIndex + vnRowDiff;
		//		}
		//	}
		//
		//	// 4. colIndex
		//	var vnColIndex = voConstraint.colIndex;
		//	if(voConstraint.colSpan != vnColSpan) {
		//		var vnColDiff = voConstraint.colSpan - vnColSpan;
		//		if(maDragDelta.width < 0 && vnColSpan > voConstraint.colSpan) {
		//			vnColIndex = vnColIndex + vnColDiff;
		//		}
		//	}
		//	
		//	var vcDuplCtrl = voLayout.findControls({
		//		rowIndex: vnRowIndex,
		//		colIndex: vnColIndex,
		//		rowSpan: vnRowSpan,
		//		colSpan: vnColSpan
		//	}).filter(function(each){
		//		if(each.type != "container" && each != pcDragCtrl) {
		//			return each;
		//		}
		//	});
		//	
		//	if(mbPermitDupl == false && vcDuplCtrl.length > 0) {
		//		return; // 겹침 방지
		//	}
		//	
		//	if(mbPermitDupl) {
		//		// TODO 영역을 확대할 때, 겹치는 아이템의 위치를 이동하십시오.
		//	}
		//	
		//	// 차트가 새로 그려질 수 있도록 삭제 후 추가
		//	vcParent.removeChild(pcDragCtrl);
		//	vcParent.addChild(pcDragCtrl, {
		//		rowIndex : vnRowIndex,
		//		colIndex : vnColIndex,
		//		rowSpan : vnRowSpan,
		//		colSpan :  vnColSpan
		//	});
		//}
		//
		//var portletIndvdl = function () {}
		//
		///**
		// * 개인화를 위한 constraint 쿠키에 저장
		// * @param {any} psName 쿠키명
		// * @param {cpr.controls.layouts.FormConstraint} paConstraint 
		// * @param {any} psExpireDate 유효기간
		// */
		//portletIndvdl.prototype.setCookie = function(psName, paConstraint, psExpireDate){
		//
		//	var vaContent = "";
		//	for (var key in paConstraint) {
		//		if(vaContent != "") {
		//			vaContent += ",";	
		//		}
		//		vaContent += "::" + paConstraint[key];
		//	}
		//
		//	var today = new Date();
		//	today.setDate(today.getDate() + parseInt(psExpireDate));
		//	document.cookie = psName + "=" + escape(vaContent) + ";path=/;expires=" + today.toGMTString() + ";";
		//}
		//
		//
		///**
		// * 쿠키확인 및 리턴
		// * @param {any} psName
		// * @return {cpr.controls.layouts.FormConstraint} constraint
		// */
		//portletIndvdl.prototype.getCookie = function(psName){
		//
		//	var vsCookieArr = getCookieByNm(psName);
		//	var vaData = [];
		//	
		//	if(vsCookieArr) {
		//		var vaNames = vsCookieArr.split("::");
		//	
		//		for (var idx in vaNames) {
		//			if(idx != 0) {
		//				if(vaNames[idx].indexOf("function") != -1) break;
		//				vaData.push(vaNames[idx]);
		//			}
		//		}
		//	}
		//	
		//	var vaRealData = [];
		//	for(var idx = 0; idx < vaData.length; idx++){
		//		var voEachConstraint = vaData[idx].split(",");
		//		vaRealData.push({
		//			rowIndex : parseInt(voEachConstraint[0]),
		//			colIndex : parseInt(voEachConstraint[1]),
		//			rowSpan : parseInt(voEachConstraint[2]) ? parseInt(voEachConstraint[2]) : 1,
		//			colSpan : parseInt(voEachConstraint[3]) ? parseInt(voEachConstraint[3]) : 1 
		//		})		
		//	}
		//	return vaRealData;
		//}
		//
		///**
		// * 쿠키확인
		// * @param {any} psName
		// */
		//function getCookieByNm(psName) {
		//	var cookie = document.cookie + ";";
		//
		//	var voItems = cookie.split(";");
		//	var vnItemLen = voItems.length;
		//	var item = null;
		//	var voItemInfo = null;
		//	for (var i = 0; i < vnItemLen; i++) {
		//		item = voItems[i];
		//		voItemInfo = item.split("=");
		//		if (psName == voItemInfo[0].trim()) {
		//			return unescape(voItemInfo[1]);
		//		}
		//	}
		//}
		//
		///**
		// * 쿠키삭제
		// * @param {any} psName
		// */
		//portletIndvdl.prototype.deleteCookie = function(psName){
		//	var voExpireDate = new Date();
		//	voExpireDate.setDate(voExpireDate.getDate() - 1);
		//	document.cookie = psName + "= " + "; expires=" + voExpireDate.toGMTString() + "; path=/";
		//}
		//
		//
		//globals.createDragManager = createDragManager;
		//globals.removeDragManager = removeDragManager;
		//globals.setDragManagerStop = setDragManagerStop;
		//globals.setResizePortlet = setResizePortlet;
		//globals.portletIndividual = function() {
		//	return new portletIndvdl();
		//}
	});
})();
/// end - portlet
/// start - savepoint
/*
 * Module URI: savepoint
 * SRC: savepoint.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("savepoint", function(exports, globals, module){
		///************************************************
		// * savepoint.module.js
		// * Created at 2020. 6. 17. 오후 1:43:25.
		// *
		// * @author HANS
		// ************************************************/
		//
		///************************************************
		// * createGrid.module.js
		// * Created at 2020. 6. 2. 오전 10:19:09.
		// *
		// * @author HANS
		// ************************************************/
		////서버에서 내려오는 빈값에 대한 양식이 null이거나 빈문자열일 수 있으므로, 지정된 양식에 맞추어서 해당 변수값을 변경하십시오.
		//var msNull = "";
		////헤더행 높이를 설정합니다.
		//var mnRowHeight = 40;
		////디테일행 높이를 설정합니다.
		//var mnDetailHeight = 24;
		//
		//var moGridStandardConfig = {
		//		"columns": [{
		//			"width": "100px"
		//		}, ],
		//		"header": {
		//			"rows": [{
		//				"height": "24px"
		//			}],
		//			"cells": [{
		//				"constraint": {
		//					"rowIndex": 0,
		//					"colIndex": 0
		//				},
		//				"configurator": function(cell) {}
		//			}]
		//		},
		//		"detail": {
		//			"rows": [{
		//				"height": "24px"
		//			}],
		//			"cells": [{
		//				"constraint": {
		//					"rowIndex": 0,
		//					"colIndex": 0
		//				},
		//				"configurator": function(cell) {}
		//				
		//			}]
		//		}
		//	};
		//	
		//
		//
		////그리드를 생성하는데 넘겨받은 데이터셋에서, 상위헤더로 사용되는게 아닌, 데이터를 표시하는 컬럼에 대한 정의를 가진 행들의 Row만 가지게 하는 변수입니다.
		///** @type cpr.data.Row[]*/
		//var vaUsedRows =[];
		//
		//globals.createGrid = createGrid;
		//
		///**
		// * 그리드를 동적으로 생성하는 함수입니다. 
		// * @param {cpr.data.DataSet} pcGridConfigDataSet 그리드의 컬럼 정보를 구성하는 데이터셋
		// * @param {cpr.data.DataSet} pcGridBindDataSet 그리드의 디테일 데이터를 구성하는 데이터셋
		// * @param {cpr.controls.Container} pcParent 그리드컨트롤을 포함시킬 그룹컨트롤
		// * @param {{eventNm : String , func : Function}[]} paEvents? 그리드에 연결할 이벤트{eventNm : String , func : Function}의 배열
		// */
		//function createGrid(pcGridConfigDataSet,pcGridBindDataSet,pcParent, paEvents){
		//
		//		var vcDataSet = pcGridConfigDataSet;
		//		var vcBindDataSet = pcGridBindDataSet;
		//		vcDataSet.setSort("ORDER_SEQ asc");
		//		var res =	headerDepth(vcDataSet);
		//		console.log("RES:::::::::::::::::::"+ res);
		//		/** @type cpr.controls.gridpart.GridConfig */
		//		var voGridInitConfig = {
		//			"dataSet" : {},
		//			"columns":[],
		//			"header" : {
		//				"rows" : [],
		//				"cells" : []
		//			},
		//			"detail" : {
		//				"rows": [],
		//				"cells" :[]
		//			}
		//		}
		//		
		//		var vcGrid = new cpr.controls.Grid("grdMst");
		//		
		//		if(vcDataSet.getRowCount() > 0) {
		//		
		//		vaUsedRows = classifyUsedColumn(vcDataSet);
		//		var vaAutoFit = vaUsedRows.filter(function(each){
		//			if(each.getValue("COLUMN_FIXYN")=="Y") {
		//				return each;
		//			}
		//		}).map(function(each){
		//			return each.getIndex();
		//		});
		//
		//		voGridInitConfig.dataSet = pcGridBindDataSet;
		////		voGridInitConfig.autoFit = vaAutoFit.toString();
		//
		//		for(var headerLeng = 0 ; headerLeng < res ; headerLeng++) {
		//			
		//			voGridInitConfig.header.rows.push({"height" : mnRowHeight+"px"});
		//		}
		//		
		//			vcDataSet.getRowDataRanged().forEach(function(each,idx){
		//			voGridInitConfig.header.cells.push({
		//				"constraint" : getGridHeaderConfig(vcDataSet, vcDataSet.getRow(idx),res),
		//				"configurator" :  function(cell) {
		//				cell.text = each["HEADER_NM"];
		//				cell.visible =each["HIDE_YN"] == "Y" ? false : true;
		//				}
		//			});
		//		});
		//		
		////			vaUsedRows.forEach(function(/*cpr.data.DataRow*/each,idx){
		////				voGridInitConfig.header.cells.push({
		////					"constraint" : getGridHeaderConfig(vcDataSet, each),
		////					"configurator" : function(cell){
		////						cell.text = each.getValue("HEADER_NM")
		////						cell.visible =each.getValue("HIDE_YN")== "Y" ? false : true;
		////					}
		////				});
		////			});
		//
		//		vcBindDataSet.getColumnNames().forEach(function(each,idx){
		//		/** @type cpr.data.Row */
		//			var voConfigRow = vaUsedRows[idx];
		////debugger;
		//			voGridInitConfig.columns.push({"width" : voConfigRow.getValue("COLUMN_WID")+"px"});
		//			voGridInitConfig.detail.cells.push({
		//				"constraint" :{"rowIndex" : 0, "colIndex" : idx},
		//				"configurator" : function(cell) {
		//					cell.columnName = each;
		//					cell.suppressible = voConfigRow.getValue("GROUP_MERGEYN") == 'Y' ? true : false;
		//					cell.control = (function(){
		//									var opts = createControlByType(voConfigRow.getValue("HEADER_TYP"), voConfigRow.getValue("COLUMN_FORMAT"));
		//									opts.bind("value").toDataColumn(each);
		//									return opts;
		//								})();
		//				}
		//			});
		//		});
		//		
		//		voGridInitConfig.detail.rows.push({"height" : mnDetailHeight+"px"});
		//		vcGrid.init(voGridInitConfig);
		//		} else {
		//			
		//			vcGrid.init(moGridStandardConfig);
		//		}
		//		if(paEvents && paEvents.length > 0) {
		//			
		//			paEvents.forEach(function(each){
		//				
		//				vcGrid.addEventListener(each.eventNm,each.func);
		//			});
		//		}	
		////		pcParent.addChild(vcGrid, {
		////			"rowIndex" : 0,
		////			"colIndex" : 0
		////		});
		//		
		//		return vcGrid;
		//}
		//
		//
		///**
		// * 그리드를 설정하는 데이터셋의 행별로 배치 속성을 구하는 함수입니다.
		// * @param {cpr.data.DataSet} pcDataSet
		// * @param {cpr.data.DataRow} poRow
		// * @param {Number} pnHeaderDepth
		// */
		//function getGridHeaderConfig(pcDataSet,poRow,pnHeaderDepth){
		//	
		//	var vcDataSet = pcDataSet;
		//
		//
		//	var vsParentId = poRow.getValue("PARENT_HDRID");
		//	var vsHeaderId = poRow.getValue("HEADER_ID");
		//	
		//	if(vsParentId) {
		//		
		//	}
		//	var vaChildrenCol= vcDataSet.findAllRow("PARENT_HDRID == '"+vsHeaderId+"'");
		//
		//	var vnRowIndex = vsParentId == msNull ? 0 : 1;
		//	var vnRowSpan = vsParentId == msNull ? 2 : 1;
		//	var vnColSpan = 1;
		//	
		//	var vnColIndex ;
		//
		//	//자기인덱스이전의 행들중 headerid가 parentId에 들어가는 행들을 뺴고 length를 구합니다. 
		//	if(vaChildrenCol.length > 0) {
		//		vnRowSpan = 1;
		//		vnColSpan = vaChildrenCol.length;
		//		}
		//		
		//		vnColIndex = checkColumnIndex(vcDataSet, poRow);	
		//	return {
		//		"rowIndex" : vnRowIndex,
		//		"colIndex" : vnColIndex,
		//		"rowSpan" : vnRowSpan,
		//		"colSpan" : vnColSpan
		//	}
		//}
		//
		///**
		// * 그리드를 설정하는 데이터셋의 행별로 컬럼이 배치되는 인덱스를 리턴하는 함수입니다. 
		// * @param {cpr.data.DataSet} pcDataSet
		// * @param {cpr.data.DataRow} poRow
		// */
		//function checkColumnIndex(pcDataSet, poRow){
		//		
		//		var vcDataSet = pcDataSet;
		//		var vnRowIndex = poRow.getIndex();
		//		var vaAllChild = vcDataSet.getUnfilteredDistinctValues("PARENT_HDRID");
		//		var vsExpress = "";
		//		
		//		var isHAN = vcDataSet.findAllRow("PARENT_HDRID == '"+poRow.getValue("HEADER_ID")+"'")
		//		if(isHAN.length > 0){
		//			return checkColumnIndex(vcDataSet, isHAN[0]);
		//			
		//		} else {
		//			
		//		vaAllChild.forEach(function(each){
		//			if(each != msNull){
		//				vsExpress += "HEADER_ID !='"+each+"' &&";
		//			}
		//		});
		//		vsExpress += "getIndex() < " + vnRowIndex;
		//		return vcDataSet.findAllRow(vsExpress).length;
		//		}
		//}
		//
		///**
		// * 그리드에서 상위헤더가 아닌, 실제 데이터를 보여주는 컬럼들을 배열로 리턴하는 함수입니다.
		// * 각 컬럼별 데이터 타입과 포맷 양식을 파악하기 위해 사용합니다.
		// * @param {cpr.data.DataSet} pcDataSet
		// * @returns {cpr.data.Row[]}
		// */
		//function classifyUsedColumn(pcDataSet) {
		//
		//    var vcDataSet = pcDataSet;
		//	
		//	if(vcDataSet.getRowCount() > 0){
		//		
		//    var vaAllChild = vcDataSet.getUnfilteredDistinctValues("PARENT_HDRID",function(/*cpr.data.DataRow*/dataRow){
		//    	return dataRow.getValue("PARENT_HDRID") != "";
		//    });
		//    var vsExpress = "";
		//    if(vaAllChild.length > 0) {
		//    	
		//    vaAllChild.forEach(function(each) {
		//            vsExpress += "HEADER_ID!='" + each + "'&&";
		//    });
		//
		//    vsExpress = vsExpress.slice(0, -2);
		//    } else {
		//    	vsExpress += true;
		//    }
		//    return vcDataSet.findAllRow(vsExpress);
		//	} else {
		//		return null;
		//	}
		//}
		//globals.classifyUsedColumn = classifyUsedColumn;
		///**
		// * 입력된 타입과 포맷을 가진 아웃풋 컨트롤을 리턴하는 함수입니다.
		// * @param {String} psType
		// * @param {String} psFormat
		// * @returns {cpr.controls.Output}
		// */
		//function createControlByType(psType,psFormat) {
		//	
		//	var vcOutput = new cpr.controls.Output();
		//	
		//	switch(psType){
		//		case "D" :
		//			vcOutput.dataType = "date";
		//			vcOutput.format = psFormat.toUpperCase();
		//			break;
		//		case "N" :
		//			
		//			vcOutput.dataType = "number";
		//			vcOutput.format = "s#,###.#";
		//			vcOutput.style.addClass("text-right");
		//			break;
		//		default :
		//		
		//			vcOutput.dataType = "string"
		//			break;
		//	}
		//	
		//	return vcOutput;
		//}
		//
		///**
		// * 멀티헤더일 경우 멀티헤더 갯수를 구하는 함수입니다.
		// * @param {cpr.data.DataSet} pcDataSet 데이터셋
		// * @return {Number} 헤더 갯수
		// */
		//function headerDepth(pcDataSet){
		//	
		//	var vcDataSet = pcDataSet;
		//	
		//	var vnHeaderDepth =1;
		//    var vaAllChild = vcDataSet.getUnfilteredDistinctValues("PARENT_HDRID",function(/*cpr.data.DataRow*/dataRow){
		//    	return dataRow.getValue("PARENT_HDRID") != "";
		//    });
		//    
		//    while(vaAllChild.length >0) {
		//    	
		//    	vnHeaderDepth += 1;
		//    	vaAllChild = vaAllChild.map(function(each){
		//    		var row = vcDataSet.findFirstRow("HEADER_ID == '"+each+"'").getValue("PARENT_HDRID");
		//    			
		//				return row;
		//    	}).filter(function(each){
		//    		return each != "";
		//    	});;
		//    	
		//    }
		//    return vnHeaderDepth;
		//}
		//
		///**
		// * 헤더의 상세 크기를 계산하는 함수입니다.
		// * @param {cpr.data.DataSet} pcDataSet
		// * @param {cpr.data.DataRow} poRow
		// * @param {Number} res
		// */
		//function getHeaderDeteil(pcDataSet, poRow,res){
		//		
		//		var vcDataSet = pcDataSet;
		//		var rowIndex = 0;
		//		var rowSpan = 1;
		//		var colSpan = 1;
		//		var header = poRow.getValue("HEADER_ID");
		//		var parent = poRow.getValue("PARENT_HDRID")
		//		
		//		var vaAllChild = vcDataSet.findAllRow("PARENT_HDRID == '"+header+"'");
		//		var temp = [];
		//		if(parent) {
		//			rowIndex = res-1;
		//			while(vaAllChild.length > 0 ){
		//				temp = [];
		//				rowIndex = rowIndex-1;
		////				vaAllChild = vaAllChild.map(function(each){
		////					return vcDataSet.findAllRow("HEADER_ID == '"+each+"'");
		////				}).map(function(eq){
		////					eq.
		////				});
		//				vaAllChild.map(function(each){
		//					return each.getValue("HEADER_ID");
		//				}).forEach(function(eachs){
		//					vcDataSet.findAllRow("PARENT_HDRID == '"+eachs+"'").map(function(eachss){
		//						return eachss.getValue("HEADER_ID");
		//					});
		//				});;
		//			}
		//			
		//			rowSpan = temp.length;
		//			
		////			var father = vcDataSet.findFirstRow("HEADER_ID == '"++"'")
		////			if(vaAllChild.length > 0) {
		////				//출생신고
		////				
		////				
		////				
		////				
		////			} else {
		////				rowSpan = 1;
		////				colSpan = 1;
		////			}
		//			
		//		} else {
		//			
		//			//부모가 없는데 내가 누군가의 부모인가?
		//			if(vaAllChild.length > 0) {
		//				//출생신고
		//			} else {
		//				//최상위
		//				rowIndex = 0;
		//				colSpan = 1;
		//				rowSpan = res-1;
		//			}
		//		}
		//						
		//}
		//
		//
		//function birthReport(){
		//	
		//}
	});
})();
/// end - savepoint
/// start - savepoint2
/*
 * Module URI: savepoint2
 * SRC: savepoint2.module.js
 *
 * This file was generated by eXbuilder6 compiler, Don't edit manually.
 */
(function(){
	cpr.core.Module.define("savepoint2", function(exports, globals, module){
		///************************************************
		// * savepoint2.module.js
		// * Created at 2020. 6. 18. 오후 3:19:30.
		// *
		// * @author HANS
		// ************************************************/
		//
		///************************************************
		// * createGrid.module.js
		// * Created at 2020. 6. 2. 오전 10:19:09.
		// *
		// * @author HANS
		// ************************************************/
		////서버에서 내려오는 빈값에 대한 양식이 null이거나 빈문자열일 수 있으므로, 지정된 양식에 맞추어서 해당 변수값을 변경하십시오.
		//var msNull = "";
		////헤더행 높이를 설정합니다.
		//var mnRowHeight = 40;
		////디테일행 높이를 설정합니다.
		//var mnDetailHeight = 24;
		//
		////그리드를 그리기위한 정보가 넘어오지 않을 경우, 기본 그리드를 그리기 위한 default grid initConfig입니다.
		//var moGridStandardConfig = {
		//		"columns": [{
		//			"width": "100px"
		//		}, ],
		//		"header": {
		//			"rows": [{
		//				"height": "24px"
		//			}],
		//			"cells": [{
		//				"constraint": {
		//					"rowIndex": 0,
		//					"colIndex": 0
		//				},
		//				"configurator": function(cell) {}
		//			}]
		//		},
		//		"detail": {
		//			"rows": [{
		//				"height": "24px"
		//			}],
		//			"cells": [{
		//				"constraint": {
		//					"rowIndex": 0,
		//					"colIndex": 0
		//				},
		//				"configurator": function(cell) {}
		//				
		//			}]
		//		}
		//	};
		//	
		//
		//
		////그리드를 생성하는데 넘겨받은 데이터셋에서, 상위헤더로 사용되는게 아닌, 데이터를 표시하는 컬럼에 대한 정의를 가진 행들의 Row만 가지게 하는 변수입니다.
		///** @type cpr.data.Row[]*/
		//var vaUsedRows =[];
		//
		//globals.createGrid = createGrid;
		//
		///**
		// * 그리드를 동적으로 생성하는 함수입니다. 
		// * @param {cpr.data.DataSet} pcGridConfigDataSet 그리드의 컬럼 정보를 구성하는 데이터셋
		// * @param {cpr.data.DataSet} pcGridBindDataSet 그리드의 디테일 데이터를 구성하는 데이터셋
		// * @param {cpr.controls.Container} pcParent 그리드컨트롤을 포함시킬 그룹컨트롤
		// * @param {{eventNm : String , func : Function}[]} paEvents? 그리드에 연결할 이벤트{eventNm : String , func : Function}의 배열
		// */
		//function createGrid(pcGridConfigDataSet,pcGridBindDataSet,pcParent, paEvents){
		//
		//		var vcDataSet = pcGridConfigDataSet;
		//		var vcBindDataSet = pcGridBindDataSet;
		//		vcDataSet.setSort("ORDER_SEQ asc");
		//		var res =	headerDepth(vcDataSet);
		//		console.log("전체크기 : " + res);
		//		/** @type cpr.controls.gridpart.GridConfig */
		//		var voGridInitConfig = {
		//			"dataSet" : {},
		//			"columns":[],
		//			"header" : {
		//				"rows" : [],
		//				"cells" : []
		//			},
		//			"detail" : {
		//				"rows": [],
		//				"cells" :[]
		//			}
		//		}
		//		
		//		var vcGrid = new cpr.controls.Grid("grdMst");
		//		
		//		if(vcDataSet.getRowCount() > 0) {
		//		
		//		vaUsedRows = classifyUsedColumn(vcDataSet);
		//		var vaAutoFit = vaUsedRows.filter(function(each){
		//			if(each.getValue("COLUMN_FIXYN")=="Y") {
		//				return each;
		//			}
		//		}).map(function(each){
		//			return each.getIndex();
		//		});
		//
		//		voGridInitConfig.dataSet = pcGridBindDataSet;
		////		voGridInitConfig.autoFit = vaAutoFit.toString();
		//
		//		for(var headerLeng = 0 ; headerLeng < res ; headerLeng++) {
		//			
		//			voGridInitConfig.header.rows.push({"height" : mnRowHeight+"px"});
		//		}
		//		
		//			vcDataSet.getRowDataRanged().forEach(function(each,idx){
		//			voGridInitConfig.header.cells.push({
		//				"constraint" : getGridHeaderConfig(vcDataSet, vcDataSet.getRow(idx),res),
		//				"configurator" :  function(cell) {
		//				cell.text = each["HEADER_NM"];
		//				cell.visible =each["HIDE_YN"] == "Y" ? false : true;
		//				}
		//			});
		//		});
		//		//삭제할 코드
		////			vaUsedRows.forEach(function(/*cpr.data.DataRow*/each,idx){
		////				voGridInitConfig.header.cells.push({
		////					"constraint" : getGridHeaderConfig(vcDataSet, each),
		////					"configurator" : function(cell){
		////						cell.text = each.getValue("HEADER_NM")
		////						cell.visible =each.getValue("HIDE_YN")== "Y" ? false : true;
		////					}
		////				});
		////			});
		//
		//		vcBindDataSet.getColumnNames().forEach(function(each,idx){
		//		/** @type cpr.data.Row */
		//			var voConfigRow = vaUsedRows[idx];
		//			voGridInitConfig.columns.push({"width" : voConfigRow.getValue("COLUMN_WID")+"px"});
		//			voGridInitConfig.detail.cells.push({
		//				"constraint" :{"rowIndex" : 0, "colIndex" : idx},
		//				"configurator" : function(cell) {
		//					cell.columnName = each;
		//					cell.suppressible = voConfigRow.getValue("GROUP_MERGEYN") == 'Y' ? true : false;
		//					cell.control = (function(){
		//									var opts = createControlByType(voConfigRow.getValue("HEADER_TYP"), voConfigRow.getValue("COLUMN_FORMAT"));
		//									opts.bind("value").toDataColumn(each);
		//									return opts;
		//								})();
		//				}
		//			});
		//		});
		//		
		//		voGridInitConfig.detail.rows.push({"height" : mnDetailHeight+"px"});
		//		vcGrid.init(voGridInitConfig);
		//		} else {
		//			
		//			vcGrid.init(moGridStandardConfig);
		//		}
		//		if(paEvents && paEvents.length > 0) {
		//			
		//			paEvents.forEach(function(each){
		//				
		//				vcGrid.addEventListener(each.eventNm,each.func);
		//			});
		//		}
		//		//그리드를 메인화면에서 추가시킬지, 여기서 추가시킬지 고민중
		////		pcParent.addChild(vcGrid, {
		////			"rowIndex" : 0,
		////			"colIndex" : 0
		////		});
		//		
		//		return vcGrid;
		//}
		//
		//
		///**
		// * 그리드를 설정하는 데이터셋의 행별로 배치 속성을 구하는 함수입니다.
		// * @param {cpr.data.DataSet} pcDataSet
		// * @param {cpr.data.DataRow} poRow
		// * @param {Number} pnHeaderDepth
		// */
		//function getGridHeaderConfig(pcDataSet,poRow,pnHeaderDepth){
		//	
		//	var vcDataSet = pcDataSet;
		//
		//
		//	var vsParentId = poRow.getValue("PARENT_HDRID");
		//	var vsHeaderId = poRow.getValue("HEADER_ID");
		//	
		//	if(vsParentId) {
		//		
		//	}
		//	var vaChildrenCol= vcDataSet.findAllRow("PARENT_HDRID == '"+vsHeaderId+"'");
		//
		////	var vnRowIndex = vsParentId == msNull ? 0 : 1;
		////	var vnRowSpan = vsParentId == msNull ? 2 : 1;
		////	var vnColSpan = 1;
		//	
		//	var vnColIndex ;
		//
		//	//자기인덱스이전의 행들중 headerid가 parentId에 들어가는 행들을 뺴고 length를 구합니다. 
		////	if(vaChildrenCol.length > 0) {
		////		vnRowSpan = 1;
		////		vnColSpan = vaChildrenCol.length;
		////		}
		//		
		//		vnColIndex = checkColumnIndex(vcDataSet, poRow);	
		//	var att = getHeaderDeteil(vcDataSet, poRow, pnHeaderDepth);
		//	
		//	att.colIndex = vnColIndex;
		//	
		//	console.log("HEADERNM : "+poRow.getValue("HEADER_NM"));
		//	console.log(att);
		//	return att;
		////	return {
		////		"rowIndex" : vnRowIndex,
		////		"colIndex" : vnColIndex,
		////		"rowSpan" : vnRowSpan,
		////		"colSpan" : vnColSpan
		////	}
		//}
		//
		///**
		// * 그리드를 설정하는 데이터셋의 행별로 컬럼이 배치되는 인덱스를 리턴하는 함수입니다. 
		// * @param {cpr.data.DataSet} pcDataSet
		// * @param {cpr.data.DataRow} poRow
		// * @return {Number}
		// */
		//function checkColumnIndex(pcDataSet, poRow){
		//		
		//		var vcDataSet = pcDataSet;
		//		var vnRowIndex = poRow.getIndex();
		//		var vaAllChild = vcDataSet.getUnfilteredDistinctValues("PARENT_HDRID");
		//		var vsExpress = "";
		//		var isHAN = vcDataSet.findAllRow("PARENT_HDRID == '"+poRow.getValue("HEADER_ID")+"'")//isHan = 특정금전신탁, 불특정금전신탁,금전신탁계
		//		if(isHAN.length > 0){
		////			console.log(isHAN[0].getValue("HEADER_NM"));
		////			if(poRow.getValue("HEADER_NM") == "금전신탁"){
		////			console.log(checkColumnIndex(vcDataSet, isHAN[0]));
		////			console.log(checkColumnIndex(vcDataSet, isHAN[1]));
		////			console.log(checkColumnIndex(vcDataSet, isHAN[2]));
		////			isHAN = isHAN.map(function(each){
		////				return checkColumnIndex(vcDataSet, each);
		////			}).sort();
		////			console.log(isHAN);
		////			}
		//
		//			isHAN = isHAN.map(function(each){
		//				return checkColumnIndex(vcDataSet, each);
		//			}).sort(function(a,b){
		//						return a-b;
		//					});
		//			
		//			return isHAN[0];
		////			return checkColumnIndex(vcDataSet, isHAN[0]);
		//		} else {
		//			
		//		vaAllChild.forEach(function(each){
		//			if(each != msNull){
		//				vsExpress += "HEADER_ID !='"+each+"' &&";
		//			}
		//		});
		//		vsExpress += "getIndex() < " + vnRowIndex;
		//		return vcDataSet.findAllRow(vsExpress).length;
		//		}
		//}
		//
		///**
		// * 그리드에서 상위헤더가 아닌, 실제 데이터를 보여주는 컬럼들을 배열로 리턴하는 함수입니다.
		// * 각 컬럼별 데이터 타입과 포맷 양식을 파악하기 위해 사용합니다.
		// * @param {cpr.data.DataSet} pcDataSet
		// * @returns {cpr.data.Row[]}
		// */
		//function classifyUsedColumn(pcDataSet) {
		//
		//    var vcDataSet = pcDataSet;
		//	
		//	if(vcDataSet.getRowCount() > 0){
		//		
		//    var vaAllChild = vcDataSet.getUnfilteredDistinctValues("PARENT_HDRID",function(/*cpr.data.DataRow*/dataRow){
		//    	return dataRow.getValue("PARENT_HDRID") != "";
		//    });
		//    var vsExpress = "";
		//    if(vaAllChild.length > 0) {
		//    	
		//    vaAllChild.forEach(function(each) {
		//            vsExpress += "HEADER_ID!='" + each + "'&&";
		//    });
		//
		//    vsExpress = vsExpress.slice(0, -2);
		//    } else {
		//    	vsExpress += true;
		//    }
		//    return vcDataSet.findAllRow(vsExpress);
		//	} else {
		//		return null;
		//	}
		//}
		//globals.classifyUsedColumn = classifyUsedColumn;
		///**
		// * 입력된 타입과 포맷을 가진 아웃풋 컨트롤을 리턴하는 함수입니다.
		// * @param {String} psType
		// * @param {String} psFormat
		// * @returns {cpr.controls.Output}
		// */
		//function createControlByType(psType,psFormat) {
		//	
		//	var vcOutput = new cpr.controls.Output();
		//	
		//	switch(psType){
		//		case "D" :
		//			vcOutput.dataType = "date";
		//			vcOutput.format = psFormat.toUpperCase();
		//			break;
		//		case "N" :
		//			
		//			vcOutput.dataType = "number";
		//			vcOutput.format = "s#,###.#";
		//			vcOutput.style.addClass("text-right");
		//			break;
		//		default :
		//		
		//			vcOutput.dataType = "string"
		//			break;
		//	}
		//	
		//	return vcOutput;
		//}
		//
		///**
		// * 멀티헤더일 경우 멀티헤더 갯수를 구하는 함수입니다.
		// * @param {cpr.data.DataSet} pcDataSet 데이터셋
		// * @return {Number} 헤더 갯수
		// */
		//function headerDepth(pcDataSet){
		//	
		//	var vcDataSet = pcDataSet;
		//	
		//	var vnHeaderDepth =1;
		//    var vaAllChild = vcDataSet.getUnfilteredDistinctValues("PARENT_HDRID",function(/*cpr.data.DataRow*/dataRow){
		//    	return dataRow.getValue("PARENT_HDRID") != "";
		//    });
		//    
		//    while(vaAllChild.length >0) {
		//    	
		//    	vnHeaderDepth += 1;
		//    	vaAllChild = vaAllChild.map(function(each){
		//    		var row = vcDataSet.findFirstRow("HEADER_ID == '"+each+"'").getValue("PARENT_HDRID");
		//    			
		//				return row;
		//    	}).filter(function(each){
		//    		return each != "";
		//    	});;
		//    	
		//    }
		//    return vnHeaderDepth;
		//}
		//
		///**
		// * 헤더의 상세 크기를 계산하는 함수입니다.
		// * @param {cpr.data.DataSet} pcDataSet
		// * @param {cpr.data.DataRow} poRow
		// * @param {Number} res
		// * @return {{rowIndex :Number, colIndex : Number, rowSpan : Number, colSpan : Number}}
		// */
		//function getHeaderDeteil(pcDataSet, poRow,res){
		//		
		//		var vcDataSet = pcDataSet;
		//		var rowIndex =0;
		//		var rowSpan = res;
		//		var colSpan = 1;
		//		var header = poRow.getValue("HEADER_ID");
		//		var parent = poRow.getValue("PARENT_HDRID")
		//		
		//		var allParent = vcDataSet.getUnfilteredDistinctValues("PARENT_HDRID",function(/*cpr.data.DataRow*/dataRow){
		//    	return dataRow.getValue("PARENT_HDRID") != "";
		//   		 });
		//   		 
		//
		//		var vaAllChild = vcDataSet.findAllRow("PARENT_HDRID == '"+header+"'").map(function(each){
		//			return each.getValue("HEADER_ID");
		//		}).filter(function(eachs){
		//			return eachs != "";
		//		});
		////		if(poRow.getValue("HEADER_NM")=="불특정금전신탁"){
		////			debugger;
		////		}
		//		var temp = [];
		//		var avengers = 0;
		//		if(parent) {
		//			if(vaAllChild.length > 0) {
		//				
		//			rowIndex = res-1;
		//			rowSpan = res-1;
		//			while(vaAllChild.length > 0) {//이부분에서 colSpan이 중요
		//				temp = vaAllChild;
		//				var a =[];
		//				rowIndex = rowIndex-1;
		//				rowSpan = rowSpan-1;
		//				vaAllChild.forEach(function(each){
		//					var hanj = vcDataSet.findAllRow("PARENT_HDRID == '"+each+"'");
		//					if(hanj.length <1) {
		//						avengers += 1;
		//					} 
		//					a = a.concat(hanj);
		//					
		//				});
		//				vaAllChild = a;
		//					
		//			}
		////			colSpan = temp.length > 0 ? temp.length : 1;
		//			colSpan = avengers;
		//		
		//			} else {
		//				rowIndex += 1;
		//				rowSpan = rowSpan -1;
		//				var han = vcDataSet.findFirstRow("HEADER_ID == '"+parent+"'");
		//				while(han.getValue("PARENT_HDRID") !=""){
		//				rowSpan = rowSpan -1;
		//				rowIndex += 1;
		//					han = vcDataSet.findFirstRow("HEADER_ID =='"+han.getValue("PARENT_HDRID")+"'");
		//				}
		//				
		//			}
		//		} else {
		//			
		//			//부모가 없는데 내가 누군가의 부모인가?
		//			if(vaAllChild.length > 0) {
		//				//출생신고
		//				rowIndex = res-1;
		//				rowSpan = res;
		//			while(vaAllChild.length > 0) {
		//				temp = vaAllChild;
		//				var a =[];
		//				rowIndex = rowIndex-1;
		//				rowSpan = rowSpan -1;
		//				vaAllChild.forEach(function(each){
		//					var hanj = vcDataSet.findAllRow("PARENT_HDRID == '"+each+"'");
		//					if(hanj.length <1) {
		//						avengers += 1;
		//					} 
		//					a = a.concat(hanj);
		//					
		//				});
		//				vaAllChild = a;
		//					
		//			}
		////			rowSpan = 1;//여기까지했음, 금전신탁 rowSpan이 계속 3이었음 => 상단에서 rowSpan 논리적으로 해결하는 로직으로 대체됨
		////			colSpan = temp.length > 0 ? temp.length : 1;
		//			colSpan = avengers;
		//		
		//			} else {
		//				//최상위
		//				rowIndex = 0;
		//				colSpan = 1;
		//				rowSpan = res;
		//			}
		//		}
		//		
		////	console.log("header : "+ poRow.getValue("HEADER_NM"));
		////	console.log("rowIndex : "+rowIndex);
		////	console.log("colSpan :"+colSpan);
		////	console.log("rowSpan : " +rowSpan);
		//	
		//	return {
		//		"rowIndex" : rowIndex,
		//		"colIndex" : 0,
		//		"rowSpan" : rowSpan,
		//		"colSpan" : colSpan
		//	}
		//}
		//
		//
		//function birthReport(){
		//	
		//}
	});
})();
/// end - savepoint2
